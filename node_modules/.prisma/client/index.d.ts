
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model detalle_factura
 * 
 */
export type detalle_factura = $Result.DefaultSelection<Prisma.$detalle_facturaPayload>
/**
 * Model facturas
 * 
 */
export type facturas = $Result.DefaultSelection<Prisma.$facturasPayload>
/**
 * Model ConversionFactor
 * 
 */
export type ConversionFactor = $Result.DefaultSelection<Prisma.$ConversionFactorPayload>
/**
 * Model kardex_materia_prima
 * 
 */
export type kardex_materia_prima = $Result.DefaultSelection<Prisma.$kardex_materia_primaPayload>
/**
 * Model kardex_productos
 * 
 */
export type kardex_productos = $Result.DefaultSelection<Prisma.$kardex_productosPayload>
/**
 * Model materia_prima
 * 
 */
export type materia_prima = $Result.DefaultSelection<Prisma.$materia_primaPayload>
/**
 * Model monedas
 * 
 */
export type monedas = $Result.DefaultSelection<Prisma.$monedasPayload>
/**
 * Model productos_terminados
 * 
 */
export type productos_terminados = $Result.DefaultSelection<Prisma.$productos_terminadosPayload>
/**
 * Model productos_especiales
 * 
 */
export type productos_especiales = $Result.DefaultSelection<Prisma.$productos_especialesPayload>
/**
 * Model proveedores
 * 
 */
export type proveedores = $Result.DefaultSelection<Prisma.$proveedoresPayload>
/**
 * Model recetas
 * 
 */
export type recetas = $Result.DefaultSelection<Prisma.$recetasPayload>
/**
 * Model unidadesmedida
 * 
 */
export type unidadesmedida = $Result.DefaultSelection<Prisma.$unidadesmedidaPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Detalle_facturas
 * const detalle_facturas = await prisma.detalle_factura.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Detalle_facturas
   * const detalle_facturas = await prisma.detalle_factura.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.detalle_factura`: Exposes CRUD operations for the **detalle_factura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detalle_facturas
    * const detalle_facturas = await prisma.detalle_factura.findMany()
    * ```
    */
  get detalle_factura(): Prisma.detalle_facturaDelegate<ExtArgs>;

  /**
   * `prisma.facturas`: Exposes CRUD operations for the **facturas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facturas
    * const facturas = await prisma.facturas.findMany()
    * ```
    */
  get facturas(): Prisma.facturasDelegate<ExtArgs>;

  /**
   * `prisma.conversionFactor`: Exposes CRUD operations for the **ConversionFactor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversionFactors
    * const conversionFactors = await prisma.conversionFactor.findMany()
    * ```
    */
  get conversionFactor(): Prisma.ConversionFactorDelegate<ExtArgs>;

  /**
   * `prisma.kardex_materia_prima`: Exposes CRUD operations for the **kardex_materia_prima** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kardex_materia_primas
    * const kardex_materia_primas = await prisma.kardex_materia_prima.findMany()
    * ```
    */
  get kardex_materia_prima(): Prisma.kardex_materia_primaDelegate<ExtArgs>;

  /**
   * `prisma.kardex_productos`: Exposes CRUD operations for the **kardex_productos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kardex_productos
    * const kardex_productos = await prisma.kardex_productos.findMany()
    * ```
    */
  get kardex_productos(): Prisma.kardex_productosDelegate<ExtArgs>;

  /**
   * `prisma.materia_prima`: Exposes CRUD operations for the **materia_prima** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materia_primas
    * const materia_primas = await prisma.materia_prima.findMany()
    * ```
    */
  get materia_prima(): Prisma.materia_primaDelegate<ExtArgs>;

  /**
   * `prisma.monedas`: Exposes CRUD operations for the **monedas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monedas
    * const monedas = await prisma.monedas.findMany()
    * ```
    */
  get monedas(): Prisma.monedasDelegate<ExtArgs>;

  /**
   * `prisma.productos_terminados`: Exposes CRUD operations for the **productos_terminados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos_terminados
    * const productos_terminados = await prisma.productos_terminados.findMany()
    * ```
    */
  get productos_terminados(): Prisma.productos_terminadosDelegate<ExtArgs>;

  /**
   * `prisma.productos_especiales`: Exposes CRUD operations for the **productos_especiales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos_especiales
    * const productos_especiales = await prisma.productos_especiales.findMany()
    * ```
    */
  get productos_especiales(): Prisma.productos_especialesDelegate<ExtArgs>;

  /**
   * `prisma.proveedores`: Exposes CRUD operations for the **proveedores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedores
    * const proveedores = await prisma.proveedores.findMany()
    * ```
    */
  get proveedores(): Prisma.proveedoresDelegate<ExtArgs>;

  /**
   * `prisma.recetas`: Exposes CRUD operations for the **recetas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recetas
    * const recetas = await prisma.recetas.findMany()
    * ```
    */
  get recetas(): Prisma.recetasDelegate<ExtArgs>;

  /**
   * `prisma.unidadesmedida`: Exposes CRUD operations for the **unidadesmedida** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Unidadesmedidas
    * const unidadesmedidas = await prisma.unidadesmedida.findMany()
    * ```
    */
  get unidadesmedida(): Prisma.unidadesmedidaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    detalle_factura: 'detalle_factura',
    facturas: 'facturas',
    ConversionFactor: 'ConversionFactor',
    kardex_materia_prima: 'kardex_materia_prima',
    kardex_productos: 'kardex_productos',
    materia_prima: 'materia_prima',
    monedas: 'monedas',
    productos_terminados: 'productos_terminados',
    productos_especiales: 'productos_especiales',
    proveedores: 'proveedores',
    recetas: 'recetas',
    unidadesmedida: 'unidadesmedida'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "detalle_factura" | "facturas" | "conversionFactor" | "kardex_materia_prima" | "kardex_productos" | "materia_prima" | "monedas" | "productos_terminados" | "productos_especiales" | "proveedores" | "recetas" | "unidadesmedida"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      detalle_factura: {
        payload: Prisma.$detalle_facturaPayload<ExtArgs>
        fields: Prisma.detalle_facturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detalle_facturaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_facturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detalle_facturaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_facturaPayload>
          }
          findFirst: {
            args: Prisma.detalle_facturaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_facturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detalle_facturaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_facturaPayload>
          }
          findMany: {
            args: Prisma.detalle_facturaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_facturaPayload>[]
          }
          create: {
            args: Prisma.detalle_facturaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_facturaPayload>
          }
          createMany: {
            args: Prisma.detalle_facturaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.detalle_facturaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_facturaPayload>[]
          }
          delete: {
            args: Prisma.detalle_facturaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_facturaPayload>
          }
          update: {
            args: Prisma.detalle_facturaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_facturaPayload>
          }
          deleteMany: {
            args: Prisma.detalle_facturaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.detalle_facturaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.detalle_facturaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_facturaPayload>
          }
          aggregate: {
            args: Prisma.Detalle_facturaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetalle_factura>
          }
          groupBy: {
            args: Prisma.detalle_facturaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Detalle_facturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.detalle_facturaCountArgs<ExtArgs>
            result: $Utils.Optional<Detalle_facturaCountAggregateOutputType> | number
          }
        }
      }
      facturas: {
        payload: Prisma.$facturasPayload<ExtArgs>
        fields: Prisma.facturasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.facturasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.facturasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          findFirst: {
            args: Prisma.facturasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.facturasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          findMany: {
            args: Prisma.facturasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>[]
          }
          create: {
            args: Prisma.facturasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          createMany: {
            args: Prisma.facturasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.facturasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>[]
          }
          delete: {
            args: Prisma.facturasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          update: {
            args: Prisma.facturasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          deleteMany: {
            args: Prisma.facturasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.facturasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.facturasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturasPayload>
          }
          aggregate: {
            args: Prisma.FacturasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacturas>
          }
          groupBy: {
            args: Prisma.facturasGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacturasGroupByOutputType>[]
          }
          count: {
            args: Prisma.facturasCountArgs<ExtArgs>
            result: $Utils.Optional<FacturasCountAggregateOutputType> | number
          }
        }
      }
      ConversionFactor: {
        payload: Prisma.$ConversionFactorPayload<ExtArgs>
        fields: Prisma.ConversionFactorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversionFactorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionFactorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversionFactorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionFactorPayload>
          }
          findFirst: {
            args: Prisma.ConversionFactorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionFactorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversionFactorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionFactorPayload>
          }
          findMany: {
            args: Prisma.ConversionFactorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionFactorPayload>[]
          }
          create: {
            args: Prisma.ConversionFactorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionFactorPayload>
          }
          createMany: {
            args: Prisma.ConversionFactorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversionFactorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionFactorPayload>[]
          }
          delete: {
            args: Prisma.ConversionFactorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionFactorPayload>
          }
          update: {
            args: Prisma.ConversionFactorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionFactorPayload>
          }
          deleteMany: {
            args: Prisma.ConversionFactorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversionFactorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversionFactorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionFactorPayload>
          }
          aggregate: {
            args: Prisma.ConversionFactorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversionFactor>
          }
          groupBy: {
            args: Prisma.ConversionFactorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversionFactorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversionFactorCountArgs<ExtArgs>
            result: $Utils.Optional<ConversionFactorCountAggregateOutputType> | number
          }
        }
      }
      kardex_materia_prima: {
        payload: Prisma.$kardex_materia_primaPayload<ExtArgs>
        fields: Prisma.kardex_materia_primaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kardex_materia_primaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_materia_primaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kardex_materia_primaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_materia_primaPayload>
          }
          findFirst: {
            args: Prisma.kardex_materia_primaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_materia_primaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kardex_materia_primaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_materia_primaPayload>
          }
          findMany: {
            args: Prisma.kardex_materia_primaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_materia_primaPayload>[]
          }
          create: {
            args: Prisma.kardex_materia_primaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_materia_primaPayload>
          }
          createMany: {
            args: Prisma.kardex_materia_primaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.kardex_materia_primaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_materia_primaPayload>[]
          }
          delete: {
            args: Prisma.kardex_materia_primaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_materia_primaPayload>
          }
          update: {
            args: Prisma.kardex_materia_primaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_materia_primaPayload>
          }
          deleteMany: {
            args: Prisma.kardex_materia_primaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kardex_materia_primaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kardex_materia_primaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_materia_primaPayload>
          }
          aggregate: {
            args: Prisma.Kardex_materia_primaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKardex_materia_prima>
          }
          groupBy: {
            args: Prisma.kardex_materia_primaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kardex_materia_primaGroupByOutputType>[]
          }
          count: {
            args: Prisma.kardex_materia_primaCountArgs<ExtArgs>
            result: $Utils.Optional<Kardex_materia_primaCountAggregateOutputType> | number
          }
        }
      }
      kardex_productos: {
        payload: Prisma.$kardex_productosPayload<ExtArgs>
        fields: Prisma.kardex_productosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kardex_productosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_productosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kardex_productosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_productosPayload>
          }
          findFirst: {
            args: Prisma.kardex_productosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_productosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kardex_productosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_productosPayload>
          }
          findMany: {
            args: Prisma.kardex_productosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_productosPayload>[]
          }
          create: {
            args: Prisma.kardex_productosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_productosPayload>
          }
          createMany: {
            args: Prisma.kardex_productosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.kardex_productosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_productosPayload>[]
          }
          delete: {
            args: Prisma.kardex_productosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_productosPayload>
          }
          update: {
            args: Prisma.kardex_productosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_productosPayload>
          }
          deleteMany: {
            args: Prisma.kardex_productosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kardex_productosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kardex_productosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kardex_productosPayload>
          }
          aggregate: {
            args: Prisma.Kardex_productosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKardex_productos>
          }
          groupBy: {
            args: Prisma.kardex_productosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kardex_productosGroupByOutputType>[]
          }
          count: {
            args: Prisma.kardex_productosCountArgs<ExtArgs>
            result: $Utils.Optional<Kardex_productosCountAggregateOutputType> | number
          }
        }
      }
      materia_prima: {
        payload: Prisma.$materia_primaPayload<ExtArgs>
        fields: Prisma.materia_primaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.materia_primaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materia_primaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.materia_primaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materia_primaPayload>
          }
          findFirst: {
            args: Prisma.materia_primaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materia_primaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.materia_primaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materia_primaPayload>
          }
          findMany: {
            args: Prisma.materia_primaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materia_primaPayload>[]
          }
          create: {
            args: Prisma.materia_primaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materia_primaPayload>
          }
          createMany: {
            args: Prisma.materia_primaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.materia_primaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materia_primaPayload>[]
          }
          delete: {
            args: Prisma.materia_primaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materia_primaPayload>
          }
          update: {
            args: Prisma.materia_primaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materia_primaPayload>
          }
          deleteMany: {
            args: Prisma.materia_primaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.materia_primaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.materia_primaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materia_primaPayload>
          }
          aggregate: {
            args: Prisma.Materia_primaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMateria_prima>
          }
          groupBy: {
            args: Prisma.materia_primaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Materia_primaGroupByOutputType>[]
          }
          count: {
            args: Prisma.materia_primaCountArgs<ExtArgs>
            result: $Utils.Optional<Materia_primaCountAggregateOutputType> | number
          }
        }
      }
      monedas: {
        payload: Prisma.$monedasPayload<ExtArgs>
        fields: Prisma.monedasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monedasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monedasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          findFirst: {
            args: Prisma.monedasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monedasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          findMany: {
            args: Prisma.monedasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>[]
          }
          create: {
            args: Prisma.monedasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          createMany: {
            args: Prisma.monedasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.monedasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>[]
          }
          delete: {
            args: Prisma.monedasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          update: {
            args: Prisma.monedasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          deleteMany: {
            args: Prisma.monedasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monedasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monedasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          aggregate: {
            args: Prisma.MonedasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonedas>
          }
          groupBy: {
            args: Prisma.monedasGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonedasGroupByOutputType>[]
          }
          count: {
            args: Prisma.monedasCountArgs<ExtArgs>
            result: $Utils.Optional<MonedasCountAggregateOutputType> | number
          }
        }
      }
      productos_terminados: {
        payload: Prisma.$productos_terminadosPayload<ExtArgs>
        fields: Prisma.productos_terminadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productos_terminadosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_terminadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productos_terminadosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_terminadosPayload>
          }
          findFirst: {
            args: Prisma.productos_terminadosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_terminadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productos_terminadosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_terminadosPayload>
          }
          findMany: {
            args: Prisma.productos_terminadosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_terminadosPayload>[]
          }
          create: {
            args: Prisma.productos_terminadosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_terminadosPayload>
          }
          createMany: {
            args: Prisma.productos_terminadosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productos_terminadosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_terminadosPayload>[]
          }
          delete: {
            args: Prisma.productos_terminadosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_terminadosPayload>
          }
          update: {
            args: Prisma.productos_terminadosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_terminadosPayload>
          }
          deleteMany: {
            args: Prisma.productos_terminadosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productos_terminadosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.productos_terminadosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_terminadosPayload>
          }
          aggregate: {
            args: Prisma.Productos_terminadosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductos_terminados>
          }
          groupBy: {
            args: Prisma.productos_terminadosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Productos_terminadosGroupByOutputType>[]
          }
          count: {
            args: Prisma.productos_terminadosCountArgs<ExtArgs>
            result: $Utils.Optional<Productos_terminadosCountAggregateOutputType> | number
          }
        }
      }
      productos_especiales: {
        payload: Prisma.$productos_especialesPayload<ExtArgs>
        fields: Prisma.productos_especialesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productos_especialesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_especialesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productos_especialesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_especialesPayload>
          }
          findFirst: {
            args: Prisma.productos_especialesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_especialesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productos_especialesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_especialesPayload>
          }
          findMany: {
            args: Prisma.productos_especialesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_especialesPayload>[]
          }
          create: {
            args: Prisma.productos_especialesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_especialesPayload>
          }
          createMany: {
            args: Prisma.productos_especialesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productos_especialesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_especialesPayload>[]
          }
          delete: {
            args: Prisma.productos_especialesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_especialesPayload>
          }
          update: {
            args: Prisma.productos_especialesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_especialesPayload>
          }
          deleteMany: {
            args: Prisma.productos_especialesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productos_especialesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.productos_especialesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productos_especialesPayload>
          }
          aggregate: {
            args: Prisma.Productos_especialesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductos_especiales>
          }
          groupBy: {
            args: Prisma.productos_especialesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Productos_especialesGroupByOutputType>[]
          }
          count: {
            args: Prisma.productos_especialesCountArgs<ExtArgs>
            result: $Utils.Optional<Productos_especialesCountAggregateOutputType> | number
          }
        }
      }
      proveedores: {
        payload: Prisma.$proveedoresPayload<ExtArgs>
        fields: Prisma.proveedoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.proveedoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.proveedoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedoresPayload>
          }
          findFirst: {
            args: Prisma.proveedoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.proveedoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedoresPayload>
          }
          findMany: {
            args: Prisma.proveedoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedoresPayload>[]
          }
          create: {
            args: Prisma.proveedoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedoresPayload>
          }
          createMany: {
            args: Prisma.proveedoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.proveedoresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedoresPayload>[]
          }
          delete: {
            args: Prisma.proveedoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedoresPayload>
          }
          update: {
            args: Prisma.proveedoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedoresPayload>
          }
          deleteMany: {
            args: Prisma.proveedoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.proveedoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.proveedoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proveedoresPayload>
          }
          aggregate: {
            args: Prisma.ProveedoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProveedores>
          }
          groupBy: {
            args: Prisma.proveedoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProveedoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.proveedoresCountArgs<ExtArgs>
            result: $Utils.Optional<ProveedoresCountAggregateOutputType> | number
          }
        }
      }
      recetas: {
        payload: Prisma.$recetasPayload<ExtArgs>
        fields: Prisma.recetasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recetasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recetasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetasPayload>
          }
          findFirst: {
            args: Prisma.recetasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recetasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetasPayload>
          }
          findMany: {
            args: Prisma.recetasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetasPayload>[]
          }
          create: {
            args: Prisma.recetasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetasPayload>
          }
          createMany: {
            args: Prisma.recetasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.recetasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetasPayload>[]
          }
          delete: {
            args: Prisma.recetasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetasPayload>
          }
          update: {
            args: Prisma.recetasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetasPayload>
          }
          deleteMany: {
            args: Prisma.recetasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recetasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.recetasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recetasPayload>
          }
          aggregate: {
            args: Prisma.RecetasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecetas>
          }
          groupBy: {
            args: Prisma.recetasGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecetasGroupByOutputType>[]
          }
          count: {
            args: Prisma.recetasCountArgs<ExtArgs>
            result: $Utils.Optional<RecetasCountAggregateOutputType> | number
          }
        }
      }
      unidadesmedida: {
        payload: Prisma.$unidadesmedidaPayload<ExtArgs>
        fields: Prisma.unidadesmedidaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.unidadesmedidaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unidadesmedidaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.unidadesmedidaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unidadesmedidaPayload>
          }
          findFirst: {
            args: Prisma.unidadesmedidaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unidadesmedidaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.unidadesmedidaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unidadesmedidaPayload>
          }
          findMany: {
            args: Prisma.unidadesmedidaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unidadesmedidaPayload>[]
          }
          create: {
            args: Prisma.unidadesmedidaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unidadesmedidaPayload>
          }
          createMany: {
            args: Prisma.unidadesmedidaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.unidadesmedidaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unidadesmedidaPayload>[]
          }
          delete: {
            args: Prisma.unidadesmedidaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unidadesmedidaPayload>
          }
          update: {
            args: Prisma.unidadesmedidaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unidadesmedidaPayload>
          }
          deleteMany: {
            args: Prisma.unidadesmedidaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.unidadesmedidaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.unidadesmedidaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unidadesmedidaPayload>
          }
          aggregate: {
            args: Prisma.UnidadesmedidaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnidadesmedida>
          }
          groupBy: {
            args: Prisma.unidadesmedidaGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnidadesmedidaGroupByOutputType>[]
          }
          count: {
            args: Prisma.unidadesmedidaCountArgs<ExtArgs>
            result: $Utils.Optional<UnidadesmedidaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type FacturasCountOutputType
   */

  export type FacturasCountOutputType = {
    detalle_factura: number
  }

  export type FacturasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_factura?: boolean | FacturasCountOutputTypeCountDetalle_facturaArgs
  }

  // Custom InputTypes
  /**
   * FacturasCountOutputType without action
   */
  export type FacturasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacturasCountOutputType
     */
    select?: FacturasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacturasCountOutputType without action
   */
  export type FacturasCountOutputTypeCountDetalle_facturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_facturaWhereInput
  }


  /**
   * Count Type Materia_primaCountOutputType
   */

  export type Materia_primaCountOutputType = {
    detalle_factura: number
    kardex_materia_prima: number
    recetas: number
  }

  export type Materia_primaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_factura?: boolean | Materia_primaCountOutputTypeCountDetalle_facturaArgs
    kardex_materia_prima?: boolean | Materia_primaCountOutputTypeCountKardex_materia_primaArgs
    recetas?: boolean | Materia_primaCountOutputTypeCountRecetasArgs
  }

  // Custom InputTypes
  /**
   * Materia_primaCountOutputType without action
   */
  export type Materia_primaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia_primaCountOutputType
     */
    select?: Materia_primaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Materia_primaCountOutputType without action
   */
  export type Materia_primaCountOutputTypeCountDetalle_facturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_facturaWhereInput
  }

  /**
   * Materia_primaCountOutputType without action
   */
  export type Materia_primaCountOutputTypeCountKardex_materia_primaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kardex_materia_primaWhereInput
  }

  /**
   * Materia_primaCountOutputType without action
   */
  export type Materia_primaCountOutputTypeCountRecetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recetasWhereInput
  }


  /**
   * Count Type MonedasCountOutputType
   */

  export type MonedasCountOutputType = {
    facturas: number
    productos_terminados: number
  }

  export type MonedasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facturas?: boolean | MonedasCountOutputTypeCountFacturasArgs
    productos_terminados?: boolean | MonedasCountOutputTypeCountProductos_terminadosArgs
  }

  // Custom InputTypes
  /**
   * MonedasCountOutputType without action
   */
  export type MonedasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonedasCountOutputType
     */
    select?: MonedasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MonedasCountOutputType without action
   */
  export type MonedasCountOutputTypeCountFacturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facturasWhereInput
  }

  /**
   * MonedasCountOutputType without action
   */
  export type MonedasCountOutputTypeCountProductos_terminadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productos_terminadosWhereInput
  }


  /**
   * Count Type Productos_terminadosCountOutputType
   */

  export type Productos_terminadosCountOutputType = {
    kardex_productos: number
    recetas: number
  }

  export type Productos_terminadosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kardex_productos?: boolean | Productos_terminadosCountOutputTypeCountKardex_productosArgs
    recetas?: boolean | Productos_terminadosCountOutputTypeCountRecetasArgs
  }

  // Custom InputTypes
  /**
   * Productos_terminadosCountOutputType without action
   */
  export type Productos_terminadosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos_terminadosCountOutputType
     */
    select?: Productos_terminadosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Productos_terminadosCountOutputType without action
   */
  export type Productos_terminadosCountOutputTypeCountKardex_productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kardex_productosWhereInput
  }

  /**
   * Productos_terminadosCountOutputType without action
   */
  export type Productos_terminadosCountOutputTypeCountRecetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recetasWhereInput
  }


  /**
   * Count Type Productos_especialesCountOutputType
   */

  export type Productos_especialesCountOutputType = {
    recetas: number
  }

  export type Productos_especialesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recetas?: boolean | Productos_especialesCountOutputTypeCountRecetasArgs
  }

  // Custom InputTypes
  /**
   * Productos_especialesCountOutputType without action
   */
  export type Productos_especialesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Productos_especialesCountOutputType
     */
    select?: Productos_especialesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Productos_especialesCountOutputType without action
   */
  export type Productos_especialesCountOutputTypeCountRecetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recetasWhereInput
  }


  /**
   * Count Type ProveedoresCountOutputType
   */

  export type ProveedoresCountOutputType = {
    facturas: number
  }

  export type ProveedoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facturas?: boolean | ProveedoresCountOutputTypeCountFacturasArgs
  }

  // Custom InputTypes
  /**
   * ProveedoresCountOutputType without action
   */
  export type ProveedoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProveedoresCountOutputType
     */
    select?: ProveedoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProveedoresCountOutputType without action
   */
  export type ProveedoresCountOutputTypeCountFacturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facturasWhereInput
  }


  /**
   * Count Type UnidadesmedidaCountOutputType
   */

  export type UnidadesmedidaCountOutputType = {
    detalle_factura: number
    recetas: number
    materia_prima: number
    productos_especiales: number
  }

  export type UnidadesmedidaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_factura?: boolean | UnidadesmedidaCountOutputTypeCountDetalle_facturaArgs
    recetas?: boolean | UnidadesmedidaCountOutputTypeCountRecetasArgs
    materia_prima?: boolean | UnidadesmedidaCountOutputTypeCountMateria_primaArgs
    productos_especiales?: boolean | UnidadesmedidaCountOutputTypeCountProductos_especialesArgs
  }

  // Custom InputTypes
  /**
   * UnidadesmedidaCountOutputType without action
   */
  export type UnidadesmedidaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadesmedidaCountOutputType
     */
    select?: UnidadesmedidaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnidadesmedidaCountOutputType without action
   */
  export type UnidadesmedidaCountOutputTypeCountDetalle_facturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_facturaWhereInput
  }

  /**
   * UnidadesmedidaCountOutputType without action
   */
  export type UnidadesmedidaCountOutputTypeCountRecetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recetasWhereInput
  }

  /**
   * UnidadesmedidaCountOutputType without action
   */
  export type UnidadesmedidaCountOutputTypeCountMateria_primaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: materia_primaWhereInput
  }

  /**
   * UnidadesmedidaCountOutputType without action
   */
  export type UnidadesmedidaCountOutputTypeCountProductos_especialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productos_especialesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model detalle_factura
   */

  export type AggregateDetalle_factura = {
    _count: Detalle_facturaCountAggregateOutputType | null
    _avg: Detalle_facturaAvgAggregateOutputType | null
    _sum: Detalle_facturaSumAggregateOutputType | null
    _min: Detalle_facturaMinAggregateOutputType | null
    _max: Detalle_facturaMaxAggregateOutputType | null
  }

  export type Detalle_facturaAvgAggregateOutputType = {
    id_detalle: number | null
    id_factura: number | null
    id_materia_prima: number | null
    cantidad: Decimal | null
    precio_unitario: Decimal | null
    subtotal: Decimal | null
    unidad_medida: number | null
  }

  export type Detalle_facturaSumAggregateOutputType = {
    id_detalle: number | null
    id_factura: number | null
    id_materia_prima: number | null
    cantidad: Decimal | null
    precio_unitario: Decimal | null
    subtotal: Decimal | null
    unidad_medida: number | null
  }

  export type Detalle_facturaMinAggregateOutputType = {
    id_detalle: number | null
    id_factura: number | null
    id_materia_prima: number | null
    cantidad: Decimal | null
    precio_unitario: Decimal | null
    subtotal: Decimal | null
    unidad_medida: number | null
  }

  export type Detalle_facturaMaxAggregateOutputType = {
    id_detalle: number | null
    id_factura: number | null
    id_materia_prima: number | null
    cantidad: Decimal | null
    precio_unitario: Decimal | null
    subtotal: Decimal | null
    unidad_medida: number | null
  }

  export type Detalle_facturaCountAggregateOutputType = {
    id_detalle: number
    id_factura: number
    id_materia_prima: number
    cantidad: number
    precio_unitario: number
    subtotal: number
    unidad_medida: number
    _all: number
  }


  export type Detalle_facturaAvgAggregateInputType = {
    id_detalle?: true
    id_factura?: true
    id_materia_prima?: true
    cantidad?: true
    precio_unitario?: true
    subtotal?: true
    unidad_medida?: true
  }

  export type Detalle_facturaSumAggregateInputType = {
    id_detalle?: true
    id_factura?: true
    id_materia_prima?: true
    cantidad?: true
    precio_unitario?: true
    subtotal?: true
    unidad_medida?: true
  }

  export type Detalle_facturaMinAggregateInputType = {
    id_detalle?: true
    id_factura?: true
    id_materia_prima?: true
    cantidad?: true
    precio_unitario?: true
    subtotal?: true
    unidad_medida?: true
  }

  export type Detalle_facturaMaxAggregateInputType = {
    id_detalle?: true
    id_factura?: true
    id_materia_prima?: true
    cantidad?: true
    precio_unitario?: true
    subtotal?: true
    unidad_medida?: true
  }

  export type Detalle_facturaCountAggregateInputType = {
    id_detalle?: true
    id_factura?: true
    id_materia_prima?: true
    cantidad?: true
    precio_unitario?: true
    subtotal?: true
    unidad_medida?: true
    _all?: true
  }

  export type Detalle_facturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_factura to aggregate.
     */
    where?: detalle_facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_facturas to fetch.
     */
    orderBy?: detalle_facturaOrderByWithRelationInput | detalle_facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detalle_facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detalle_facturas
    **/
    _count?: true | Detalle_facturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detalle_facturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detalle_facturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detalle_facturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detalle_facturaMaxAggregateInputType
  }

  export type GetDetalle_facturaAggregateType<T extends Detalle_facturaAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalle_factura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalle_factura[P]>
      : GetScalarType<T[P], AggregateDetalle_factura[P]>
  }




  export type detalle_facturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_facturaWhereInput
    orderBy?: detalle_facturaOrderByWithAggregationInput | detalle_facturaOrderByWithAggregationInput[]
    by: Detalle_facturaScalarFieldEnum[] | Detalle_facturaScalarFieldEnum
    having?: detalle_facturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detalle_facturaCountAggregateInputType | true
    _avg?: Detalle_facturaAvgAggregateInputType
    _sum?: Detalle_facturaSumAggregateInputType
    _min?: Detalle_facturaMinAggregateInputType
    _max?: Detalle_facturaMaxAggregateInputType
  }

  export type Detalle_facturaGroupByOutputType = {
    id_detalle: number
    id_factura: number | null
    id_materia_prima: number | null
    cantidad: Decimal
    precio_unitario: Decimal
    subtotal: Decimal | null
    unidad_medida: number | null
    _count: Detalle_facturaCountAggregateOutputType | null
    _avg: Detalle_facturaAvgAggregateOutputType | null
    _sum: Detalle_facturaSumAggregateOutputType | null
    _min: Detalle_facturaMinAggregateOutputType | null
    _max: Detalle_facturaMaxAggregateOutputType | null
  }

  type GetDetalle_facturaGroupByPayload<T extends detalle_facturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detalle_facturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detalle_facturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detalle_facturaGroupByOutputType[P]>
            : GetScalarType<T[P], Detalle_facturaGroupByOutputType[P]>
        }
      >
    >


  export type detalle_facturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle?: boolean
    id_factura?: boolean
    id_materia_prima?: boolean
    cantidad?: boolean
    precio_unitario?: boolean
    subtotal?: boolean
    unidad_medida?: boolean
    facturas?: boolean | detalle_factura$facturasArgs<ExtArgs>
    materia_prima?: boolean | detalle_factura$materia_primaArgs<ExtArgs>
    unidadesmedida?: boolean | detalle_factura$unidadesmedidaArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_factura"]>

  export type detalle_facturaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_detalle?: boolean
    id_factura?: boolean
    id_materia_prima?: boolean
    cantidad?: boolean
    precio_unitario?: boolean
    subtotal?: boolean
    unidad_medida?: boolean
    facturas?: boolean | detalle_factura$facturasArgs<ExtArgs>
    materia_prima?: boolean | detalle_factura$materia_primaArgs<ExtArgs>
    unidadesmedida?: boolean | detalle_factura$unidadesmedidaArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_factura"]>

  export type detalle_facturaSelectScalar = {
    id_detalle?: boolean
    id_factura?: boolean
    id_materia_prima?: boolean
    cantidad?: boolean
    precio_unitario?: boolean
    subtotal?: boolean
    unidad_medida?: boolean
  }

  export type detalle_facturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facturas?: boolean | detalle_factura$facturasArgs<ExtArgs>
    materia_prima?: boolean | detalle_factura$materia_primaArgs<ExtArgs>
    unidadesmedida?: boolean | detalle_factura$unidadesmedidaArgs<ExtArgs>
  }
  export type detalle_facturaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facturas?: boolean | detalle_factura$facturasArgs<ExtArgs>
    materia_prima?: boolean | detalle_factura$materia_primaArgs<ExtArgs>
    unidadesmedida?: boolean | detalle_factura$unidadesmedidaArgs<ExtArgs>
  }

  export type $detalle_facturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "detalle_factura"
    objects: {
      facturas: Prisma.$facturasPayload<ExtArgs> | null
      materia_prima: Prisma.$materia_primaPayload<ExtArgs> | null
      unidadesmedida: Prisma.$unidadesmedidaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_detalle: number
      id_factura: number | null
      id_materia_prima: number | null
      cantidad: Prisma.Decimal
      precio_unitario: Prisma.Decimal
      subtotal: Prisma.Decimal | null
      unidad_medida: number | null
    }, ExtArgs["result"]["detalle_factura"]>
    composites: {}
  }

  type detalle_facturaGetPayload<S extends boolean | null | undefined | detalle_facturaDefaultArgs> = $Result.GetResult<Prisma.$detalle_facturaPayload, S>

  type detalle_facturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<detalle_facturaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Detalle_facturaCountAggregateInputType | true
    }

  export interface detalle_facturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detalle_factura'], meta: { name: 'detalle_factura' } }
    /**
     * Find zero or one Detalle_factura that matches the filter.
     * @param {detalle_facturaFindUniqueArgs} args - Arguments to find a Detalle_factura
     * @example
     * // Get one Detalle_factura
     * const detalle_factura = await prisma.detalle_factura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends detalle_facturaFindUniqueArgs>(args: SelectSubset<T, detalle_facturaFindUniqueArgs<ExtArgs>>): Prisma__detalle_facturaClient<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Detalle_factura that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {detalle_facturaFindUniqueOrThrowArgs} args - Arguments to find a Detalle_factura
     * @example
     * // Get one Detalle_factura
     * const detalle_factura = await prisma.detalle_factura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends detalle_facturaFindUniqueOrThrowArgs>(args: SelectSubset<T, detalle_facturaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__detalle_facturaClient<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Detalle_factura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_facturaFindFirstArgs} args - Arguments to find a Detalle_factura
     * @example
     * // Get one Detalle_factura
     * const detalle_factura = await prisma.detalle_factura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends detalle_facturaFindFirstArgs>(args?: SelectSubset<T, detalle_facturaFindFirstArgs<ExtArgs>>): Prisma__detalle_facturaClient<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Detalle_factura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_facturaFindFirstOrThrowArgs} args - Arguments to find a Detalle_factura
     * @example
     * // Get one Detalle_factura
     * const detalle_factura = await prisma.detalle_factura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends detalle_facturaFindFirstOrThrowArgs>(args?: SelectSubset<T, detalle_facturaFindFirstOrThrowArgs<ExtArgs>>): Prisma__detalle_facturaClient<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Detalle_facturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_facturaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detalle_facturas
     * const detalle_facturas = await prisma.detalle_factura.findMany()
     * 
     * // Get first 10 Detalle_facturas
     * const detalle_facturas = await prisma.detalle_factura.findMany({ take: 10 })
     * 
     * // Only select the `id_detalle`
     * const detalle_facturaWithId_detalleOnly = await prisma.detalle_factura.findMany({ select: { id_detalle: true } })
     * 
     */
    findMany<T extends detalle_facturaFindManyArgs>(args?: SelectSubset<T, detalle_facturaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Detalle_factura.
     * @param {detalle_facturaCreateArgs} args - Arguments to create a Detalle_factura.
     * @example
     * // Create one Detalle_factura
     * const Detalle_factura = await prisma.detalle_factura.create({
     *   data: {
     *     // ... data to create a Detalle_factura
     *   }
     * })
     * 
     */
    create<T extends detalle_facturaCreateArgs>(args: SelectSubset<T, detalle_facturaCreateArgs<ExtArgs>>): Prisma__detalle_facturaClient<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Detalle_facturas.
     * @param {detalle_facturaCreateManyArgs} args - Arguments to create many Detalle_facturas.
     * @example
     * // Create many Detalle_facturas
     * const detalle_factura = await prisma.detalle_factura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends detalle_facturaCreateManyArgs>(args?: SelectSubset<T, detalle_facturaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Detalle_facturas and returns the data saved in the database.
     * @param {detalle_facturaCreateManyAndReturnArgs} args - Arguments to create many Detalle_facturas.
     * @example
     * // Create many Detalle_facturas
     * const detalle_factura = await prisma.detalle_factura.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Detalle_facturas and only return the `id_detalle`
     * const detalle_facturaWithId_detalleOnly = await prisma.detalle_factura.createManyAndReturn({ 
     *   select: { id_detalle: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends detalle_facturaCreateManyAndReturnArgs>(args?: SelectSubset<T, detalle_facturaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Detalle_factura.
     * @param {detalle_facturaDeleteArgs} args - Arguments to delete one Detalle_factura.
     * @example
     * // Delete one Detalle_factura
     * const Detalle_factura = await prisma.detalle_factura.delete({
     *   where: {
     *     // ... filter to delete one Detalle_factura
     *   }
     * })
     * 
     */
    delete<T extends detalle_facturaDeleteArgs>(args: SelectSubset<T, detalle_facturaDeleteArgs<ExtArgs>>): Prisma__detalle_facturaClient<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Detalle_factura.
     * @param {detalle_facturaUpdateArgs} args - Arguments to update one Detalle_factura.
     * @example
     * // Update one Detalle_factura
     * const detalle_factura = await prisma.detalle_factura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends detalle_facturaUpdateArgs>(args: SelectSubset<T, detalle_facturaUpdateArgs<ExtArgs>>): Prisma__detalle_facturaClient<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Detalle_facturas.
     * @param {detalle_facturaDeleteManyArgs} args - Arguments to filter Detalle_facturas to delete.
     * @example
     * // Delete a few Detalle_facturas
     * const { count } = await prisma.detalle_factura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends detalle_facturaDeleteManyArgs>(args?: SelectSubset<T, detalle_facturaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detalle_facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_facturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detalle_facturas
     * const detalle_factura = await prisma.detalle_factura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends detalle_facturaUpdateManyArgs>(args: SelectSubset<T, detalle_facturaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detalle_factura.
     * @param {detalle_facturaUpsertArgs} args - Arguments to update or create a Detalle_factura.
     * @example
     * // Update or create a Detalle_factura
     * const detalle_factura = await prisma.detalle_factura.upsert({
     *   create: {
     *     // ... data to create a Detalle_factura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detalle_factura we want to update
     *   }
     * })
     */
    upsert<T extends detalle_facturaUpsertArgs>(args: SelectSubset<T, detalle_facturaUpsertArgs<ExtArgs>>): Prisma__detalle_facturaClient<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Detalle_facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_facturaCountArgs} args - Arguments to filter Detalle_facturas to count.
     * @example
     * // Count the number of Detalle_facturas
     * const count = await prisma.detalle_factura.count({
     *   where: {
     *     // ... the filter for the Detalle_facturas we want to count
     *   }
     * })
    **/
    count<T extends detalle_facturaCountArgs>(
      args?: Subset<T, detalle_facturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detalle_facturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detalle_factura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detalle_facturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detalle_facturaAggregateArgs>(args: Subset<T, Detalle_facturaAggregateArgs>): Prisma.PrismaPromise<GetDetalle_facturaAggregateType<T>>

    /**
     * Group by Detalle_factura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_facturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detalle_facturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detalle_facturaGroupByArgs['orderBy'] }
        : { orderBy?: detalle_facturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detalle_facturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalle_facturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detalle_factura model
   */
  readonly fields: detalle_facturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detalle_factura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detalle_facturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facturas<T extends detalle_factura$facturasArgs<ExtArgs> = {}>(args?: Subset<T, detalle_factura$facturasArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    materia_prima<T extends detalle_factura$materia_primaArgs<ExtArgs> = {}>(args?: Subset<T, detalle_factura$materia_primaArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    unidadesmedida<T extends detalle_factura$unidadesmedidaArgs<ExtArgs> = {}>(args?: Subset<T, detalle_factura$unidadesmedidaArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the detalle_factura model
   */ 
  interface detalle_facturaFieldRefs {
    readonly id_detalle: FieldRef<"detalle_factura", 'Int'>
    readonly id_factura: FieldRef<"detalle_factura", 'Int'>
    readonly id_materia_prima: FieldRef<"detalle_factura", 'Int'>
    readonly cantidad: FieldRef<"detalle_factura", 'Decimal'>
    readonly precio_unitario: FieldRef<"detalle_factura", 'Decimal'>
    readonly subtotal: FieldRef<"detalle_factura", 'Decimal'>
    readonly unidad_medida: FieldRef<"detalle_factura", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * detalle_factura findUnique
   */
  export type detalle_facturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    /**
     * Filter, which detalle_factura to fetch.
     */
    where: detalle_facturaWhereUniqueInput
  }

  /**
   * detalle_factura findUniqueOrThrow
   */
  export type detalle_facturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    /**
     * Filter, which detalle_factura to fetch.
     */
    where: detalle_facturaWhereUniqueInput
  }

  /**
   * detalle_factura findFirst
   */
  export type detalle_facturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    /**
     * Filter, which detalle_factura to fetch.
     */
    where?: detalle_facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_facturas to fetch.
     */
    orderBy?: detalle_facturaOrderByWithRelationInput | detalle_facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_facturas.
     */
    cursor?: detalle_facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_facturas.
     */
    distinct?: Detalle_facturaScalarFieldEnum | Detalle_facturaScalarFieldEnum[]
  }

  /**
   * detalle_factura findFirstOrThrow
   */
  export type detalle_facturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    /**
     * Filter, which detalle_factura to fetch.
     */
    where?: detalle_facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_facturas to fetch.
     */
    orderBy?: detalle_facturaOrderByWithRelationInput | detalle_facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_facturas.
     */
    cursor?: detalle_facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_facturas.
     */
    distinct?: Detalle_facturaScalarFieldEnum | Detalle_facturaScalarFieldEnum[]
  }

  /**
   * detalle_factura findMany
   */
  export type detalle_facturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    /**
     * Filter, which detalle_facturas to fetch.
     */
    where?: detalle_facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_facturas to fetch.
     */
    orderBy?: detalle_facturaOrderByWithRelationInput | detalle_facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detalle_facturas.
     */
    cursor?: detalle_facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_facturas.
     */
    skip?: number
    distinct?: Detalle_facturaScalarFieldEnum | Detalle_facturaScalarFieldEnum[]
  }

  /**
   * detalle_factura create
   */
  export type detalle_facturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    /**
     * The data needed to create a detalle_factura.
     */
    data: XOR<detalle_facturaCreateInput, detalle_facturaUncheckedCreateInput>
  }

  /**
   * detalle_factura createMany
   */
  export type detalle_facturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detalle_facturas.
     */
    data: detalle_facturaCreateManyInput | detalle_facturaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * detalle_factura createManyAndReturn
   */
  export type detalle_facturaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many detalle_facturas.
     */
    data: detalle_facturaCreateManyInput | detalle_facturaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * detalle_factura update
   */
  export type detalle_facturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    /**
     * The data needed to update a detalle_factura.
     */
    data: XOR<detalle_facturaUpdateInput, detalle_facturaUncheckedUpdateInput>
    /**
     * Choose, which detalle_factura to update.
     */
    where: detalle_facturaWhereUniqueInput
  }

  /**
   * detalle_factura updateMany
   */
  export type detalle_facturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detalle_facturas.
     */
    data: XOR<detalle_facturaUpdateManyMutationInput, detalle_facturaUncheckedUpdateManyInput>
    /**
     * Filter which detalle_facturas to update
     */
    where?: detalle_facturaWhereInput
  }

  /**
   * detalle_factura upsert
   */
  export type detalle_facturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    /**
     * The filter to search for the detalle_factura to update in case it exists.
     */
    where: detalle_facturaWhereUniqueInput
    /**
     * In case the detalle_factura found by the `where` argument doesn't exist, create a new detalle_factura with this data.
     */
    create: XOR<detalle_facturaCreateInput, detalle_facturaUncheckedCreateInput>
    /**
     * In case the detalle_factura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detalle_facturaUpdateInput, detalle_facturaUncheckedUpdateInput>
  }

  /**
   * detalle_factura delete
   */
  export type detalle_facturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    /**
     * Filter which detalle_factura to delete.
     */
    where: detalle_facturaWhereUniqueInput
  }

  /**
   * detalle_factura deleteMany
   */
  export type detalle_facturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_facturas to delete
     */
    where?: detalle_facturaWhereInput
  }

  /**
   * detalle_factura.facturas
   */
  export type detalle_factura$facturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    where?: facturasWhereInput
  }

  /**
   * detalle_factura.materia_prima
   */
  export type detalle_factura$materia_primaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    where?: materia_primaWhereInput
  }

  /**
   * detalle_factura.unidadesmedida
   */
  export type detalle_factura$unidadesmedidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    where?: unidadesmedidaWhereInput
  }

  /**
   * detalle_factura without action
   */
  export type detalle_facturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
  }


  /**
   * Model facturas
   */

  export type AggregateFacturas = {
    _count: FacturasCountAggregateOutputType | null
    _avg: FacturasAvgAggregateOutputType | null
    _sum: FacturasSumAggregateOutputType | null
    _min: FacturasMinAggregateOutputType | null
    _max: FacturasMaxAggregateOutputType | null
  }

  export type FacturasAvgAggregateOutputType = {
    id_factura: number | null
    id_proveedor: number | null
    id_moneda: number | null
    total: Decimal | null
  }

  export type FacturasSumAggregateOutputType = {
    id_factura: number | null
    id_proveedor: number | null
    id_moneda: number | null
    total: Decimal | null
  }

  export type FacturasMinAggregateOutputType = {
    id_factura: number | null
    id_proveedor: number | null
    id_moneda: number | null
    fecha_factura: Date | null
    total: Decimal | null
    estado: boolean | null
    observaciones: string | null
  }

  export type FacturasMaxAggregateOutputType = {
    id_factura: number | null
    id_proveedor: number | null
    id_moneda: number | null
    fecha_factura: Date | null
    total: Decimal | null
    estado: boolean | null
    observaciones: string | null
  }

  export type FacturasCountAggregateOutputType = {
    id_factura: number
    id_proveedor: number
    id_moneda: number
    fecha_factura: number
    total: number
    estado: number
    observaciones: number
    _all: number
  }


  export type FacturasAvgAggregateInputType = {
    id_factura?: true
    id_proveedor?: true
    id_moneda?: true
    total?: true
  }

  export type FacturasSumAggregateInputType = {
    id_factura?: true
    id_proveedor?: true
    id_moneda?: true
    total?: true
  }

  export type FacturasMinAggregateInputType = {
    id_factura?: true
    id_proveedor?: true
    id_moneda?: true
    fecha_factura?: true
    total?: true
    estado?: true
    observaciones?: true
  }

  export type FacturasMaxAggregateInputType = {
    id_factura?: true
    id_proveedor?: true
    id_moneda?: true
    fecha_factura?: true
    total?: true
    estado?: true
    observaciones?: true
  }

  export type FacturasCountAggregateInputType = {
    id_factura?: true
    id_proveedor?: true
    id_moneda?: true
    fecha_factura?: true
    total?: true
    estado?: true
    observaciones?: true
    _all?: true
  }

  export type FacturasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which facturas to aggregate.
     */
    where?: facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned facturas
    **/
    _count?: true | FacturasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacturasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacturasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacturasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacturasMaxAggregateInputType
  }

  export type GetFacturasAggregateType<T extends FacturasAggregateArgs> = {
        [P in keyof T & keyof AggregateFacturas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacturas[P]>
      : GetScalarType<T[P], AggregateFacturas[P]>
  }




  export type facturasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facturasWhereInput
    orderBy?: facturasOrderByWithAggregationInput | facturasOrderByWithAggregationInput[]
    by: FacturasScalarFieldEnum[] | FacturasScalarFieldEnum
    having?: facturasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacturasCountAggregateInputType | true
    _avg?: FacturasAvgAggregateInputType
    _sum?: FacturasSumAggregateInputType
    _min?: FacturasMinAggregateInputType
    _max?: FacturasMaxAggregateInputType
  }

  export type FacturasGroupByOutputType = {
    id_factura: number
    id_proveedor: number | null
    id_moneda: number
    fecha_factura: Date | null
    total: Decimal
    estado: boolean | null
    observaciones: string | null
    _count: FacturasCountAggregateOutputType | null
    _avg: FacturasAvgAggregateOutputType | null
    _sum: FacturasSumAggregateOutputType | null
    _min: FacturasMinAggregateOutputType | null
    _max: FacturasMaxAggregateOutputType | null
  }

  type GetFacturasGroupByPayload<T extends facturasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacturasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacturasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacturasGroupByOutputType[P]>
            : GetScalarType<T[P], FacturasGroupByOutputType[P]>
        }
      >
    >


  export type facturasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_factura?: boolean
    id_proveedor?: boolean
    id_moneda?: boolean
    fecha_factura?: boolean
    total?: boolean
    estado?: boolean
    observaciones?: boolean
    detalle_factura?: boolean | facturas$detalle_facturaArgs<ExtArgs>
    monedas?: boolean | monedasDefaultArgs<ExtArgs>
    proveedores?: boolean | facturas$proveedoresArgs<ExtArgs>
    _count?: boolean | FacturasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facturas"]>

  export type facturasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_factura?: boolean
    id_proveedor?: boolean
    id_moneda?: boolean
    fecha_factura?: boolean
    total?: boolean
    estado?: boolean
    observaciones?: boolean
    monedas?: boolean | monedasDefaultArgs<ExtArgs>
    proveedores?: boolean | facturas$proveedoresArgs<ExtArgs>
  }, ExtArgs["result"]["facturas"]>

  export type facturasSelectScalar = {
    id_factura?: boolean
    id_proveedor?: boolean
    id_moneda?: boolean
    fecha_factura?: boolean
    total?: boolean
    estado?: boolean
    observaciones?: boolean
  }

  export type facturasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_factura?: boolean | facturas$detalle_facturaArgs<ExtArgs>
    monedas?: boolean | monedasDefaultArgs<ExtArgs>
    proveedores?: boolean | facturas$proveedoresArgs<ExtArgs>
    _count?: boolean | FacturasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type facturasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monedas?: boolean | monedasDefaultArgs<ExtArgs>
    proveedores?: boolean | facturas$proveedoresArgs<ExtArgs>
  }

  export type $facturasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "facturas"
    objects: {
      detalle_factura: Prisma.$detalle_facturaPayload<ExtArgs>[]
      monedas: Prisma.$monedasPayload<ExtArgs>
      proveedores: Prisma.$proveedoresPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_factura: number
      id_proveedor: number | null
      id_moneda: number
      fecha_factura: Date | null
      total: Prisma.Decimal
      estado: boolean | null
      observaciones: string | null
    }, ExtArgs["result"]["facturas"]>
    composites: {}
  }

  type facturasGetPayload<S extends boolean | null | undefined | facturasDefaultArgs> = $Result.GetResult<Prisma.$facturasPayload, S>

  type facturasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<facturasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacturasCountAggregateInputType | true
    }

  export interface facturasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['facturas'], meta: { name: 'facturas' } }
    /**
     * Find zero or one Facturas that matches the filter.
     * @param {facturasFindUniqueArgs} args - Arguments to find a Facturas
     * @example
     * // Get one Facturas
     * const facturas = await prisma.facturas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends facturasFindUniqueArgs>(args: SelectSubset<T, facturasFindUniqueArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Facturas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {facturasFindUniqueOrThrowArgs} args - Arguments to find a Facturas
     * @example
     * // Get one Facturas
     * const facturas = await prisma.facturas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends facturasFindUniqueOrThrowArgs>(args: SelectSubset<T, facturasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Facturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasFindFirstArgs} args - Arguments to find a Facturas
     * @example
     * // Get one Facturas
     * const facturas = await prisma.facturas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends facturasFindFirstArgs>(args?: SelectSubset<T, facturasFindFirstArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Facturas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasFindFirstOrThrowArgs} args - Arguments to find a Facturas
     * @example
     * // Get one Facturas
     * const facturas = await prisma.facturas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends facturasFindFirstOrThrowArgs>(args?: SelectSubset<T, facturasFindFirstOrThrowArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Facturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facturas
     * const facturas = await prisma.facturas.findMany()
     * 
     * // Get first 10 Facturas
     * const facturas = await prisma.facturas.findMany({ take: 10 })
     * 
     * // Only select the `id_factura`
     * const facturasWithId_facturaOnly = await prisma.facturas.findMany({ select: { id_factura: true } })
     * 
     */
    findMany<T extends facturasFindManyArgs>(args?: SelectSubset<T, facturasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Facturas.
     * @param {facturasCreateArgs} args - Arguments to create a Facturas.
     * @example
     * // Create one Facturas
     * const Facturas = await prisma.facturas.create({
     *   data: {
     *     // ... data to create a Facturas
     *   }
     * })
     * 
     */
    create<T extends facturasCreateArgs>(args: SelectSubset<T, facturasCreateArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Facturas.
     * @param {facturasCreateManyArgs} args - Arguments to create many Facturas.
     * @example
     * // Create many Facturas
     * const facturas = await prisma.facturas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends facturasCreateManyArgs>(args?: SelectSubset<T, facturasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facturas and returns the data saved in the database.
     * @param {facturasCreateManyAndReturnArgs} args - Arguments to create many Facturas.
     * @example
     * // Create many Facturas
     * const facturas = await prisma.facturas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facturas and only return the `id_factura`
     * const facturasWithId_facturaOnly = await prisma.facturas.createManyAndReturn({ 
     *   select: { id_factura: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends facturasCreateManyAndReturnArgs>(args?: SelectSubset<T, facturasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Facturas.
     * @param {facturasDeleteArgs} args - Arguments to delete one Facturas.
     * @example
     * // Delete one Facturas
     * const Facturas = await prisma.facturas.delete({
     *   where: {
     *     // ... filter to delete one Facturas
     *   }
     * })
     * 
     */
    delete<T extends facturasDeleteArgs>(args: SelectSubset<T, facturasDeleteArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Facturas.
     * @param {facturasUpdateArgs} args - Arguments to update one Facturas.
     * @example
     * // Update one Facturas
     * const facturas = await prisma.facturas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends facturasUpdateArgs>(args: SelectSubset<T, facturasUpdateArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Facturas.
     * @param {facturasDeleteManyArgs} args - Arguments to filter Facturas to delete.
     * @example
     * // Delete a few Facturas
     * const { count } = await prisma.facturas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends facturasDeleteManyArgs>(args?: SelectSubset<T, facturasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facturas
     * const facturas = await prisma.facturas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends facturasUpdateManyArgs>(args: SelectSubset<T, facturasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Facturas.
     * @param {facturasUpsertArgs} args - Arguments to update or create a Facturas.
     * @example
     * // Update or create a Facturas
     * const facturas = await prisma.facturas.upsert({
     *   create: {
     *     // ... data to create a Facturas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facturas we want to update
     *   }
     * })
     */
    upsert<T extends facturasUpsertArgs>(args: SelectSubset<T, facturasUpsertArgs<ExtArgs>>): Prisma__facturasClient<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasCountArgs} args - Arguments to filter Facturas to count.
     * @example
     * // Count the number of Facturas
     * const count = await prisma.facturas.count({
     *   where: {
     *     // ... the filter for the Facturas we want to count
     *   }
     * })
    **/
    count<T extends facturasCountArgs>(
      args?: Subset<T, facturasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacturasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacturasAggregateArgs>(args: Subset<T, FacturasAggregateArgs>): Prisma.PrismaPromise<GetFacturasAggregateType<T>>

    /**
     * Group by Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends facturasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: facturasGroupByArgs['orderBy'] }
        : { orderBy?: facturasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, facturasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacturasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the facturas model
   */
  readonly fields: facturasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for facturas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__facturasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detalle_factura<T extends facturas$detalle_facturaArgs<ExtArgs> = {}>(args?: Subset<T, facturas$detalle_facturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "findMany"> | Null>
    monedas<T extends monedasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, monedasDefaultArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    proveedores<T extends facturas$proveedoresArgs<ExtArgs> = {}>(args?: Subset<T, facturas$proveedoresArgs<ExtArgs>>): Prisma__proveedoresClient<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the facturas model
   */ 
  interface facturasFieldRefs {
    readonly id_factura: FieldRef<"facturas", 'Int'>
    readonly id_proveedor: FieldRef<"facturas", 'Int'>
    readonly id_moneda: FieldRef<"facturas", 'Int'>
    readonly fecha_factura: FieldRef<"facturas", 'DateTime'>
    readonly total: FieldRef<"facturas", 'Decimal'>
    readonly estado: FieldRef<"facturas", 'Boolean'>
    readonly observaciones: FieldRef<"facturas", 'String'>
  }
    

  // Custom InputTypes
  /**
   * facturas findUnique
   */
  export type facturasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where: facturasWhereUniqueInput
  }

  /**
   * facturas findUniqueOrThrow
   */
  export type facturasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where: facturasWhereUniqueInput
  }

  /**
   * facturas findFirst
   */
  export type facturasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where?: facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for facturas.
     */
    cursor?: facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of facturas.
     */
    distinct?: FacturasScalarFieldEnum | FacturasScalarFieldEnum[]
  }

  /**
   * facturas findFirstOrThrow
   */
  export type facturasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where?: facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for facturas.
     */
    cursor?: facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of facturas.
     */
    distinct?: FacturasScalarFieldEnum | FacturasScalarFieldEnum[]
  }

  /**
   * facturas findMany
   */
  export type facturasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where?: facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing facturas.
     */
    cursor?: facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    distinct?: FacturasScalarFieldEnum | FacturasScalarFieldEnum[]
  }

  /**
   * facturas create
   */
  export type facturasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * The data needed to create a facturas.
     */
    data: XOR<facturasCreateInput, facturasUncheckedCreateInput>
  }

  /**
   * facturas createMany
   */
  export type facturasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many facturas.
     */
    data: facturasCreateManyInput | facturasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * facturas createManyAndReturn
   */
  export type facturasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many facturas.
     */
    data: facturasCreateManyInput | facturasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * facturas update
   */
  export type facturasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * The data needed to update a facturas.
     */
    data: XOR<facturasUpdateInput, facturasUncheckedUpdateInput>
    /**
     * Choose, which facturas to update.
     */
    where: facturasWhereUniqueInput
  }

  /**
   * facturas updateMany
   */
  export type facturasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update facturas.
     */
    data: XOR<facturasUpdateManyMutationInput, facturasUncheckedUpdateManyInput>
    /**
     * Filter which facturas to update
     */
    where?: facturasWhereInput
  }

  /**
   * facturas upsert
   */
  export type facturasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * The filter to search for the facturas to update in case it exists.
     */
    where: facturasWhereUniqueInput
    /**
     * In case the facturas found by the `where` argument doesn't exist, create a new facturas with this data.
     */
    create: XOR<facturasCreateInput, facturasUncheckedCreateInput>
    /**
     * In case the facturas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<facturasUpdateInput, facturasUncheckedUpdateInput>
  }

  /**
   * facturas delete
   */
  export type facturasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    /**
     * Filter which facturas to delete.
     */
    where: facturasWhereUniqueInput
  }

  /**
   * facturas deleteMany
   */
  export type facturasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which facturas to delete
     */
    where?: facturasWhereInput
  }

  /**
   * facturas.detalle_factura
   */
  export type facturas$detalle_facturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    where?: detalle_facturaWhereInput
    orderBy?: detalle_facturaOrderByWithRelationInput | detalle_facturaOrderByWithRelationInput[]
    cursor?: detalle_facturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detalle_facturaScalarFieldEnum | Detalle_facturaScalarFieldEnum[]
  }

  /**
   * facturas.proveedores
   */
  export type facturas$proveedoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
    where?: proveedoresWhereInput
  }

  /**
   * facturas without action
   */
  export type facturasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
  }


  /**
   * Model ConversionFactor
   */

  export type AggregateConversionFactor = {
    _count: ConversionFactorCountAggregateOutputType | null
    _avg: ConversionFactorAvgAggregateOutputType | null
    _sum: ConversionFactorSumAggregateOutputType | null
    _min: ConversionFactorMinAggregateOutputType | null
    _max: ConversionFactorMaxAggregateOutputType | null
  }

  export type ConversionFactorAvgAggregateOutputType = {
    id: number | null
    factorConversion: number | null
  }

  export type ConversionFactorSumAggregateOutputType = {
    id: number | null
    factorConversion: number | null
  }

  export type ConversionFactorMinAggregateOutputType = {
    id: number | null
    unidadOrigen: string | null
    unidadDestino: string | null
    factorConversion: number | null
  }

  export type ConversionFactorMaxAggregateOutputType = {
    id: number | null
    unidadOrigen: string | null
    unidadDestino: string | null
    factorConversion: number | null
  }

  export type ConversionFactorCountAggregateOutputType = {
    id: number
    unidadOrigen: number
    unidadDestino: number
    factorConversion: number
    _all: number
  }


  export type ConversionFactorAvgAggregateInputType = {
    id?: true
    factorConversion?: true
  }

  export type ConversionFactorSumAggregateInputType = {
    id?: true
    factorConversion?: true
  }

  export type ConversionFactorMinAggregateInputType = {
    id?: true
    unidadOrigen?: true
    unidadDestino?: true
    factorConversion?: true
  }

  export type ConversionFactorMaxAggregateInputType = {
    id?: true
    unidadOrigen?: true
    unidadDestino?: true
    factorConversion?: true
  }

  export type ConversionFactorCountAggregateInputType = {
    id?: true
    unidadOrigen?: true
    unidadDestino?: true
    factorConversion?: true
    _all?: true
  }

  export type ConversionFactorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversionFactor to aggregate.
     */
    where?: ConversionFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversionFactors to fetch.
     */
    orderBy?: ConversionFactorOrderByWithRelationInput | ConversionFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversionFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversionFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversionFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversionFactors
    **/
    _count?: true | ConversionFactorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversionFactorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversionFactorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversionFactorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversionFactorMaxAggregateInputType
  }

  export type GetConversionFactorAggregateType<T extends ConversionFactorAggregateArgs> = {
        [P in keyof T & keyof AggregateConversionFactor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversionFactor[P]>
      : GetScalarType<T[P], AggregateConversionFactor[P]>
  }




  export type ConversionFactorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversionFactorWhereInput
    orderBy?: ConversionFactorOrderByWithAggregationInput | ConversionFactorOrderByWithAggregationInput[]
    by: ConversionFactorScalarFieldEnum[] | ConversionFactorScalarFieldEnum
    having?: ConversionFactorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversionFactorCountAggregateInputType | true
    _avg?: ConversionFactorAvgAggregateInputType
    _sum?: ConversionFactorSumAggregateInputType
    _min?: ConversionFactorMinAggregateInputType
    _max?: ConversionFactorMaxAggregateInputType
  }

  export type ConversionFactorGroupByOutputType = {
    id: number
    unidadOrigen: string
    unidadDestino: string
    factorConversion: number
    _count: ConversionFactorCountAggregateOutputType | null
    _avg: ConversionFactorAvgAggregateOutputType | null
    _sum: ConversionFactorSumAggregateOutputType | null
    _min: ConversionFactorMinAggregateOutputType | null
    _max: ConversionFactorMaxAggregateOutputType | null
  }

  type GetConversionFactorGroupByPayload<T extends ConversionFactorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversionFactorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversionFactorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversionFactorGroupByOutputType[P]>
            : GetScalarType<T[P], ConversionFactorGroupByOutputType[P]>
        }
      >
    >


  export type ConversionFactorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unidadOrigen?: boolean
    unidadDestino?: boolean
    factorConversion?: boolean
  }, ExtArgs["result"]["conversionFactor"]>

  export type ConversionFactorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unidadOrigen?: boolean
    unidadDestino?: boolean
    factorConversion?: boolean
  }, ExtArgs["result"]["conversionFactor"]>

  export type ConversionFactorSelectScalar = {
    id?: boolean
    unidadOrigen?: boolean
    unidadDestino?: boolean
    factorConversion?: boolean
  }


  export type $ConversionFactorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversionFactor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unidadOrigen: string
      unidadDestino: string
      factorConversion: number
    }, ExtArgs["result"]["conversionFactor"]>
    composites: {}
  }

  type ConversionFactorGetPayload<S extends boolean | null | undefined | ConversionFactorDefaultArgs> = $Result.GetResult<Prisma.$ConversionFactorPayload, S>

  type ConversionFactorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversionFactorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversionFactorCountAggregateInputType | true
    }

  export interface ConversionFactorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversionFactor'], meta: { name: 'ConversionFactor' } }
    /**
     * Find zero or one ConversionFactor that matches the filter.
     * @param {ConversionFactorFindUniqueArgs} args - Arguments to find a ConversionFactor
     * @example
     * // Get one ConversionFactor
     * const conversionFactor = await prisma.conversionFactor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversionFactorFindUniqueArgs>(args: SelectSubset<T, ConversionFactorFindUniqueArgs<ExtArgs>>): Prisma__ConversionFactorClient<$Result.GetResult<Prisma.$ConversionFactorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConversionFactor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversionFactorFindUniqueOrThrowArgs} args - Arguments to find a ConversionFactor
     * @example
     * // Get one ConversionFactor
     * const conversionFactor = await prisma.conversionFactor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversionFactorFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversionFactorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversionFactorClient<$Result.GetResult<Prisma.$ConversionFactorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConversionFactor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFactorFindFirstArgs} args - Arguments to find a ConversionFactor
     * @example
     * // Get one ConversionFactor
     * const conversionFactor = await prisma.conversionFactor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversionFactorFindFirstArgs>(args?: SelectSubset<T, ConversionFactorFindFirstArgs<ExtArgs>>): Prisma__ConversionFactorClient<$Result.GetResult<Prisma.$ConversionFactorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConversionFactor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFactorFindFirstOrThrowArgs} args - Arguments to find a ConversionFactor
     * @example
     * // Get one ConversionFactor
     * const conversionFactor = await prisma.conversionFactor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversionFactorFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversionFactorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversionFactorClient<$Result.GetResult<Prisma.$ConversionFactorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConversionFactors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFactorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversionFactors
     * const conversionFactors = await prisma.conversionFactor.findMany()
     * 
     * // Get first 10 ConversionFactors
     * const conversionFactors = await prisma.conversionFactor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversionFactorWithIdOnly = await prisma.conversionFactor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversionFactorFindManyArgs>(args?: SelectSubset<T, ConversionFactorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionFactorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConversionFactor.
     * @param {ConversionFactorCreateArgs} args - Arguments to create a ConversionFactor.
     * @example
     * // Create one ConversionFactor
     * const ConversionFactor = await prisma.conversionFactor.create({
     *   data: {
     *     // ... data to create a ConversionFactor
     *   }
     * })
     * 
     */
    create<T extends ConversionFactorCreateArgs>(args: SelectSubset<T, ConversionFactorCreateArgs<ExtArgs>>): Prisma__ConversionFactorClient<$Result.GetResult<Prisma.$ConversionFactorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConversionFactors.
     * @param {ConversionFactorCreateManyArgs} args - Arguments to create many ConversionFactors.
     * @example
     * // Create many ConversionFactors
     * const conversionFactor = await prisma.conversionFactor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversionFactorCreateManyArgs>(args?: SelectSubset<T, ConversionFactorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversionFactors and returns the data saved in the database.
     * @param {ConversionFactorCreateManyAndReturnArgs} args - Arguments to create many ConversionFactors.
     * @example
     * // Create many ConversionFactors
     * const conversionFactor = await prisma.conversionFactor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversionFactors and only return the `id`
     * const conversionFactorWithIdOnly = await prisma.conversionFactor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversionFactorCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversionFactorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionFactorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConversionFactor.
     * @param {ConversionFactorDeleteArgs} args - Arguments to delete one ConversionFactor.
     * @example
     * // Delete one ConversionFactor
     * const ConversionFactor = await prisma.conversionFactor.delete({
     *   where: {
     *     // ... filter to delete one ConversionFactor
     *   }
     * })
     * 
     */
    delete<T extends ConversionFactorDeleteArgs>(args: SelectSubset<T, ConversionFactorDeleteArgs<ExtArgs>>): Prisma__ConversionFactorClient<$Result.GetResult<Prisma.$ConversionFactorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConversionFactor.
     * @param {ConversionFactorUpdateArgs} args - Arguments to update one ConversionFactor.
     * @example
     * // Update one ConversionFactor
     * const conversionFactor = await prisma.conversionFactor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversionFactorUpdateArgs>(args: SelectSubset<T, ConversionFactorUpdateArgs<ExtArgs>>): Prisma__ConversionFactorClient<$Result.GetResult<Prisma.$ConversionFactorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConversionFactors.
     * @param {ConversionFactorDeleteManyArgs} args - Arguments to filter ConversionFactors to delete.
     * @example
     * // Delete a few ConversionFactors
     * const { count } = await prisma.conversionFactor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversionFactorDeleteManyArgs>(args?: SelectSubset<T, ConversionFactorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversionFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFactorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversionFactors
     * const conversionFactor = await prisma.conversionFactor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversionFactorUpdateManyArgs>(args: SelectSubset<T, ConversionFactorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversionFactor.
     * @param {ConversionFactorUpsertArgs} args - Arguments to update or create a ConversionFactor.
     * @example
     * // Update or create a ConversionFactor
     * const conversionFactor = await prisma.conversionFactor.upsert({
     *   create: {
     *     // ... data to create a ConversionFactor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversionFactor we want to update
     *   }
     * })
     */
    upsert<T extends ConversionFactorUpsertArgs>(args: SelectSubset<T, ConversionFactorUpsertArgs<ExtArgs>>): Prisma__ConversionFactorClient<$Result.GetResult<Prisma.$ConversionFactorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConversionFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFactorCountArgs} args - Arguments to filter ConversionFactors to count.
     * @example
     * // Count the number of ConversionFactors
     * const count = await prisma.conversionFactor.count({
     *   where: {
     *     // ... the filter for the ConversionFactors we want to count
     *   }
     * })
    **/
    count<T extends ConversionFactorCountArgs>(
      args?: Subset<T, ConversionFactorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversionFactorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversionFactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFactorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversionFactorAggregateArgs>(args: Subset<T, ConversionFactorAggregateArgs>): Prisma.PrismaPromise<GetConversionFactorAggregateType<T>>

    /**
     * Group by ConversionFactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFactorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversionFactorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversionFactorGroupByArgs['orderBy'] }
        : { orderBy?: ConversionFactorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversionFactorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversionFactorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversionFactor model
   */
  readonly fields: ConversionFactorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversionFactor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversionFactorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversionFactor model
   */ 
  interface ConversionFactorFieldRefs {
    readonly id: FieldRef<"ConversionFactor", 'Int'>
    readonly unidadOrigen: FieldRef<"ConversionFactor", 'String'>
    readonly unidadDestino: FieldRef<"ConversionFactor", 'String'>
    readonly factorConversion: FieldRef<"ConversionFactor", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ConversionFactor findUnique
   */
  export type ConversionFactorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelect<ExtArgs> | null
    /**
     * Filter, which ConversionFactor to fetch.
     */
    where: ConversionFactorWhereUniqueInput
  }

  /**
   * ConversionFactor findUniqueOrThrow
   */
  export type ConversionFactorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelect<ExtArgs> | null
    /**
     * Filter, which ConversionFactor to fetch.
     */
    where: ConversionFactorWhereUniqueInput
  }

  /**
   * ConversionFactor findFirst
   */
  export type ConversionFactorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelect<ExtArgs> | null
    /**
     * Filter, which ConversionFactor to fetch.
     */
    where?: ConversionFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversionFactors to fetch.
     */
    orderBy?: ConversionFactorOrderByWithRelationInput | ConversionFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversionFactors.
     */
    cursor?: ConversionFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversionFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversionFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversionFactors.
     */
    distinct?: ConversionFactorScalarFieldEnum | ConversionFactorScalarFieldEnum[]
  }

  /**
   * ConversionFactor findFirstOrThrow
   */
  export type ConversionFactorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelect<ExtArgs> | null
    /**
     * Filter, which ConversionFactor to fetch.
     */
    where?: ConversionFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversionFactors to fetch.
     */
    orderBy?: ConversionFactorOrderByWithRelationInput | ConversionFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversionFactors.
     */
    cursor?: ConversionFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversionFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversionFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversionFactors.
     */
    distinct?: ConversionFactorScalarFieldEnum | ConversionFactorScalarFieldEnum[]
  }

  /**
   * ConversionFactor findMany
   */
  export type ConversionFactorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelect<ExtArgs> | null
    /**
     * Filter, which ConversionFactors to fetch.
     */
    where?: ConversionFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversionFactors to fetch.
     */
    orderBy?: ConversionFactorOrderByWithRelationInput | ConversionFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversionFactors.
     */
    cursor?: ConversionFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversionFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversionFactors.
     */
    skip?: number
    distinct?: ConversionFactorScalarFieldEnum | ConversionFactorScalarFieldEnum[]
  }

  /**
   * ConversionFactor create
   */
  export type ConversionFactorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelect<ExtArgs> | null
    /**
     * The data needed to create a ConversionFactor.
     */
    data: XOR<ConversionFactorCreateInput, ConversionFactorUncheckedCreateInput>
  }

  /**
   * ConversionFactor createMany
   */
  export type ConversionFactorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversionFactors.
     */
    data: ConversionFactorCreateManyInput | ConversionFactorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversionFactor createManyAndReturn
   */
  export type ConversionFactorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConversionFactors.
     */
    data: ConversionFactorCreateManyInput | ConversionFactorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversionFactor update
   */
  export type ConversionFactorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelect<ExtArgs> | null
    /**
     * The data needed to update a ConversionFactor.
     */
    data: XOR<ConversionFactorUpdateInput, ConversionFactorUncheckedUpdateInput>
    /**
     * Choose, which ConversionFactor to update.
     */
    where: ConversionFactorWhereUniqueInput
  }

  /**
   * ConversionFactor updateMany
   */
  export type ConversionFactorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversionFactors.
     */
    data: XOR<ConversionFactorUpdateManyMutationInput, ConversionFactorUncheckedUpdateManyInput>
    /**
     * Filter which ConversionFactors to update
     */
    where?: ConversionFactorWhereInput
  }

  /**
   * ConversionFactor upsert
   */
  export type ConversionFactorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelect<ExtArgs> | null
    /**
     * The filter to search for the ConversionFactor to update in case it exists.
     */
    where: ConversionFactorWhereUniqueInput
    /**
     * In case the ConversionFactor found by the `where` argument doesn't exist, create a new ConversionFactor with this data.
     */
    create: XOR<ConversionFactorCreateInput, ConversionFactorUncheckedCreateInput>
    /**
     * In case the ConversionFactor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversionFactorUpdateInput, ConversionFactorUncheckedUpdateInput>
  }

  /**
   * ConversionFactor delete
   */
  export type ConversionFactorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelect<ExtArgs> | null
    /**
     * Filter which ConversionFactor to delete.
     */
    where: ConversionFactorWhereUniqueInput
  }

  /**
   * ConversionFactor deleteMany
   */
  export type ConversionFactorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversionFactors to delete
     */
    where?: ConversionFactorWhereInput
  }

  /**
   * ConversionFactor without action
   */
  export type ConversionFactorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionFactor
     */
    select?: ConversionFactorSelect<ExtArgs> | null
  }


  /**
   * Model kardex_materia_prima
   */

  export type AggregateKardex_materia_prima = {
    _count: Kardex_materia_primaCountAggregateOutputType | null
    _avg: Kardex_materia_primaAvgAggregateOutputType | null
    _sum: Kardex_materia_primaSumAggregateOutputType | null
    _min: Kardex_materia_primaMinAggregateOutputType | null
    _max: Kardex_materia_primaMaxAggregateOutputType | null
  }

  export type Kardex_materia_primaAvgAggregateOutputType = {
    id_kardex: number | null
    id_materia_prima: number | null
    cantidad: Decimal | null
    saldo: Decimal | null
    costo_unitario: Decimal | null
    costo_total: Decimal | null
  }

  export type Kardex_materia_primaSumAggregateOutputType = {
    id_kardex: number | null
    id_materia_prima: number | null
    cantidad: Decimal | null
    saldo: Decimal | null
    costo_unitario: Decimal | null
    costo_total: Decimal | null
  }

  export type Kardex_materia_primaMinAggregateOutputType = {
    id_kardex: number | null
    id_materia_prima: number | null
    tipo_movimiento: string | null
    cantidad: Decimal | null
    saldo: Decimal | null
    costo_unitario: Decimal | null
    costo_total: Decimal | null
    fecha_movimiento: Date | null
    referencia: string | null
    observaciones: string | null
  }

  export type Kardex_materia_primaMaxAggregateOutputType = {
    id_kardex: number | null
    id_materia_prima: number | null
    tipo_movimiento: string | null
    cantidad: Decimal | null
    saldo: Decimal | null
    costo_unitario: Decimal | null
    costo_total: Decimal | null
    fecha_movimiento: Date | null
    referencia: string | null
    observaciones: string | null
  }

  export type Kardex_materia_primaCountAggregateOutputType = {
    id_kardex: number
    id_materia_prima: number
    tipo_movimiento: number
    cantidad: number
    saldo: number
    costo_unitario: number
    costo_total: number
    fecha_movimiento: number
    referencia: number
    observaciones: number
    _all: number
  }


  export type Kardex_materia_primaAvgAggregateInputType = {
    id_kardex?: true
    id_materia_prima?: true
    cantidad?: true
    saldo?: true
    costo_unitario?: true
    costo_total?: true
  }

  export type Kardex_materia_primaSumAggregateInputType = {
    id_kardex?: true
    id_materia_prima?: true
    cantidad?: true
    saldo?: true
    costo_unitario?: true
    costo_total?: true
  }

  export type Kardex_materia_primaMinAggregateInputType = {
    id_kardex?: true
    id_materia_prima?: true
    tipo_movimiento?: true
    cantidad?: true
    saldo?: true
    costo_unitario?: true
    costo_total?: true
    fecha_movimiento?: true
    referencia?: true
    observaciones?: true
  }

  export type Kardex_materia_primaMaxAggregateInputType = {
    id_kardex?: true
    id_materia_prima?: true
    tipo_movimiento?: true
    cantidad?: true
    saldo?: true
    costo_unitario?: true
    costo_total?: true
    fecha_movimiento?: true
    referencia?: true
    observaciones?: true
  }

  export type Kardex_materia_primaCountAggregateInputType = {
    id_kardex?: true
    id_materia_prima?: true
    tipo_movimiento?: true
    cantidad?: true
    saldo?: true
    costo_unitario?: true
    costo_total?: true
    fecha_movimiento?: true
    referencia?: true
    observaciones?: true
    _all?: true
  }

  export type Kardex_materia_primaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kardex_materia_prima to aggregate.
     */
    where?: kardex_materia_primaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kardex_materia_primas to fetch.
     */
    orderBy?: kardex_materia_primaOrderByWithRelationInput | kardex_materia_primaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kardex_materia_primaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kardex_materia_primas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kardex_materia_primas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kardex_materia_primas
    **/
    _count?: true | Kardex_materia_primaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kardex_materia_primaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kardex_materia_primaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kardex_materia_primaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kardex_materia_primaMaxAggregateInputType
  }

  export type GetKardex_materia_primaAggregateType<T extends Kardex_materia_primaAggregateArgs> = {
        [P in keyof T & keyof AggregateKardex_materia_prima]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKardex_materia_prima[P]>
      : GetScalarType<T[P], AggregateKardex_materia_prima[P]>
  }




  export type kardex_materia_primaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kardex_materia_primaWhereInput
    orderBy?: kardex_materia_primaOrderByWithAggregationInput | kardex_materia_primaOrderByWithAggregationInput[]
    by: Kardex_materia_primaScalarFieldEnum[] | Kardex_materia_primaScalarFieldEnum
    having?: kardex_materia_primaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kardex_materia_primaCountAggregateInputType | true
    _avg?: Kardex_materia_primaAvgAggregateInputType
    _sum?: Kardex_materia_primaSumAggregateInputType
    _min?: Kardex_materia_primaMinAggregateInputType
    _max?: Kardex_materia_primaMaxAggregateInputType
  }

  export type Kardex_materia_primaGroupByOutputType = {
    id_kardex: number
    id_materia_prima: number | null
    tipo_movimiento: string
    cantidad: Decimal
    saldo: Decimal
    costo_unitario: Decimal
    costo_total: Decimal
    fecha_movimiento: Date | null
    referencia: string | null
    observaciones: string | null
    _count: Kardex_materia_primaCountAggregateOutputType | null
    _avg: Kardex_materia_primaAvgAggregateOutputType | null
    _sum: Kardex_materia_primaSumAggregateOutputType | null
    _min: Kardex_materia_primaMinAggregateOutputType | null
    _max: Kardex_materia_primaMaxAggregateOutputType | null
  }

  type GetKardex_materia_primaGroupByPayload<T extends kardex_materia_primaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kardex_materia_primaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kardex_materia_primaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kardex_materia_primaGroupByOutputType[P]>
            : GetScalarType<T[P], Kardex_materia_primaGroupByOutputType[P]>
        }
      >
    >


  export type kardex_materia_primaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kardex?: boolean
    id_materia_prima?: boolean
    tipo_movimiento?: boolean
    cantidad?: boolean
    saldo?: boolean
    costo_unitario?: boolean
    costo_total?: boolean
    fecha_movimiento?: boolean
    referencia?: boolean
    observaciones?: boolean
    materia_prima?: boolean | kardex_materia_prima$materia_primaArgs<ExtArgs>
  }, ExtArgs["result"]["kardex_materia_prima"]>

  export type kardex_materia_primaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kardex?: boolean
    id_materia_prima?: boolean
    tipo_movimiento?: boolean
    cantidad?: boolean
    saldo?: boolean
    costo_unitario?: boolean
    costo_total?: boolean
    fecha_movimiento?: boolean
    referencia?: boolean
    observaciones?: boolean
    materia_prima?: boolean | kardex_materia_prima$materia_primaArgs<ExtArgs>
  }, ExtArgs["result"]["kardex_materia_prima"]>

  export type kardex_materia_primaSelectScalar = {
    id_kardex?: boolean
    id_materia_prima?: boolean
    tipo_movimiento?: boolean
    cantidad?: boolean
    saldo?: boolean
    costo_unitario?: boolean
    costo_total?: boolean
    fecha_movimiento?: boolean
    referencia?: boolean
    observaciones?: boolean
  }

  export type kardex_materia_primaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materia_prima?: boolean | kardex_materia_prima$materia_primaArgs<ExtArgs>
  }
  export type kardex_materia_primaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materia_prima?: boolean | kardex_materia_prima$materia_primaArgs<ExtArgs>
  }

  export type $kardex_materia_primaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kardex_materia_prima"
    objects: {
      materia_prima: Prisma.$materia_primaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_kardex: number
      id_materia_prima: number | null
      tipo_movimiento: string
      cantidad: Prisma.Decimal
      saldo: Prisma.Decimal
      costo_unitario: Prisma.Decimal
      costo_total: Prisma.Decimal
      fecha_movimiento: Date | null
      referencia: string | null
      observaciones: string | null
    }, ExtArgs["result"]["kardex_materia_prima"]>
    composites: {}
  }

  type kardex_materia_primaGetPayload<S extends boolean | null | undefined | kardex_materia_primaDefaultArgs> = $Result.GetResult<Prisma.$kardex_materia_primaPayload, S>

  type kardex_materia_primaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kardex_materia_primaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kardex_materia_primaCountAggregateInputType | true
    }

  export interface kardex_materia_primaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kardex_materia_prima'], meta: { name: 'kardex_materia_prima' } }
    /**
     * Find zero or one Kardex_materia_prima that matches the filter.
     * @param {kardex_materia_primaFindUniqueArgs} args - Arguments to find a Kardex_materia_prima
     * @example
     * // Get one Kardex_materia_prima
     * const kardex_materia_prima = await prisma.kardex_materia_prima.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kardex_materia_primaFindUniqueArgs>(args: SelectSubset<T, kardex_materia_primaFindUniqueArgs<ExtArgs>>): Prisma__kardex_materia_primaClient<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kardex_materia_prima that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kardex_materia_primaFindUniqueOrThrowArgs} args - Arguments to find a Kardex_materia_prima
     * @example
     * // Get one Kardex_materia_prima
     * const kardex_materia_prima = await prisma.kardex_materia_prima.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kardex_materia_primaFindUniqueOrThrowArgs>(args: SelectSubset<T, kardex_materia_primaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kardex_materia_primaClient<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kardex_materia_prima that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_materia_primaFindFirstArgs} args - Arguments to find a Kardex_materia_prima
     * @example
     * // Get one Kardex_materia_prima
     * const kardex_materia_prima = await prisma.kardex_materia_prima.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kardex_materia_primaFindFirstArgs>(args?: SelectSubset<T, kardex_materia_primaFindFirstArgs<ExtArgs>>): Prisma__kardex_materia_primaClient<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kardex_materia_prima that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_materia_primaFindFirstOrThrowArgs} args - Arguments to find a Kardex_materia_prima
     * @example
     * // Get one Kardex_materia_prima
     * const kardex_materia_prima = await prisma.kardex_materia_prima.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kardex_materia_primaFindFirstOrThrowArgs>(args?: SelectSubset<T, kardex_materia_primaFindFirstOrThrowArgs<ExtArgs>>): Prisma__kardex_materia_primaClient<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kardex_materia_primas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_materia_primaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kardex_materia_primas
     * const kardex_materia_primas = await prisma.kardex_materia_prima.findMany()
     * 
     * // Get first 10 Kardex_materia_primas
     * const kardex_materia_primas = await prisma.kardex_materia_prima.findMany({ take: 10 })
     * 
     * // Only select the `id_kardex`
     * const kardex_materia_primaWithId_kardexOnly = await prisma.kardex_materia_prima.findMany({ select: { id_kardex: true } })
     * 
     */
    findMany<T extends kardex_materia_primaFindManyArgs>(args?: SelectSubset<T, kardex_materia_primaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kardex_materia_prima.
     * @param {kardex_materia_primaCreateArgs} args - Arguments to create a Kardex_materia_prima.
     * @example
     * // Create one Kardex_materia_prima
     * const Kardex_materia_prima = await prisma.kardex_materia_prima.create({
     *   data: {
     *     // ... data to create a Kardex_materia_prima
     *   }
     * })
     * 
     */
    create<T extends kardex_materia_primaCreateArgs>(args: SelectSubset<T, kardex_materia_primaCreateArgs<ExtArgs>>): Prisma__kardex_materia_primaClient<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kardex_materia_primas.
     * @param {kardex_materia_primaCreateManyArgs} args - Arguments to create many Kardex_materia_primas.
     * @example
     * // Create many Kardex_materia_primas
     * const kardex_materia_prima = await prisma.kardex_materia_prima.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kardex_materia_primaCreateManyArgs>(args?: SelectSubset<T, kardex_materia_primaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kardex_materia_primas and returns the data saved in the database.
     * @param {kardex_materia_primaCreateManyAndReturnArgs} args - Arguments to create many Kardex_materia_primas.
     * @example
     * // Create many Kardex_materia_primas
     * const kardex_materia_prima = await prisma.kardex_materia_prima.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kardex_materia_primas and only return the `id_kardex`
     * const kardex_materia_primaWithId_kardexOnly = await prisma.kardex_materia_prima.createManyAndReturn({ 
     *   select: { id_kardex: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends kardex_materia_primaCreateManyAndReturnArgs>(args?: SelectSubset<T, kardex_materia_primaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Kardex_materia_prima.
     * @param {kardex_materia_primaDeleteArgs} args - Arguments to delete one Kardex_materia_prima.
     * @example
     * // Delete one Kardex_materia_prima
     * const Kardex_materia_prima = await prisma.kardex_materia_prima.delete({
     *   where: {
     *     // ... filter to delete one Kardex_materia_prima
     *   }
     * })
     * 
     */
    delete<T extends kardex_materia_primaDeleteArgs>(args: SelectSubset<T, kardex_materia_primaDeleteArgs<ExtArgs>>): Prisma__kardex_materia_primaClient<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kardex_materia_prima.
     * @param {kardex_materia_primaUpdateArgs} args - Arguments to update one Kardex_materia_prima.
     * @example
     * // Update one Kardex_materia_prima
     * const kardex_materia_prima = await prisma.kardex_materia_prima.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kardex_materia_primaUpdateArgs>(args: SelectSubset<T, kardex_materia_primaUpdateArgs<ExtArgs>>): Prisma__kardex_materia_primaClient<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kardex_materia_primas.
     * @param {kardex_materia_primaDeleteManyArgs} args - Arguments to filter Kardex_materia_primas to delete.
     * @example
     * // Delete a few Kardex_materia_primas
     * const { count } = await prisma.kardex_materia_prima.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kardex_materia_primaDeleteManyArgs>(args?: SelectSubset<T, kardex_materia_primaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kardex_materia_primas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_materia_primaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kardex_materia_primas
     * const kardex_materia_prima = await prisma.kardex_materia_prima.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kardex_materia_primaUpdateManyArgs>(args: SelectSubset<T, kardex_materia_primaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kardex_materia_prima.
     * @param {kardex_materia_primaUpsertArgs} args - Arguments to update or create a Kardex_materia_prima.
     * @example
     * // Update or create a Kardex_materia_prima
     * const kardex_materia_prima = await prisma.kardex_materia_prima.upsert({
     *   create: {
     *     // ... data to create a Kardex_materia_prima
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kardex_materia_prima we want to update
     *   }
     * })
     */
    upsert<T extends kardex_materia_primaUpsertArgs>(args: SelectSubset<T, kardex_materia_primaUpsertArgs<ExtArgs>>): Prisma__kardex_materia_primaClient<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kardex_materia_primas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_materia_primaCountArgs} args - Arguments to filter Kardex_materia_primas to count.
     * @example
     * // Count the number of Kardex_materia_primas
     * const count = await prisma.kardex_materia_prima.count({
     *   where: {
     *     // ... the filter for the Kardex_materia_primas we want to count
     *   }
     * })
    **/
    count<T extends kardex_materia_primaCountArgs>(
      args?: Subset<T, kardex_materia_primaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kardex_materia_primaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kardex_materia_prima.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kardex_materia_primaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kardex_materia_primaAggregateArgs>(args: Subset<T, Kardex_materia_primaAggregateArgs>): Prisma.PrismaPromise<GetKardex_materia_primaAggregateType<T>>

    /**
     * Group by Kardex_materia_prima.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_materia_primaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kardex_materia_primaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kardex_materia_primaGroupByArgs['orderBy'] }
        : { orderBy?: kardex_materia_primaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kardex_materia_primaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKardex_materia_primaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kardex_materia_prima model
   */
  readonly fields: kardex_materia_primaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kardex_materia_prima.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kardex_materia_primaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materia_prima<T extends kardex_materia_prima$materia_primaArgs<ExtArgs> = {}>(args?: Subset<T, kardex_materia_prima$materia_primaArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kardex_materia_prima model
   */ 
  interface kardex_materia_primaFieldRefs {
    readonly id_kardex: FieldRef<"kardex_materia_prima", 'Int'>
    readonly id_materia_prima: FieldRef<"kardex_materia_prima", 'Int'>
    readonly tipo_movimiento: FieldRef<"kardex_materia_prima", 'String'>
    readonly cantidad: FieldRef<"kardex_materia_prima", 'Decimal'>
    readonly saldo: FieldRef<"kardex_materia_prima", 'Decimal'>
    readonly costo_unitario: FieldRef<"kardex_materia_prima", 'Decimal'>
    readonly costo_total: FieldRef<"kardex_materia_prima", 'Decimal'>
    readonly fecha_movimiento: FieldRef<"kardex_materia_prima", 'DateTime'>
    readonly referencia: FieldRef<"kardex_materia_prima", 'String'>
    readonly observaciones: FieldRef<"kardex_materia_prima", 'String'>
  }
    

  // Custom InputTypes
  /**
   * kardex_materia_prima findUnique
   */
  export type kardex_materia_primaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
    /**
     * Filter, which kardex_materia_prima to fetch.
     */
    where: kardex_materia_primaWhereUniqueInput
  }

  /**
   * kardex_materia_prima findUniqueOrThrow
   */
  export type kardex_materia_primaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
    /**
     * Filter, which kardex_materia_prima to fetch.
     */
    where: kardex_materia_primaWhereUniqueInput
  }

  /**
   * kardex_materia_prima findFirst
   */
  export type kardex_materia_primaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
    /**
     * Filter, which kardex_materia_prima to fetch.
     */
    where?: kardex_materia_primaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kardex_materia_primas to fetch.
     */
    orderBy?: kardex_materia_primaOrderByWithRelationInput | kardex_materia_primaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kardex_materia_primas.
     */
    cursor?: kardex_materia_primaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kardex_materia_primas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kardex_materia_primas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kardex_materia_primas.
     */
    distinct?: Kardex_materia_primaScalarFieldEnum | Kardex_materia_primaScalarFieldEnum[]
  }

  /**
   * kardex_materia_prima findFirstOrThrow
   */
  export type kardex_materia_primaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
    /**
     * Filter, which kardex_materia_prima to fetch.
     */
    where?: kardex_materia_primaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kardex_materia_primas to fetch.
     */
    orderBy?: kardex_materia_primaOrderByWithRelationInput | kardex_materia_primaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kardex_materia_primas.
     */
    cursor?: kardex_materia_primaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kardex_materia_primas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kardex_materia_primas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kardex_materia_primas.
     */
    distinct?: Kardex_materia_primaScalarFieldEnum | Kardex_materia_primaScalarFieldEnum[]
  }

  /**
   * kardex_materia_prima findMany
   */
  export type kardex_materia_primaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
    /**
     * Filter, which kardex_materia_primas to fetch.
     */
    where?: kardex_materia_primaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kardex_materia_primas to fetch.
     */
    orderBy?: kardex_materia_primaOrderByWithRelationInput | kardex_materia_primaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kardex_materia_primas.
     */
    cursor?: kardex_materia_primaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kardex_materia_primas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kardex_materia_primas.
     */
    skip?: number
    distinct?: Kardex_materia_primaScalarFieldEnum | Kardex_materia_primaScalarFieldEnum[]
  }

  /**
   * kardex_materia_prima create
   */
  export type kardex_materia_primaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
    /**
     * The data needed to create a kardex_materia_prima.
     */
    data: XOR<kardex_materia_primaCreateInput, kardex_materia_primaUncheckedCreateInput>
  }

  /**
   * kardex_materia_prima createMany
   */
  export type kardex_materia_primaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kardex_materia_primas.
     */
    data: kardex_materia_primaCreateManyInput | kardex_materia_primaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kardex_materia_prima createManyAndReturn
   */
  export type kardex_materia_primaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many kardex_materia_primas.
     */
    data: kardex_materia_primaCreateManyInput | kardex_materia_primaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * kardex_materia_prima update
   */
  export type kardex_materia_primaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
    /**
     * The data needed to update a kardex_materia_prima.
     */
    data: XOR<kardex_materia_primaUpdateInput, kardex_materia_primaUncheckedUpdateInput>
    /**
     * Choose, which kardex_materia_prima to update.
     */
    where: kardex_materia_primaWhereUniqueInput
  }

  /**
   * kardex_materia_prima updateMany
   */
  export type kardex_materia_primaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kardex_materia_primas.
     */
    data: XOR<kardex_materia_primaUpdateManyMutationInput, kardex_materia_primaUncheckedUpdateManyInput>
    /**
     * Filter which kardex_materia_primas to update
     */
    where?: kardex_materia_primaWhereInput
  }

  /**
   * kardex_materia_prima upsert
   */
  export type kardex_materia_primaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
    /**
     * The filter to search for the kardex_materia_prima to update in case it exists.
     */
    where: kardex_materia_primaWhereUniqueInput
    /**
     * In case the kardex_materia_prima found by the `where` argument doesn't exist, create a new kardex_materia_prima with this data.
     */
    create: XOR<kardex_materia_primaCreateInput, kardex_materia_primaUncheckedCreateInput>
    /**
     * In case the kardex_materia_prima was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kardex_materia_primaUpdateInput, kardex_materia_primaUncheckedUpdateInput>
  }

  /**
   * kardex_materia_prima delete
   */
  export type kardex_materia_primaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
    /**
     * Filter which kardex_materia_prima to delete.
     */
    where: kardex_materia_primaWhereUniqueInput
  }

  /**
   * kardex_materia_prima deleteMany
   */
  export type kardex_materia_primaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kardex_materia_primas to delete
     */
    where?: kardex_materia_primaWhereInput
  }

  /**
   * kardex_materia_prima.materia_prima
   */
  export type kardex_materia_prima$materia_primaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    where?: materia_primaWhereInput
  }

  /**
   * kardex_materia_prima without action
   */
  export type kardex_materia_primaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
  }


  /**
   * Model kardex_productos
   */

  export type AggregateKardex_productos = {
    _count: Kardex_productosCountAggregateOutputType | null
    _avg: Kardex_productosAvgAggregateOutputType | null
    _sum: Kardex_productosSumAggregateOutputType | null
    _min: Kardex_productosMinAggregateOutputType | null
    _max: Kardex_productosMaxAggregateOutputType | null
  }

  export type Kardex_productosAvgAggregateOutputType = {
    id_kardex: number | null
    id_producto: number | null
    cantidad: Decimal | null
    saldo: Decimal | null
    costo_produccion: Decimal | null
    precio_venta: Decimal | null
  }

  export type Kardex_productosSumAggregateOutputType = {
    id_kardex: number | null
    id_producto: number | null
    cantidad: Decimal | null
    saldo: Decimal | null
    costo_produccion: Decimal | null
    precio_venta: Decimal | null
  }

  export type Kardex_productosMinAggregateOutputType = {
    id_kardex: number | null
    id_producto: number | null
    tipo_movimiento: string | null
    cantidad: Decimal | null
    saldo: Decimal | null
    costo_produccion: Decimal | null
    precio_venta: Decimal | null
    fecha_movimiento: Date | null
    referencia: string | null
    observaciones: string | null
  }

  export type Kardex_productosMaxAggregateOutputType = {
    id_kardex: number | null
    id_producto: number | null
    tipo_movimiento: string | null
    cantidad: Decimal | null
    saldo: Decimal | null
    costo_produccion: Decimal | null
    precio_venta: Decimal | null
    fecha_movimiento: Date | null
    referencia: string | null
    observaciones: string | null
  }

  export type Kardex_productosCountAggregateOutputType = {
    id_kardex: number
    id_producto: number
    tipo_movimiento: number
    cantidad: number
    saldo: number
    costo_produccion: number
    precio_venta: number
    fecha_movimiento: number
    referencia: number
    referencias_archivos: number
    observaciones: number
    _all: number
  }


  export type Kardex_productosAvgAggregateInputType = {
    id_kardex?: true
    id_producto?: true
    cantidad?: true
    saldo?: true
    costo_produccion?: true
    precio_venta?: true
  }

  export type Kardex_productosSumAggregateInputType = {
    id_kardex?: true
    id_producto?: true
    cantidad?: true
    saldo?: true
    costo_produccion?: true
    precio_venta?: true
  }

  export type Kardex_productosMinAggregateInputType = {
    id_kardex?: true
    id_producto?: true
    tipo_movimiento?: true
    cantidad?: true
    saldo?: true
    costo_produccion?: true
    precio_venta?: true
    fecha_movimiento?: true
    referencia?: true
    observaciones?: true
  }

  export type Kardex_productosMaxAggregateInputType = {
    id_kardex?: true
    id_producto?: true
    tipo_movimiento?: true
    cantidad?: true
    saldo?: true
    costo_produccion?: true
    precio_venta?: true
    fecha_movimiento?: true
    referencia?: true
    observaciones?: true
  }

  export type Kardex_productosCountAggregateInputType = {
    id_kardex?: true
    id_producto?: true
    tipo_movimiento?: true
    cantidad?: true
    saldo?: true
    costo_produccion?: true
    precio_venta?: true
    fecha_movimiento?: true
    referencia?: true
    referencias_archivos?: true
    observaciones?: true
    _all?: true
  }

  export type Kardex_productosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kardex_productos to aggregate.
     */
    where?: kardex_productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kardex_productos to fetch.
     */
    orderBy?: kardex_productosOrderByWithRelationInput | kardex_productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kardex_productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kardex_productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kardex_productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kardex_productos
    **/
    _count?: true | Kardex_productosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kardex_productosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kardex_productosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kardex_productosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kardex_productosMaxAggregateInputType
  }

  export type GetKardex_productosAggregateType<T extends Kardex_productosAggregateArgs> = {
        [P in keyof T & keyof AggregateKardex_productos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKardex_productos[P]>
      : GetScalarType<T[P], AggregateKardex_productos[P]>
  }




  export type kardex_productosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kardex_productosWhereInput
    orderBy?: kardex_productosOrderByWithAggregationInput | kardex_productosOrderByWithAggregationInput[]
    by: Kardex_productosScalarFieldEnum[] | Kardex_productosScalarFieldEnum
    having?: kardex_productosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kardex_productosCountAggregateInputType | true
    _avg?: Kardex_productosAvgAggregateInputType
    _sum?: Kardex_productosSumAggregateInputType
    _min?: Kardex_productosMinAggregateInputType
    _max?: Kardex_productosMaxAggregateInputType
  }

  export type Kardex_productosGroupByOutputType = {
    id_kardex: number
    id_producto: number | null
    tipo_movimiento: string
    cantidad: Decimal
    saldo: Decimal
    costo_produccion: Decimal | null
    precio_venta: Decimal | null
    fecha_movimiento: Date | null
    referencia: string | null
    referencias_archivos: string[]
    observaciones: string | null
    _count: Kardex_productosCountAggregateOutputType | null
    _avg: Kardex_productosAvgAggregateOutputType | null
    _sum: Kardex_productosSumAggregateOutputType | null
    _min: Kardex_productosMinAggregateOutputType | null
    _max: Kardex_productosMaxAggregateOutputType | null
  }

  type GetKardex_productosGroupByPayload<T extends kardex_productosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kardex_productosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kardex_productosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kardex_productosGroupByOutputType[P]>
            : GetScalarType<T[P], Kardex_productosGroupByOutputType[P]>
        }
      >
    >


  export type kardex_productosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kardex?: boolean
    id_producto?: boolean
    tipo_movimiento?: boolean
    cantidad?: boolean
    saldo?: boolean
    costo_produccion?: boolean
    precio_venta?: boolean
    fecha_movimiento?: boolean
    referencia?: boolean
    referencias_archivos?: boolean
    observaciones?: boolean
    productos_terminados?: boolean | kardex_productos$productos_terminadosArgs<ExtArgs>
  }, ExtArgs["result"]["kardex_productos"]>

  export type kardex_productosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kardex?: boolean
    id_producto?: boolean
    tipo_movimiento?: boolean
    cantidad?: boolean
    saldo?: boolean
    costo_produccion?: boolean
    precio_venta?: boolean
    fecha_movimiento?: boolean
    referencia?: boolean
    referencias_archivos?: boolean
    observaciones?: boolean
    productos_terminados?: boolean | kardex_productos$productos_terminadosArgs<ExtArgs>
  }, ExtArgs["result"]["kardex_productos"]>

  export type kardex_productosSelectScalar = {
    id_kardex?: boolean
    id_producto?: boolean
    tipo_movimiento?: boolean
    cantidad?: boolean
    saldo?: boolean
    costo_produccion?: boolean
    precio_venta?: boolean
    fecha_movimiento?: boolean
    referencia?: boolean
    referencias_archivos?: boolean
    observaciones?: boolean
  }

  export type kardex_productosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos_terminados?: boolean | kardex_productos$productos_terminadosArgs<ExtArgs>
  }
  export type kardex_productosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos_terminados?: boolean | kardex_productos$productos_terminadosArgs<ExtArgs>
  }

  export type $kardex_productosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kardex_productos"
    objects: {
      productos_terminados: Prisma.$productos_terminadosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_kardex: number
      id_producto: number | null
      tipo_movimiento: string
      cantidad: Prisma.Decimal
      saldo: Prisma.Decimal
      costo_produccion: Prisma.Decimal | null
      precio_venta: Prisma.Decimal | null
      fecha_movimiento: Date | null
      referencia: string | null
      referencias_archivos: string[]
      observaciones: string | null
    }, ExtArgs["result"]["kardex_productos"]>
    composites: {}
  }

  type kardex_productosGetPayload<S extends boolean | null | undefined | kardex_productosDefaultArgs> = $Result.GetResult<Prisma.$kardex_productosPayload, S>

  type kardex_productosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kardex_productosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kardex_productosCountAggregateInputType | true
    }

  export interface kardex_productosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kardex_productos'], meta: { name: 'kardex_productos' } }
    /**
     * Find zero or one Kardex_productos that matches the filter.
     * @param {kardex_productosFindUniqueArgs} args - Arguments to find a Kardex_productos
     * @example
     * // Get one Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kardex_productosFindUniqueArgs>(args: SelectSubset<T, kardex_productosFindUniqueArgs<ExtArgs>>): Prisma__kardex_productosClient<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kardex_productos that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kardex_productosFindUniqueOrThrowArgs} args - Arguments to find a Kardex_productos
     * @example
     * // Get one Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kardex_productosFindUniqueOrThrowArgs>(args: SelectSubset<T, kardex_productosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kardex_productosClient<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kardex_productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_productosFindFirstArgs} args - Arguments to find a Kardex_productos
     * @example
     * // Get one Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kardex_productosFindFirstArgs>(args?: SelectSubset<T, kardex_productosFindFirstArgs<ExtArgs>>): Prisma__kardex_productosClient<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kardex_productos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_productosFindFirstOrThrowArgs} args - Arguments to find a Kardex_productos
     * @example
     * // Get one Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kardex_productosFindFirstOrThrowArgs>(args?: SelectSubset<T, kardex_productosFindFirstOrThrowArgs<ExtArgs>>): Prisma__kardex_productosClient<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kardex_productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_productosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.findMany()
     * 
     * // Get first 10 Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.findMany({ take: 10 })
     * 
     * // Only select the `id_kardex`
     * const kardex_productosWithId_kardexOnly = await prisma.kardex_productos.findMany({ select: { id_kardex: true } })
     * 
     */
    findMany<T extends kardex_productosFindManyArgs>(args?: SelectSubset<T, kardex_productosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kardex_productos.
     * @param {kardex_productosCreateArgs} args - Arguments to create a Kardex_productos.
     * @example
     * // Create one Kardex_productos
     * const Kardex_productos = await prisma.kardex_productos.create({
     *   data: {
     *     // ... data to create a Kardex_productos
     *   }
     * })
     * 
     */
    create<T extends kardex_productosCreateArgs>(args: SelectSubset<T, kardex_productosCreateArgs<ExtArgs>>): Prisma__kardex_productosClient<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kardex_productos.
     * @param {kardex_productosCreateManyArgs} args - Arguments to create many Kardex_productos.
     * @example
     * // Create many Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kardex_productosCreateManyArgs>(args?: SelectSubset<T, kardex_productosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kardex_productos and returns the data saved in the database.
     * @param {kardex_productosCreateManyAndReturnArgs} args - Arguments to create many Kardex_productos.
     * @example
     * // Create many Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kardex_productos and only return the `id_kardex`
     * const kardex_productosWithId_kardexOnly = await prisma.kardex_productos.createManyAndReturn({ 
     *   select: { id_kardex: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends kardex_productosCreateManyAndReturnArgs>(args?: SelectSubset<T, kardex_productosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Kardex_productos.
     * @param {kardex_productosDeleteArgs} args - Arguments to delete one Kardex_productos.
     * @example
     * // Delete one Kardex_productos
     * const Kardex_productos = await prisma.kardex_productos.delete({
     *   where: {
     *     // ... filter to delete one Kardex_productos
     *   }
     * })
     * 
     */
    delete<T extends kardex_productosDeleteArgs>(args: SelectSubset<T, kardex_productosDeleteArgs<ExtArgs>>): Prisma__kardex_productosClient<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kardex_productos.
     * @param {kardex_productosUpdateArgs} args - Arguments to update one Kardex_productos.
     * @example
     * // Update one Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kardex_productosUpdateArgs>(args: SelectSubset<T, kardex_productosUpdateArgs<ExtArgs>>): Prisma__kardex_productosClient<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kardex_productos.
     * @param {kardex_productosDeleteManyArgs} args - Arguments to filter Kardex_productos to delete.
     * @example
     * // Delete a few Kardex_productos
     * const { count } = await prisma.kardex_productos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kardex_productosDeleteManyArgs>(args?: SelectSubset<T, kardex_productosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kardex_productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_productosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kardex_productosUpdateManyArgs>(args: SelectSubset<T, kardex_productosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kardex_productos.
     * @param {kardex_productosUpsertArgs} args - Arguments to update or create a Kardex_productos.
     * @example
     * // Update or create a Kardex_productos
     * const kardex_productos = await prisma.kardex_productos.upsert({
     *   create: {
     *     // ... data to create a Kardex_productos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kardex_productos we want to update
     *   }
     * })
     */
    upsert<T extends kardex_productosUpsertArgs>(args: SelectSubset<T, kardex_productosUpsertArgs<ExtArgs>>): Prisma__kardex_productosClient<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kardex_productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_productosCountArgs} args - Arguments to filter Kardex_productos to count.
     * @example
     * // Count the number of Kardex_productos
     * const count = await prisma.kardex_productos.count({
     *   where: {
     *     // ... the filter for the Kardex_productos we want to count
     *   }
     * })
    **/
    count<T extends kardex_productosCountArgs>(
      args?: Subset<T, kardex_productosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kardex_productosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kardex_productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kardex_productosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kardex_productosAggregateArgs>(args: Subset<T, Kardex_productosAggregateArgs>): Prisma.PrismaPromise<GetKardex_productosAggregateType<T>>

    /**
     * Group by Kardex_productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kardex_productosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kardex_productosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kardex_productosGroupByArgs['orderBy'] }
        : { orderBy?: kardex_productosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kardex_productosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKardex_productosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kardex_productos model
   */
  readonly fields: kardex_productosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kardex_productos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kardex_productosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productos_terminados<T extends kardex_productos$productos_terminadosArgs<ExtArgs> = {}>(args?: Subset<T, kardex_productos$productos_terminadosArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kardex_productos model
   */ 
  interface kardex_productosFieldRefs {
    readonly id_kardex: FieldRef<"kardex_productos", 'Int'>
    readonly id_producto: FieldRef<"kardex_productos", 'Int'>
    readonly tipo_movimiento: FieldRef<"kardex_productos", 'String'>
    readonly cantidad: FieldRef<"kardex_productos", 'Decimal'>
    readonly saldo: FieldRef<"kardex_productos", 'Decimal'>
    readonly costo_produccion: FieldRef<"kardex_productos", 'Decimal'>
    readonly precio_venta: FieldRef<"kardex_productos", 'Decimal'>
    readonly fecha_movimiento: FieldRef<"kardex_productos", 'DateTime'>
    readonly referencia: FieldRef<"kardex_productos", 'String'>
    readonly referencias_archivos: FieldRef<"kardex_productos", 'String[]'>
    readonly observaciones: FieldRef<"kardex_productos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * kardex_productos findUnique
   */
  export type kardex_productosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
    /**
     * Filter, which kardex_productos to fetch.
     */
    where: kardex_productosWhereUniqueInput
  }

  /**
   * kardex_productos findUniqueOrThrow
   */
  export type kardex_productosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
    /**
     * Filter, which kardex_productos to fetch.
     */
    where: kardex_productosWhereUniqueInput
  }

  /**
   * kardex_productos findFirst
   */
  export type kardex_productosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
    /**
     * Filter, which kardex_productos to fetch.
     */
    where?: kardex_productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kardex_productos to fetch.
     */
    orderBy?: kardex_productosOrderByWithRelationInput | kardex_productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kardex_productos.
     */
    cursor?: kardex_productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kardex_productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kardex_productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kardex_productos.
     */
    distinct?: Kardex_productosScalarFieldEnum | Kardex_productosScalarFieldEnum[]
  }

  /**
   * kardex_productos findFirstOrThrow
   */
  export type kardex_productosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
    /**
     * Filter, which kardex_productos to fetch.
     */
    where?: kardex_productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kardex_productos to fetch.
     */
    orderBy?: kardex_productosOrderByWithRelationInput | kardex_productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kardex_productos.
     */
    cursor?: kardex_productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kardex_productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kardex_productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kardex_productos.
     */
    distinct?: Kardex_productosScalarFieldEnum | Kardex_productosScalarFieldEnum[]
  }

  /**
   * kardex_productos findMany
   */
  export type kardex_productosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
    /**
     * Filter, which kardex_productos to fetch.
     */
    where?: kardex_productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kardex_productos to fetch.
     */
    orderBy?: kardex_productosOrderByWithRelationInput | kardex_productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kardex_productos.
     */
    cursor?: kardex_productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kardex_productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kardex_productos.
     */
    skip?: number
    distinct?: Kardex_productosScalarFieldEnum | Kardex_productosScalarFieldEnum[]
  }

  /**
   * kardex_productos create
   */
  export type kardex_productosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
    /**
     * The data needed to create a kardex_productos.
     */
    data: XOR<kardex_productosCreateInput, kardex_productosUncheckedCreateInput>
  }

  /**
   * kardex_productos createMany
   */
  export type kardex_productosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kardex_productos.
     */
    data: kardex_productosCreateManyInput | kardex_productosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kardex_productos createManyAndReturn
   */
  export type kardex_productosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many kardex_productos.
     */
    data: kardex_productosCreateManyInput | kardex_productosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * kardex_productos update
   */
  export type kardex_productosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
    /**
     * The data needed to update a kardex_productos.
     */
    data: XOR<kardex_productosUpdateInput, kardex_productosUncheckedUpdateInput>
    /**
     * Choose, which kardex_productos to update.
     */
    where: kardex_productosWhereUniqueInput
  }

  /**
   * kardex_productos updateMany
   */
  export type kardex_productosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kardex_productos.
     */
    data: XOR<kardex_productosUpdateManyMutationInput, kardex_productosUncheckedUpdateManyInput>
    /**
     * Filter which kardex_productos to update
     */
    where?: kardex_productosWhereInput
  }

  /**
   * kardex_productos upsert
   */
  export type kardex_productosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
    /**
     * The filter to search for the kardex_productos to update in case it exists.
     */
    where: kardex_productosWhereUniqueInput
    /**
     * In case the kardex_productos found by the `where` argument doesn't exist, create a new kardex_productos with this data.
     */
    create: XOR<kardex_productosCreateInput, kardex_productosUncheckedCreateInput>
    /**
     * In case the kardex_productos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kardex_productosUpdateInput, kardex_productosUncheckedUpdateInput>
  }

  /**
   * kardex_productos delete
   */
  export type kardex_productosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
    /**
     * Filter which kardex_productos to delete.
     */
    where: kardex_productosWhereUniqueInput
  }

  /**
   * kardex_productos deleteMany
   */
  export type kardex_productosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kardex_productos to delete
     */
    where?: kardex_productosWhereInput
  }

  /**
   * kardex_productos.productos_terminados
   */
  export type kardex_productos$productos_terminadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    where?: productos_terminadosWhereInput
  }

  /**
   * kardex_productos without action
   */
  export type kardex_productosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
  }


  /**
   * Model materia_prima
   */

  export type AggregateMateria_prima = {
    _count: Materia_primaCountAggregateOutputType | null
    _avg: Materia_primaAvgAggregateOutputType | null
    _sum: Materia_primaSumAggregateOutputType | null
    _min: Materia_primaMinAggregateOutputType | null
    _max: Materia_primaMaxAggregateOutputType | null
  }

  export type Materia_primaAvgAggregateOutputType = {
    id_materia_prima: number | null
    unidad_medida_id: number | null
    costo_unitario: Decimal | null
    presentacion: Decimal | null
    stock_actual: Decimal | null
  }

  export type Materia_primaSumAggregateOutputType = {
    id_materia_prima: number | null
    unidad_medida_id: number | null
    costo_unitario: Decimal | null
    presentacion: Decimal | null
    stock_actual: Decimal | null
  }

  export type Materia_primaMinAggregateOutputType = {
    id_materia_prima: number | null
    nombre: string | null
    unidad_medida_id: number | null
    costo_unitario: Decimal | null
    presentacion: Decimal | null
    stock_actual: Decimal | null
    codigo_barras: string | null
    fecha_registro: Date | null
    disponible: boolean | null
  }

  export type Materia_primaMaxAggregateOutputType = {
    id_materia_prima: number | null
    nombre: string | null
    unidad_medida_id: number | null
    costo_unitario: Decimal | null
    presentacion: Decimal | null
    stock_actual: Decimal | null
    codigo_barras: string | null
    fecha_registro: Date | null
    disponible: boolean | null
  }

  export type Materia_primaCountAggregateOutputType = {
    id_materia_prima: number
    nombre: number
    unidad_medida_id: number
    costo_unitario: number
    presentacion: number
    stock_actual: number
    codigo_barras: number
    fecha_registro: number
    disponible: number
    _all: number
  }


  export type Materia_primaAvgAggregateInputType = {
    id_materia_prima?: true
    unidad_medida_id?: true
    costo_unitario?: true
    presentacion?: true
    stock_actual?: true
  }

  export type Materia_primaSumAggregateInputType = {
    id_materia_prima?: true
    unidad_medida_id?: true
    costo_unitario?: true
    presentacion?: true
    stock_actual?: true
  }

  export type Materia_primaMinAggregateInputType = {
    id_materia_prima?: true
    nombre?: true
    unidad_medida_id?: true
    costo_unitario?: true
    presentacion?: true
    stock_actual?: true
    codigo_barras?: true
    fecha_registro?: true
    disponible?: true
  }

  export type Materia_primaMaxAggregateInputType = {
    id_materia_prima?: true
    nombre?: true
    unidad_medida_id?: true
    costo_unitario?: true
    presentacion?: true
    stock_actual?: true
    codigo_barras?: true
    fecha_registro?: true
    disponible?: true
  }

  export type Materia_primaCountAggregateInputType = {
    id_materia_prima?: true
    nombre?: true
    unidad_medida_id?: true
    costo_unitario?: true
    presentacion?: true
    stock_actual?: true
    codigo_barras?: true
    fecha_registro?: true
    disponible?: true
    _all?: true
  }

  export type Materia_primaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which materia_prima to aggregate.
     */
    where?: materia_primaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materia_primas to fetch.
     */
    orderBy?: materia_primaOrderByWithRelationInput | materia_primaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: materia_primaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materia_primas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materia_primas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned materia_primas
    **/
    _count?: true | Materia_primaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Materia_primaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Materia_primaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Materia_primaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Materia_primaMaxAggregateInputType
  }

  export type GetMateria_primaAggregateType<T extends Materia_primaAggregateArgs> = {
        [P in keyof T & keyof AggregateMateria_prima]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateria_prima[P]>
      : GetScalarType<T[P], AggregateMateria_prima[P]>
  }




  export type materia_primaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: materia_primaWhereInput
    orderBy?: materia_primaOrderByWithAggregationInput | materia_primaOrderByWithAggregationInput[]
    by: Materia_primaScalarFieldEnum[] | Materia_primaScalarFieldEnum
    having?: materia_primaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Materia_primaCountAggregateInputType | true
    _avg?: Materia_primaAvgAggregateInputType
    _sum?: Materia_primaSumAggregateInputType
    _min?: Materia_primaMinAggregateInputType
    _max?: Materia_primaMaxAggregateInputType
  }

  export type Materia_primaGroupByOutputType = {
    id_materia_prima: number
    nombre: string
    unidad_medida_id: number
    costo_unitario: Decimal
    presentacion: Decimal
    stock_actual: Decimal | null
    codigo_barras: string
    fecha_registro: Date | null
    disponible: boolean
    _count: Materia_primaCountAggregateOutputType | null
    _avg: Materia_primaAvgAggregateOutputType | null
    _sum: Materia_primaSumAggregateOutputType | null
    _min: Materia_primaMinAggregateOutputType | null
    _max: Materia_primaMaxAggregateOutputType | null
  }

  type GetMateria_primaGroupByPayload<T extends materia_primaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Materia_primaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Materia_primaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Materia_primaGroupByOutputType[P]>
            : GetScalarType<T[P], Materia_primaGroupByOutputType[P]>
        }
      >
    >


  export type materia_primaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_materia_prima?: boolean
    nombre?: boolean
    unidad_medida_id?: boolean
    costo_unitario?: boolean
    presentacion?: boolean
    stock_actual?: boolean
    codigo_barras?: boolean
    fecha_registro?: boolean
    disponible?: boolean
    detalle_factura?: boolean | materia_prima$detalle_facturaArgs<ExtArgs>
    kardex_materia_prima?: boolean | materia_prima$kardex_materia_primaArgs<ExtArgs>
    recetas?: boolean | materia_prima$recetasArgs<ExtArgs>
    unidad_medida?: boolean | unidadesmedidaDefaultArgs<ExtArgs>
    _count?: boolean | Materia_primaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materia_prima"]>

  export type materia_primaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_materia_prima?: boolean
    nombre?: boolean
    unidad_medida_id?: boolean
    costo_unitario?: boolean
    presentacion?: boolean
    stock_actual?: boolean
    codigo_barras?: boolean
    fecha_registro?: boolean
    disponible?: boolean
    unidad_medida?: boolean | unidadesmedidaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materia_prima"]>

  export type materia_primaSelectScalar = {
    id_materia_prima?: boolean
    nombre?: boolean
    unidad_medida_id?: boolean
    costo_unitario?: boolean
    presentacion?: boolean
    stock_actual?: boolean
    codigo_barras?: boolean
    fecha_registro?: boolean
    disponible?: boolean
  }

  export type materia_primaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_factura?: boolean | materia_prima$detalle_facturaArgs<ExtArgs>
    kardex_materia_prima?: boolean | materia_prima$kardex_materia_primaArgs<ExtArgs>
    recetas?: boolean | materia_prima$recetasArgs<ExtArgs>
    unidad_medida?: boolean | unidadesmedidaDefaultArgs<ExtArgs>
    _count?: boolean | Materia_primaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type materia_primaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unidad_medida?: boolean | unidadesmedidaDefaultArgs<ExtArgs>
  }

  export type $materia_primaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "materia_prima"
    objects: {
      detalle_factura: Prisma.$detalle_facturaPayload<ExtArgs>[]
      kardex_materia_prima: Prisma.$kardex_materia_primaPayload<ExtArgs>[]
      recetas: Prisma.$recetasPayload<ExtArgs>[]
      unidad_medida: Prisma.$unidadesmedidaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_materia_prima: number
      nombre: string
      unidad_medida_id: number
      costo_unitario: Prisma.Decimal
      presentacion: Prisma.Decimal
      stock_actual: Prisma.Decimal | null
      codigo_barras: string
      fecha_registro: Date | null
      disponible: boolean
    }, ExtArgs["result"]["materia_prima"]>
    composites: {}
  }

  type materia_primaGetPayload<S extends boolean | null | undefined | materia_primaDefaultArgs> = $Result.GetResult<Prisma.$materia_primaPayload, S>

  type materia_primaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<materia_primaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Materia_primaCountAggregateInputType | true
    }

  export interface materia_primaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['materia_prima'], meta: { name: 'materia_prima' } }
    /**
     * Find zero or one Materia_prima that matches the filter.
     * @param {materia_primaFindUniqueArgs} args - Arguments to find a Materia_prima
     * @example
     * // Get one Materia_prima
     * const materia_prima = await prisma.materia_prima.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends materia_primaFindUniqueArgs>(args: SelectSubset<T, materia_primaFindUniqueArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Materia_prima that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {materia_primaFindUniqueOrThrowArgs} args - Arguments to find a Materia_prima
     * @example
     * // Get one Materia_prima
     * const materia_prima = await prisma.materia_prima.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends materia_primaFindUniqueOrThrowArgs>(args: SelectSubset<T, materia_primaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Materia_prima that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materia_primaFindFirstArgs} args - Arguments to find a Materia_prima
     * @example
     * // Get one Materia_prima
     * const materia_prima = await prisma.materia_prima.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends materia_primaFindFirstArgs>(args?: SelectSubset<T, materia_primaFindFirstArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Materia_prima that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materia_primaFindFirstOrThrowArgs} args - Arguments to find a Materia_prima
     * @example
     * // Get one Materia_prima
     * const materia_prima = await prisma.materia_prima.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends materia_primaFindFirstOrThrowArgs>(args?: SelectSubset<T, materia_primaFindFirstOrThrowArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Materia_primas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materia_primaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materia_primas
     * const materia_primas = await prisma.materia_prima.findMany()
     * 
     * // Get first 10 Materia_primas
     * const materia_primas = await prisma.materia_prima.findMany({ take: 10 })
     * 
     * // Only select the `id_materia_prima`
     * const materia_primaWithId_materia_primaOnly = await prisma.materia_prima.findMany({ select: { id_materia_prima: true } })
     * 
     */
    findMany<T extends materia_primaFindManyArgs>(args?: SelectSubset<T, materia_primaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Materia_prima.
     * @param {materia_primaCreateArgs} args - Arguments to create a Materia_prima.
     * @example
     * // Create one Materia_prima
     * const Materia_prima = await prisma.materia_prima.create({
     *   data: {
     *     // ... data to create a Materia_prima
     *   }
     * })
     * 
     */
    create<T extends materia_primaCreateArgs>(args: SelectSubset<T, materia_primaCreateArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Materia_primas.
     * @param {materia_primaCreateManyArgs} args - Arguments to create many Materia_primas.
     * @example
     * // Create many Materia_primas
     * const materia_prima = await prisma.materia_prima.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends materia_primaCreateManyArgs>(args?: SelectSubset<T, materia_primaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materia_primas and returns the data saved in the database.
     * @param {materia_primaCreateManyAndReturnArgs} args - Arguments to create many Materia_primas.
     * @example
     * // Create many Materia_primas
     * const materia_prima = await prisma.materia_prima.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materia_primas and only return the `id_materia_prima`
     * const materia_primaWithId_materia_primaOnly = await prisma.materia_prima.createManyAndReturn({ 
     *   select: { id_materia_prima: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends materia_primaCreateManyAndReturnArgs>(args?: SelectSubset<T, materia_primaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Materia_prima.
     * @param {materia_primaDeleteArgs} args - Arguments to delete one Materia_prima.
     * @example
     * // Delete one Materia_prima
     * const Materia_prima = await prisma.materia_prima.delete({
     *   where: {
     *     // ... filter to delete one Materia_prima
     *   }
     * })
     * 
     */
    delete<T extends materia_primaDeleteArgs>(args: SelectSubset<T, materia_primaDeleteArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Materia_prima.
     * @param {materia_primaUpdateArgs} args - Arguments to update one Materia_prima.
     * @example
     * // Update one Materia_prima
     * const materia_prima = await prisma.materia_prima.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends materia_primaUpdateArgs>(args: SelectSubset<T, materia_primaUpdateArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Materia_primas.
     * @param {materia_primaDeleteManyArgs} args - Arguments to filter Materia_primas to delete.
     * @example
     * // Delete a few Materia_primas
     * const { count } = await prisma.materia_prima.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends materia_primaDeleteManyArgs>(args?: SelectSubset<T, materia_primaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materia_primas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materia_primaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materia_primas
     * const materia_prima = await prisma.materia_prima.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends materia_primaUpdateManyArgs>(args: SelectSubset<T, materia_primaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materia_prima.
     * @param {materia_primaUpsertArgs} args - Arguments to update or create a Materia_prima.
     * @example
     * // Update or create a Materia_prima
     * const materia_prima = await prisma.materia_prima.upsert({
     *   create: {
     *     // ... data to create a Materia_prima
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materia_prima we want to update
     *   }
     * })
     */
    upsert<T extends materia_primaUpsertArgs>(args: SelectSubset<T, materia_primaUpsertArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Materia_primas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materia_primaCountArgs} args - Arguments to filter Materia_primas to count.
     * @example
     * // Count the number of Materia_primas
     * const count = await prisma.materia_prima.count({
     *   where: {
     *     // ... the filter for the Materia_primas we want to count
     *   }
     * })
    **/
    count<T extends materia_primaCountArgs>(
      args?: Subset<T, materia_primaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Materia_primaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materia_prima.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Materia_primaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Materia_primaAggregateArgs>(args: Subset<T, Materia_primaAggregateArgs>): Prisma.PrismaPromise<GetMateria_primaAggregateType<T>>

    /**
     * Group by Materia_prima.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materia_primaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends materia_primaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: materia_primaGroupByArgs['orderBy'] }
        : { orderBy?: materia_primaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, materia_primaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMateria_primaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the materia_prima model
   */
  readonly fields: materia_primaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for materia_prima.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__materia_primaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detalle_factura<T extends materia_prima$detalle_facturaArgs<ExtArgs> = {}>(args?: Subset<T, materia_prima$detalle_facturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "findMany"> | Null>
    kardex_materia_prima<T extends materia_prima$kardex_materia_primaArgs<ExtArgs> = {}>(args?: Subset<T, materia_prima$kardex_materia_primaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kardex_materia_primaPayload<ExtArgs>, T, "findMany"> | Null>
    recetas<T extends materia_prima$recetasArgs<ExtArgs> = {}>(args?: Subset<T, materia_prima$recetasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "findMany"> | Null>
    unidad_medida<T extends unidadesmedidaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, unidadesmedidaDefaultArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the materia_prima model
   */ 
  interface materia_primaFieldRefs {
    readonly id_materia_prima: FieldRef<"materia_prima", 'Int'>
    readonly nombre: FieldRef<"materia_prima", 'String'>
    readonly unidad_medida_id: FieldRef<"materia_prima", 'Int'>
    readonly costo_unitario: FieldRef<"materia_prima", 'Decimal'>
    readonly presentacion: FieldRef<"materia_prima", 'Decimal'>
    readonly stock_actual: FieldRef<"materia_prima", 'Decimal'>
    readonly codigo_barras: FieldRef<"materia_prima", 'String'>
    readonly fecha_registro: FieldRef<"materia_prima", 'DateTime'>
    readonly disponible: FieldRef<"materia_prima", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * materia_prima findUnique
   */
  export type materia_primaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    /**
     * Filter, which materia_prima to fetch.
     */
    where: materia_primaWhereUniqueInput
  }

  /**
   * materia_prima findUniqueOrThrow
   */
  export type materia_primaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    /**
     * Filter, which materia_prima to fetch.
     */
    where: materia_primaWhereUniqueInput
  }

  /**
   * materia_prima findFirst
   */
  export type materia_primaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    /**
     * Filter, which materia_prima to fetch.
     */
    where?: materia_primaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materia_primas to fetch.
     */
    orderBy?: materia_primaOrderByWithRelationInput | materia_primaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materia_primas.
     */
    cursor?: materia_primaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materia_primas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materia_primas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materia_primas.
     */
    distinct?: Materia_primaScalarFieldEnum | Materia_primaScalarFieldEnum[]
  }

  /**
   * materia_prima findFirstOrThrow
   */
  export type materia_primaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    /**
     * Filter, which materia_prima to fetch.
     */
    where?: materia_primaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materia_primas to fetch.
     */
    orderBy?: materia_primaOrderByWithRelationInput | materia_primaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materia_primas.
     */
    cursor?: materia_primaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materia_primas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materia_primas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materia_primas.
     */
    distinct?: Materia_primaScalarFieldEnum | Materia_primaScalarFieldEnum[]
  }

  /**
   * materia_prima findMany
   */
  export type materia_primaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    /**
     * Filter, which materia_primas to fetch.
     */
    where?: materia_primaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materia_primas to fetch.
     */
    orderBy?: materia_primaOrderByWithRelationInput | materia_primaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing materia_primas.
     */
    cursor?: materia_primaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materia_primas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materia_primas.
     */
    skip?: number
    distinct?: Materia_primaScalarFieldEnum | Materia_primaScalarFieldEnum[]
  }

  /**
   * materia_prima create
   */
  export type materia_primaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    /**
     * The data needed to create a materia_prima.
     */
    data: XOR<materia_primaCreateInput, materia_primaUncheckedCreateInput>
  }

  /**
   * materia_prima createMany
   */
  export type materia_primaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many materia_primas.
     */
    data: materia_primaCreateManyInput | materia_primaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * materia_prima createManyAndReturn
   */
  export type materia_primaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many materia_primas.
     */
    data: materia_primaCreateManyInput | materia_primaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * materia_prima update
   */
  export type materia_primaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    /**
     * The data needed to update a materia_prima.
     */
    data: XOR<materia_primaUpdateInput, materia_primaUncheckedUpdateInput>
    /**
     * Choose, which materia_prima to update.
     */
    where: materia_primaWhereUniqueInput
  }

  /**
   * materia_prima updateMany
   */
  export type materia_primaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update materia_primas.
     */
    data: XOR<materia_primaUpdateManyMutationInput, materia_primaUncheckedUpdateManyInput>
    /**
     * Filter which materia_primas to update
     */
    where?: materia_primaWhereInput
  }

  /**
   * materia_prima upsert
   */
  export type materia_primaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    /**
     * The filter to search for the materia_prima to update in case it exists.
     */
    where: materia_primaWhereUniqueInput
    /**
     * In case the materia_prima found by the `where` argument doesn't exist, create a new materia_prima with this data.
     */
    create: XOR<materia_primaCreateInput, materia_primaUncheckedCreateInput>
    /**
     * In case the materia_prima was found with the provided `where` argument, update it with this data.
     */
    update: XOR<materia_primaUpdateInput, materia_primaUncheckedUpdateInput>
  }

  /**
   * materia_prima delete
   */
  export type materia_primaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    /**
     * Filter which materia_prima to delete.
     */
    where: materia_primaWhereUniqueInput
  }

  /**
   * materia_prima deleteMany
   */
  export type materia_primaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which materia_primas to delete
     */
    where?: materia_primaWhereInput
  }

  /**
   * materia_prima.detalle_factura
   */
  export type materia_prima$detalle_facturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    where?: detalle_facturaWhereInput
    orderBy?: detalle_facturaOrderByWithRelationInput | detalle_facturaOrderByWithRelationInput[]
    cursor?: detalle_facturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detalle_facturaScalarFieldEnum | Detalle_facturaScalarFieldEnum[]
  }

  /**
   * materia_prima.kardex_materia_prima
   */
  export type materia_prima$kardex_materia_primaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_materia_prima
     */
    select?: kardex_materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_materia_primaInclude<ExtArgs> | null
    where?: kardex_materia_primaWhereInput
    orderBy?: kardex_materia_primaOrderByWithRelationInput | kardex_materia_primaOrderByWithRelationInput[]
    cursor?: kardex_materia_primaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Kardex_materia_primaScalarFieldEnum | Kardex_materia_primaScalarFieldEnum[]
  }

  /**
   * materia_prima.recetas
   */
  export type materia_prima$recetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    where?: recetasWhereInput
    orderBy?: recetasOrderByWithRelationInput | recetasOrderByWithRelationInput[]
    cursor?: recetasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetasScalarFieldEnum | RecetasScalarFieldEnum[]
  }

  /**
   * materia_prima without action
   */
  export type materia_primaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
  }


  /**
   * Model monedas
   */

  export type AggregateMonedas = {
    _count: MonedasCountAggregateOutputType | null
    _avg: MonedasAvgAggregateOutputType | null
    _sum: MonedasSumAggregateOutputType | null
    _min: MonedasMinAggregateOutputType | null
    _max: MonedasMaxAggregateOutputType | null
  }

  export type MonedasAvgAggregateOutputType = {
    id_moneda: number | null
    tasa_cambio: Decimal | null
  }

  export type MonedasSumAggregateOutputType = {
    id_moneda: number | null
    tasa_cambio: Decimal | null
  }

  export type MonedasMinAggregateOutputType = {
    id_moneda: number | null
    nombre: string | null
    tasa_cambio: Decimal | null
  }

  export type MonedasMaxAggregateOutputType = {
    id_moneda: number | null
    nombre: string | null
    tasa_cambio: Decimal | null
  }

  export type MonedasCountAggregateOutputType = {
    id_moneda: number
    nombre: number
    tasa_cambio: number
    _all: number
  }


  export type MonedasAvgAggregateInputType = {
    id_moneda?: true
    tasa_cambio?: true
  }

  export type MonedasSumAggregateInputType = {
    id_moneda?: true
    tasa_cambio?: true
  }

  export type MonedasMinAggregateInputType = {
    id_moneda?: true
    nombre?: true
    tasa_cambio?: true
  }

  export type MonedasMaxAggregateInputType = {
    id_moneda?: true
    nombre?: true
    tasa_cambio?: true
  }

  export type MonedasCountAggregateInputType = {
    id_moneda?: true
    nombre?: true
    tasa_cambio?: true
    _all?: true
  }

  export type MonedasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monedas to aggregate.
     */
    where?: monedasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monedas to fetch.
     */
    orderBy?: monedasOrderByWithRelationInput | monedasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monedasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monedas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monedas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monedas
    **/
    _count?: true | MonedasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonedasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonedasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonedasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonedasMaxAggregateInputType
  }

  export type GetMonedasAggregateType<T extends MonedasAggregateArgs> = {
        [P in keyof T & keyof AggregateMonedas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonedas[P]>
      : GetScalarType<T[P], AggregateMonedas[P]>
  }




  export type monedasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monedasWhereInput
    orderBy?: monedasOrderByWithAggregationInput | monedasOrderByWithAggregationInput[]
    by: MonedasScalarFieldEnum[] | MonedasScalarFieldEnum
    having?: monedasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonedasCountAggregateInputType | true
    _avg?: MonedasAvgAggregateInputType
    _sum?: MonedasSumAggregateInputType
    _min?: MonedasMinAggregateInputType
    _max?: MonedasMaxAggregateInputType
  }

  export type MonedasGroupByOutputType = {
    id_moneda: number
    nombre: string
    tasa_cambio: Decimal
    _count: MonedasCountAggregateOutputType | null
    _avg: MonedasAvgAggregateOutputType | null
    _sum: MonedasSumAggregateOutputType | null
    _min: MonedasMinAggregateOutputType | null
    _max: MonedasMaxAggregateOutputType | null
  }

  type GetMonedasGroupByPayload<T extends monedasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonedasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonedasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonedasGroupByOutputType[P]>
            : GetScalarType<T[P], MonedasGroupByOutputType[P]>
        }
      >
    >


  export type monedasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_moneda?: boolean
    nombre?: boolean
    tasa_cambio?: boolean
    facturas?: boolean | monedas$facturasArgs<ExtArgs>
    productos_terminados?: boolean | monedas$productos_terminadosArgs<ExtArgs>
    _count?: boolean | MonedasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monedas"]>

  export type monedasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_moneda?: boolean
    nombre?: boolean
    tasa_cambio?: boolean
  }, ExtArgs["result"]["monedas"]>

  export type monedasSelectScalar = {
    id_moneda?: boolean
    nombre?: boolean
    tasa_cambio?: boolean
  }

  export type monedasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facturas?: boolean | monedas$facturasArgs<ExtArgs>
    productos_terminados?: boolean | monedas$productos_terminadosArgs<ExtArgs>
    _count?: boolean | MonedasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type monedasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $monedasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monedas"
    objects: {
      facturas: Prisma.$facturasPayload<ExtArgs>[]
      productos_terminados: Prisma.$productos_terminadosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_moneda: number
      nombre: string
      tasa_cambio: Prisma.Decimal
    }, ExtArgs["result"]["monedas"]>
    composites: {}
  }

  type monedasGetPayload<S extends boolean | null | undefined | monedasDefaultArgs> = $Result.GetResult<Prisma.$monedasPayload, S>

  type monedasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monedasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonedasCountAggregateInputType | true
    }

  export interface monedasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monedas'], meta: { name: 'monedas' } }
    /**
     * Find zero or one Monedas that matches the filter.
     * @param {monedasFindUniqueArgs} args - Arguments to find a Monedas
     * @example
     * // Get one Monedas
     * const monedas = await prisma.monedas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monedasFindUniqueArgs>(args: SelectSubset<T, monedasFindUniqueArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monedas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monedasFindUniqueOrThrowArgs} args - Arguments to find a Monedas
     * @example
     * // Get one Monedas
     * const monedas = await prisma.monedas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monedasFindUniqueOrThrowArgs>(args: SelectSubset<T, monedasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monedas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasFindFirstArgs} args - Arguments to find a Monedas
     * @example
     * // Get one Monedas
     * const monedas = await prisma.monedas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monedasFindFirstArgs>(args?: SelectSubset<T, monedasFindFirstArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monedas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasFindFirstOrThrowArgs} args - Arguments to find a Monedas
     * @example
     * // Get one Monedas
     * const monedas = await prisma.monedas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monedasFindFirstOrThrowArgs>(args?: SelectSubset<T, monedasFindFirstOrThrowArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monedas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monedas
     * const monedas = await prisma.monedas.findMany()
     * 
     * // Get first 10 Monedas
     * const monedas = await prisma.monedas.findMany({ take: 10 })
     * 
     * // Only select the `id_moneda`
     * const monedasWithId_monedaOnly = await prisma.monedas.findMany({ select: { id_moneda: true } })
     * 
     */
    findMany<T extends monedasFindManyArgs>(args?: SelectSubset<T, monedasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monedas.
     * @param {monedasCreateArgs} args - Arguments to create a Monedas.
     * @example
     * // Create one Monedas
     * const Monedas = await prisma.monedas.create({
     *   data: {
     *     // ... data to create a Monedas
     *   }
     * })
     * 
     */
    create<T extends monedasCreateArgs>(args: SelectSubset<T, monedasCreateArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monedas.
     * @param {monedasCreateManyArgs} args - Arguments to create many Monedas.
     * @example
     * // Create many Monedas
     * const monedas = await prisma.monedas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monedasCreateManyArgs>(args?: SelectSubset<T, monedasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Monedas and returns the data saved in the database.
     * @param {monedasCreateManyAndReturnArgs} args - Arguments to create many Monedas.
     * @example
     * // Create many Monedas
     * const monedas = await prisma.monedas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Monedas and only return the `id_moneda`
     * const monedasWithId_monedaOnly = await prisma.monedas.createManyAndReturn({ 
     *   select: { id_moneda: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends monedasCreateManyAndReturnArgs>(args?: SelectSubset<T, monedasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Monedas.
     * @param {monedasDeleteArgs} args - Arguments to delete one Monedas.
     * @example
     * // Delete one Monedas
     * const Monedas = await prisma.monedas.delete({
     *   where: {
     *     // ... filter to delete one Monedas
     *   }
     * })
     * 
     */
    delete<T extends monedasDeleteArgs>(args: SelectSubset<T, monedasDeleteArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monedas.
     * @param {monedasUpdateArgs} args - Arguments to update one Monedas.
     * @example
     * // Update one Monedas
     * const monedas = await prisma.monedas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monedasUpdateArgs>(args: SelectSubset<T, monedasUpdateArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monedas.
     * @param {monedasDeleteManyArgs} args - Arguments to filter Monedas to delete.
     * @example
     * // Delete a few Monedas
     * const { count } = await prisma.monedas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monedasDeleteManyArgs>(args?: SelectSubset<T, monedasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monedas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monedas
     * const monedas = await prisma.monedas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monedasUpdateManyArgs>(args: SelectSubset<T, monedasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monedas.
     * @param {monedasUpsertArgs} args - Arguments to update or create a Monedas.
     * @example
     * // Update or create a Monedas
     * const monedas = await prisma.monedas.upsert({
     *   create: {
     *     // ... data to create a Monedas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monedas we want to update
     *   }
     * })
     */
    upsert<T extends monedasUpsertArgs>(args: SelectSubset<T, monedasUpsertArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monedas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasCountArgs} args - Arguments to filter Monedas to count.
     * @example
     * // Count the number of Monedas
     * const count = await prisma.monedas.count({
     *   where: {
     *     // ... the filter for the Monedas we want to count
     *   }
     * })
    **/
    count<T extends monedasCountArgs>(
      args?: Subset<T, monedasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonedasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monedas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonedasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonedasAggregateArgs>(args: Subset<T, MonedasAggregateArgs>): Prisma.PrismaPromise<GetMonedasAggregateType<T>>

    /**
     * Group by Monedas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monedasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monedasGroupByArgs['orderBy'] }
        : { orderBy?: monedasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monedasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonedasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monedas model
   */
  readonly fields: monedasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monedas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monedasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facturas<T extends monedas$facturasArgs<ExtArgs> = {}>(args?: Subset<T, monedas$facturasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findMany"> | Null>
    productos_terminados<T extends monedas$productos_terminadosArgs<ExtArgs> = {}>(args?: Subset<T, monedas$productos_terminadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monedas model
   */ 
  interface monedasFieldRefs {
    readonly id_moneda: FieldRef<"monedas", 'Int'>
    readonly nombre: FieldRef<"monedas", 'String'>
    readonly tasa_cambio: FieldRef<"monedas", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * monedas findUnique
   */
  export type monedasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter, which monedas to fetch.
     */
    where: monedasWhereUniqueInput
  }

  /**
   * monedas findUniqueOrThrow
   */
  export type monedasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter, which monedas to fetch.
     */
    where: monedasWhereUniqueInput
  }

  /**
   * monedas findFirst
   */
  export type monedasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter, which monedas to fetch.
     */
    where?: monedasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monedas to fetch.
     */
    orderBy?: monedasOrderByWithRelationInput | monedasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monedas.
     */
    cursor?: monedasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monedas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monedas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monedas.
     */
    distinct?: MonedasScalarFieldEnum | MonedasScalarFieldEnum[]
  }

  /**
   * monedas findFirstOrThrow
   */
  export type monedasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter, which monedas to fetch.
     */
    where?: monedasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monedas to fetch.
     */
    orderBy?: monedasOrderByWithRelationInput | monedasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monedas.
     */
    cursor?: monedasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monedas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monedas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monedas.
     */
    distinct?: MonedasScalarFieldEnum | MonedasScalarFieldEnum[]
  }

  /**
   * monedas findMany
   */
  export type monedasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter, which monedas to fetch.
     */
    where?: monedasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monedas to fetch.
     */
    orderBy?: monedasOrderByWithRelationInput | monedasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monedas.
     */
    cursor?: monedasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monedas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monedas.
     */
    skip?: number
    distinct?: MonedasScalarFieldEnum | MonedasScalarFieldEnum[]
  }

  /**
   * monedas create
   */
  export type monedasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * The data needed to create a monedas.
     */
    data: XOR<monedasCreateInput, monedasUncheckedCreateInput>
  }

  /**
   * monedas createMany
   */
  export type monedasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monedas.
     */
    data: monedasCreateManyInput | monedasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monedas createManyAndReturn
   */
  export type monedasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many monedas.
     */
    data: monedasCreateManyInput | monedasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monedas update
   */
  export type monedasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * The data needed to update a monedas.
     */
    data: XOR<monedasUpdateInput, monedasUncheckedUpdateInput>
    /**
     * Choose, which monedas to update.
     */
    where: monedasWhereUniqueInput
  }

  /**
   * monedas updateMany
   */
  export type monedasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monedas.
     */
    data: XOR<monedasUpdateManyMutationInput, monedasUncheckedUpdateManyInput>
    /**
     * Filter which monedas to update
     */
    where?: monedasWhereInput
  }

  /**
   * monedas upsert
   */
  export type monedasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * The filter to search for the monedas to update in case it exists.
     */
    where: monedasWhereUniqueInput
    /**
     * In case the monedas found by the `where` argument doesn't exist, create a new monedas with this data.
     */
    create: XOR<monedasCreateInput, monedasUncheckedCreateInput>
    /**
     * In case the monedas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monedasUpdateInput, monedasUncheckedUpdateInput>
  }

  /**
   * monedas delete
   */
  export type monedasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter which monedas to delete.
     */
    where: monedasWhereUniqueInput
  }

  /**
   * monedas deleteMany
   */
  export type monedasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monedas to delete
     */
    where?: monedasWhereInput
  }

  /**
   * monedas.facturas
   */
  export type monedas$facturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    where?: facturasWhereInput
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    cursor?: facturasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacturasScalarFieldEnum | FacturasScalarFieldEnum[]
  }

  /**
   * monedas.productos_terminados
   */
  export type monedas$productos_terminadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    where?: productos_terminadosWhereInput
    orderBy?: productos_terminadosOrderByWithRelationInput | productos_terminadosOrderByWithRelationInput[]
    cursor?: productos_terminadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Productos_terminadosScalarFieldEnum | Productos_terminadosScalarFieldEnum[]
  }

  /**
   * monedas without action
   */
  export type monedasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
  }


  /**
   * Model productos_terminados
   */

  export type AggregateProductos_terminados = {
    _count: Productos_terminadosCountAggregateOutputType | null
    _avg: Productos_terminadosAvgAggregateOutputType | null
    _sum: Productos_terminadosSumAggregateOutputType | null
    _min: Productos_terminadosMinAggregateOutputType | null
    _max: Productos_terminadosMaxAggregateOutputType | null
  }

  export type Productos_terminadosAvgAggregateOutputType = {
    id_producto: number | null
    precio_venta: Decimal | null
    stock_actual: Decimal | null
    precio_produccion: Decimal | null
    id_moneda: number | null
    id_producto_especial: number | null
  }

  export type Productos_terminadosSumAggregateOutputType = {
    id_producto: number | null
    precio_venta: Decimal | null
    stock_actual: Decimal | null
    precio_produccion: Decimal | null
    id_moneda: number | null
    id_producto_especial: number | null
  }

  export type Productos_terminadosMinAggregateOutputType = {
    id_producto: number | null
    nombre: string | null
    precio_venta: Decimal | null
    stock_actual: Decimal | null
    codigo_barras: string | null
    precio_produccion: Decimal | null
    id_moneda: number | null
    id_producto_especial: number | null
  }

  export type Productos_terminadosMaxAggregateOutputType = {
    id_producto: number | null
    nombre: string | null
    precio_venta: Decimal | null
    stock_actual: Decimal | null
    codigo_barras: string | null
    precio_produccion: Decimal | null
    id_moneda: number | null
    id_producto_especial: number | null
  }

  export type Productos_terminadosCountAggregateOutputType = {
    id_producto: number
    nombre: number
    precio_venta: number
    stock_actual: number
    codigo_barras: number
    precio_produccion: number
    id_moneda: number
    id_producto_especial: number
    _all: number
  }


  export type Productos_terminadosAvgAggregateInputType = {
    id_producto?: true
    precio_venta?: true
    stock_actual?: true
    precio_produccion?: true
    id_moneda?: true
    id_producto_especial?: true
  }

  export type Productos_terminadosSumAggregateInputType = {
    id_producto?: true
    precio_venta?: true
    stock_actual?: true
    precio_produccion?: true
    id_moneda?: true
    id_producto_especial?: true
  }

  export type Productos_terminadosMinAggregateInputType = {
    id_producto?: true
    nombre?: true
    precio_venta?: true
    stock_actual?: true
    codigo_barras?: true
    precio_produccion?: true
    id_moneda?: true
    id_producto_especial?: true
  }

  export type Productos_terminadosMaxAggregateInputType = {
    id_producto?: true
    nombre?: true
    precio_venta?: true
    stock_actual?: true
    codigo_barras?: true
    precio_produccion?: true
    id_moneda?: true
    id_producto_especial?: true
  }

  export type Productos_terminadosCountAggregateInputType = {
    id_producto?: true
    nombre?: true
    precio_venta?: true
    stock_actual?: true
    codigo_barras?: true
    precio_produccion?: true
    id_moneda?: true
    id_producto_especial?: true
    _all?: true
  }

  export type Productos_terminadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productos_terminados to aggregate.
     */
    where?: productos_terminadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos_terminados to fetch.
     */
    orderBy?: productos_terminadosOrderByWithRelationInput | productos_terminadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productos_terminadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos_terminados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos_terminados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned productos_terminados
    **/
    _count?: true | Productos_terminadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Productos_terminadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Productos_terminadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Productos_terminadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Productos_terminadosMaxAggregateInputType
  }

  export type GetProductos_terminadosAggregateType<T extends Productos_terminadosAggregateArgs> = {
        [P in keyof T & keyof AggregateProductos_terminados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductos_terminados[P]>
      : GetScalarType<T[P], AggregateProductos_terminados[P]>
  }




  export type productos_terminadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productos_terminadosWhereInput
    orderBy?: productos_terminadosOrderByWithAggregationInput | productos_terminadosOrderByWithAggregationInput[]
    by: Productos_terminadosScalarFieldEnum[] | Productos_terminadosScalarFieldEnum
    having?: productos_terminadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Productos_terminadosCountAggregateInputType | true
    _avg?: Productos_terminadosAvgAggregateInputType
    _sum?: Productos_terminadosSumAggregateInputType
    _min?: Productos_terminadosMinAggregateInputType
    _max?: Productos_terminadosMaxAggregateInputType
  }

  export type Productos_terminadosGroupByOutputType = {
    id_producto: number
    nombre: string
    precio_venta: Decimal
    stock_actual: Decimal | null
    codigo_barras: string
    precio_produccion: Decimal
    id_moneda: number
    id_producto_especial: number | null
    _count: Productos_terminadosCountAggregateOutputType | null
    _avg: Productos_terminadosAvgAggregateOutputType | null
    _sum: Productos_terminadosSumAggregateOutputType | null
    _min: Productos_terminadosMinAggregateOutputType | null
    _max: Productos_terminadosMaxAggregateOutputType | null
  }

  type GetProductos_terminadosGroupByPayload<T extends productos_terminadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Productos_terminadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Productos_terminadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Productos_terminadosGroupByOutputType[P]>
            : GetScalarType<T[P], Productos_terminadosGroupByOutputType[P]>
        }
      >
    >


  export type productos_terminadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_producto?: boolean
    nombre?: boolean
    precio_venta?: boolean
    stock_actual?: boolean
    codigo_barras?: boolean
    precio_produccion?: boolean
    id_moneda?: boolean
    id_producto_especial?: boolean
    kardex_productos?: boolean | productos_terminados$kardex_productosArgs<ExtArgs>
    monedas?: boolean | monedasDefaultArgs<ExtArgs>
    recetas?: boolean | productos_terminados$recetasArgs<ExtArgs>
    producto_especial?: boolean | productos_terminados$producto_especialArgs<ExtArgs>
    _count?: boolean | Productos_terminadosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productos_terminados"]>

  export type productos_terminadosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_producto?: boolean
    nombre?: boolean
    precio_venta?: boolean
    stock_actual?: boolean
    codigo_barras?: boolean
    precio_produccion?: boolean
    id_moneda?: boolean
    id_producto_especial?: boolean
    monedas?: boolean | monedasDefaultArgs<ExtArgs>
    producto_especial?: boolean | productos_terminados$producto_especialArgs<ExtArgs>
  }, ExtArgs["result"]["productos_terminados"]>

  export type productos_terminadosSelectScalar = {
    id_producto?: boolean
    nombre?: boolean
    precio_venta?: boolean
    stock_actual?: boolean
    codigo_barras?: boolean
    precio_produccion?: boolean
    id_moneda?: boolean
    id_producto_especial?: boolean
  }

  export type productos_terminadosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kardex_productos?: boolean | productos_terminados$kardex_productosArgs<ExtArgs>
    monedas?: boolean | monedasDefaultArgs<ExtArgs>
    recetas?: boolean | productos_terminados$recetasArgs<ExtArgs>
    producto_especial?: boolean | productos_terminados$producto_especialArgs<ExtArgs>
    _count?: boolean | Productos_terminadosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productos_terminadosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monedas?: boolean | monedasDefaultArgs<ExtArgs>
    producto_especial?: boolean | productos_terminados$producto_especialArgs<ExtArgs>
  }

  export type $productos_terminadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "productos_terminados"
    objects: {
      kardex_productos: Prisma.$kardex_productosPayload<ExtArgs>[]
      monedas: Prisma.$monedasPayload<ExtArgs>
      recetas: Prisma.$recetasPayload<ExtArgs>[]
      producto_especial: Prisma.$productos_especialesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_producto: number
      nombre: string
      precio_venta: Prisma.Decimal
      stock_actual: Prisma.Decimal | null
      codigo_barras: string
      precio_produccion: Prisma.Decimal
      id_moneda: number
      id_producto_especial: number | null
    }, ExtArgs["result"]["productos_terminados"]>
    composites: {}
  }

  type productos_terminadosGetPayload<S extends boolean | null | undefined | productos_terminadosDefaultArgs> = $Result.GetResult<Prisma.$productos_terminadosPayload, S>

  type productos_terminadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productos_terminadosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Productos_terminadosCountAggregateInputType | true
    }

  export interface productos_terminadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['productos_terminados'], meta: { name: 'productos_terminados' } }
    /**
     * Find zero or one Productos_terminados that matches the filter.
     * @param {productos_terminadosFindUniqueArgs} args - Arguments to find a Productos_terminados
     * @example
     * // Get one Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productos_terminadosFindUniqueArgs>(args: SelectSubset<T, productos_terminadosFindUniqueArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Productos_terminados that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {productos_terminadosFindUniqueOrThrowArgs} args - Arguments to find a Productos_terminados
     * @example
     * // Get one Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productos_terminadosFindUniqueOrThrowArgs>(args: SelectSubset<T, productos_terminadosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Productos_terminados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_terminadosFindFirstArgs} args - Arguments to find a Productos_terminados
     * @example
     * // Get one Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productos_terminadosFindFirstArgs>(args?: SelectSubset<T, productos_terminadosFindFirstArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Productos_terminados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_terminadosFindFirstOrThrowArgs} args - Arguments to find a Productos_terminados
     * @example
     * // Get one Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productos_terminadosFindFirstOrThrowArgs>(args?: SelectSubset<T, productos_terminadosFindFirstOrThrowArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Productos_terminados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_terminadosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.findMany()
     * 
     * // Get first 10 Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.findMany({ take: 10 })
     * 
     * // Only select the `id_producto`
     * const productos_terminadosWithId_productoOnly = await prisma.productos_terminados.findMany({ select: { id_producto: true } })
     * 
     */
    findMany<T extends productos_terminadosFindManyArgs>(args?: SelectSubset<T, productos_terminadosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Productos_terminados.
     * @param {productos_terminadosCreateArgs} args - Arguments to create a Productos_terminados.
     * @example
     * // Create one Productos_terminados
     * const Productos_terminados = await prisma.productos_terminados.create({
     *   data: {
     *     // ... data to create a Productos_terminados
     *   }
     * })
     * 
     */
    create<T extends productos_terminadosCreateArgs>(args: SelectSubset<T, productos_terminadosCreateArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Productos_terminados.
     * @param {productos_terminadosCreateManyArgs} args - Arguments to create many Productos_terminados.
     * @example
     * // Create many Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productos_terminadosCreateManyArgs>(args?: SelectSubset<T, productos_terminadosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Productos_terminados and returns the data saved in the database.
     * @param {productos_terminadosCreateManyAndReturnArgs} args - Arguments to create many Productos_terminados.
     * @example
     * // Create many Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Productos_terminados and only return the `id_producto`
     * const productos_terminadosWithId_productoOnly = await prisma.productos_terminados.createManyAndReturn({ 
     *   select: { id_producto: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productos_terminadosCreateManyAndReturnArgs>(args?: SelectSubset<T, productos_terminadosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Productos_terminados.
     * @param {productos_terminadosDeleteArgs} args - Arguments to delete one Productos_terminados.
     * @example
     * // Delete one Productos_terminados
     * const Productos_terminados = await prisma.productos_terminados.delete({
     *   where: {
     *     // ... filter to delete one Productos_terminados
     *   }
     * })
     * 
     */
    delete<T extends productos_terminadosDeleteArgs>(args: SelectSubset<T, productos_terminadosDeleteArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Productos_terminados.
     * @param {productos_terminadosUpdateArgs} args - Arguments to update one Productos_terminados.
     * @example
     * // Update one Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productos_terminadosUpdateArgs>(args: SelectSubset<T, productos_terminadosUpdateArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Productos_terminados.
     * @param {productos_terminadosDeleteManyArgs} args - Arguments to filter Productos_terminados to delete.
     * @example
     * // Delete a few Productos_terminados
     * const { count } = await prisma.productos_terminados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productos_terminadosDeleteManyArgs>(args?: SelectSubset<T, productos_terminadosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos_terminados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_terminadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productos_terminadosUpdateManyArgs>(args: SelectSubset<T, productos_terminadosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Productos_terminados.
     * @param {productos_terminadosUpsertArgs} args - Arguments to update or create a Productos_terminados.
     * @example
     * // Update or create a Productos_terminados
     * const productos_terminados = await prisma.productos_terminados.upsert({
     *   create: {
     *     // ... data to create a Productos_terminados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Productos_terminados we want to update
     *   }
     * })
     */
    upsert<T extends productos_terminadosUpsertArgs>(args: SelectSubset<T, productos_terminadosUpsertArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Productos_terminados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_terminadosCountArgs} args - Arguments to filter Productos_terminados to count.
     * @example
     * // Count the number of Productos_terminados
     * const count = await prisma.productos_terminados.count({
     *   where: {
     *     // ... the filter for the Productos_terminados we want to count
     *   }
     * })
    **/
    count<T extends productos_terminadosCountArgs>(
      args?: Subset<T, productos_terminadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Productos_terminadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Productos_terminados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Productos_terminadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Productos_terminadosAggregateArgs>(args: Subset<T, Productos_terminadosAggregateArgs>): Prisma.PrismaPromise<GetProductos_terminadosAggregateType<T>>

    /**
     * Group by Productos_terminados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_terminadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productos_terminadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productos_terminadosGroupByArgs['orderBy'] }
        : { orderBy?: productos_terminadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productos_terminadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductos_terminadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the productos_terminados model
   */
  readonly fields: productos_terminadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for productos_terminados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productos_terminadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kardex_productos<T extends productos_terminados$kardex_productosArgs<ExtArgs> = {}>(args?: Subset<T, productos_terminados$kardex_productosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kardex_productosPayload<ExtArgs>, T, "findMany"> | Null>
    monedas<T extends monedasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, monedasDefaultArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    recetas<T extends productos_terminados$recetasArgs<ExtArgs> = {}>(args?: Subset<T, productos_terminados$recetasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "findMany"> | Null>
    producto_especial<T extends productos_terminados$producto_especialArgs<ExtArgs> = {}>(args?: Subset<T, productos_terminados$producto_especialArgs<ExtArgs>>): Prisma__productos_especialesClient<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the productos_terminados model
   */ 
  interface productos_terminadosFieldRefs {
    readonly id_producto: FieldRef<"productos_terminados", 'Int'>
    readonly nombre: FieldRef<"productos_terminados", 'String'>
    readonly precio_venta: FieldRef<"productos_terminados", 'Decimal'>
    readonly stock_actual: FieldRef<"productos_terminados", 'Decimal'>
    readonly codigo_barras: FieldRef<"productos_terminados", 'String'>
    readonly precio_produccion: FieldRef<"productos_terminados", 'Decimal'>
    readonly id_moneda: FieldRef<"productos_terminados", 'Int'>
    readonly id_producto_especial: FieldRef<"productos_terminados", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * productos_terminados findUnique
   */
  export type productos_terminadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    /**
     * Filter, which productos_terminados to fetch.
     */
    where: productos_terminadosWhereUniqueInput
  }

  /**
   * productos_terminados findUniqueOrThrow
   */
  export type productos_terminadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    /**
     * Filter, which productos_terminados to fetch.
     */
    where: productos_terminadosWhereUniqueInput
  }

  /**
   * productos_terminados findFirst
   */
  export type productos_terminadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    /**
     * Filter, which productos_terminados to fetch.
     */
    where?: productos_terminadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos_terminados to fetch.
     */
    orderBy?: productos_terminadosOrderByWithRelationInput | productos_terminadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productos_terminados.
     */
    cursor?: productos_terminadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos_terminados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos_terminados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productos_terminados.
     */
    distinct?: Productos_terminadosScalarFieldEnum | Productos_terminadosScalarFieldEnum[]
  }

  /**
   * productos_terminados findFirstOrThrow
   */
  export type productos_terminadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    /**
     * Filter, which productos_terminados to fetch.
     */
    where?: productos_terminadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos_terminados to fetch.
     */
    orderBy?: productos_terminadosOrderByWithRelationInput | productos_terminadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productos_terminados.
     */
    cursor?: productos_terminadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos_terminados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos_terminados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productos_terminados.
     */
    distinct?: Productos_terminadosScalarFieldEnum | Productos_terminadosScalarFieldEnum[]
  }

  /**
   * productos_terminados findMany
   */
  export type productos_terminadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    /**
     * Filter, which productos_terminados to fetch.
     */
    where?: productos_terminadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos_terminados to fetch.
     */
    orderBy?: productos_terminadosOrderByWithRelationInput | productos_terminadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing productos_terminados.
     */
    cursor?: productos_terminadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos_terminados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos_terminados.
     */
    skip?: number
    distinct?: Productos_terminadosScalarFieldEnum | Productos_terminadosScalarFieldEnum[]
  }

  /**
   * productos_terminados create
   */
  export type productos_terminadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    /**
     * The data needed to create a productos_terminados.
     */
    data: XOR<productos_terminadosCreateInput, productos_terminadosUncheckedCreateInput>
  }

  /**
   * productos_terminados createMany
   */
  export type productos_terminadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many productos_terminados.
     */
    data: productos_terminadosCreateManyInput | productos_terminadosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * productos_terminados createManyAndReturn
   */
  export type productos_terminadosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many productos_terminados.
     */
    data: productos_terminadosCreateManyInput | productos_terminadosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * productos_terminados update
   */
  export type productos_terminadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    /**
     * The data needed to update a productos_terminados.
     */
    data: XOR<productos_terminadosUpdateInput, productos_terminadosUncheckedUpdateInput>
    /**
     * Choose, which productos_terminados to update.
     */
    where: productos_terminadosWhereUniqueInput
  }

  /**
   * productos_terminados updateMany
   */
  export type productos_terminadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update productos_terminados.
     */
    data: XOR<productos_terminadosUpdateManyMutationInput, productos_terminadosUncheckedUpdateManyInput>
    /**
     * Filter which productos_terminados to update
     */
    where?: productos_terminadosWhereInput
  }

  /**
   * productos_terminados upsert
   */
  export type productos_terminadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    /**
     * The filter to search for the productos_terminados to update in case it exists.
     */
    where: productos_terminadosWhereUniqueInput
    /**
     * In case the productos_terminados found by the `where` argument doesn't exist, create a new productos_terminados with this data.
     */
    create: XOR<productos_terminadosCreateInput, productos_terminadosUncheckedCreateInput>
    /**
     * In case the productos_terminados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productos_terminadosUpdateInput, productos_terminadosUncheckedUpdateInput>
  }

  /**
   * productos_terminados delete
   */
  export type productos_terminadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    /**
     * Filter which productos_terminados to delete.
     */
    where: productos_terminadosWhereUniqueInput
  }

  /**
   * productos_terminados deleteMany
   */
  export type productos_terminadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productos_terminados to delete
     */
    where?: productos_terminadosWhereInput
  }

  /**
   * productos_terminados.kardex_productos
   */
  export type productos_terminados$kardex_productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kardex_productos
     */
    select?: kardex_productosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kardex_productosInclude<ExtArgs> | null
    where?: kardex_productosWhereInput
    orderBy?: kardex_productosOrderByWithRelationInput | kardex_productosOrderByWithRelationInput[]
    cursor?: kardex_productosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Kardex_productosScalarFieldEnum | Kardex_productosScalarFieldEnum[]
  }

  /**
   * productos_terminados.recetas
   */
  export type productos_terminados$recetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    where?: recetasWhereInput
    orderBy?: recetasOrderByWithRelationInput | recetasOrderByWithRelationInput[]
    cursor?: recetasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetasScalarFieldEnum | RecetasScalarFieldEnum[]
  }

  /**
   * productos_terminados.producto_especial
   */
  export type productos_terminados$producto_especialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    where?: productos_especialesWhereInput
  }

  /**
   * productos_terminados without action
   */
  export type productos_terminadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
  }


  /**
   * Model productos_especiales
   */

  export type AggregateProductos_especiales = {
    _count: Productos_especialesCountAggregateOutputType | null
    _avg: Productos_especialesAvgAggregateOutputType | null
    _sum: Productos_especialesSumAggregateOutputType | null
    _min: Productos_especialesMinAggregateOutputType | null
    _max: Productos_especialesMaxAggregateOutputType | null
  }

  export type Productos_especialesAvgAggregateOutputType = {
    id_producto_especial: number | null
    id_producto: number | null
    rendimiento: Decimal | null
    unidad_rendimiento: number | null
  }

  export type Productos_especialesSumAggregateOutputType = {
    id_producto_especial: number | null
    id_producto: number | null
    rendimiento: Decimal | null
    unidad_rendimiento: number | null
  }

  export type Productos_especialesMinAggregateOutputType = {
    id_producto_especial: number | null
    id_producto: number | null
    rendimiento: Decimal | null
    unidad_rendimiento: number | null
  }

  export type Productos_especialesMaxAggregateOutputType = {
    id_producto_especial: number | null
    id_producto: number | null
    rendimiento: Decimal | null
    unidad_rendimiento: number | null
  }

  export type Productos_especialesCountAggregateOutputType = {
    id_producto_especial: number
    id_producto: number
    rendimiento: number
    unidad_rendimiento: number
    _all: number
  }


  export type Productos_especialesAvgAggregateInputType = {
    id_producto_especial?: true
    id_producto?: true
    rendimiento?: true
    unidad_rendimiento?: true
  }

  export type Productos_especialesSumAggregateInputType = {
    id_producto_especial?: true
    id_producto?: true
    rendimiento?: true
    unidad_rendimiento?: true
  }

  export type Productos_especialesMinAggregateInputType = {
    id_producto_especial?: true
    id_producto?: true
    rendimiento?: true
    unidad_rendimiento?: true
  }

  export type Productos_especialesMaxAggregateInputType = {
    id_producto_especial?: true
    id_producto?: true
    rendimiento?: true
    unidad_rendimiento?: true
  }

  export type Productos_especialesCountAggregateInputType = {
    id_producto_especial?: true
    id_producto?: true
    rendimiento?: true
    unidad_rendimiento?: true
    _all?: true
  }

  export type Productos_especialesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productos_especiales to aggregate.
     */
    where?: productos_especialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos_especiales to fetch.
     */
    orderBy?: productos_especialesOrderByWithRelationInput | productos_especialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productos_especialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos_especiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos_especiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned productos_especiales
    **/
    _count?: true | Productos_especialesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Productos_especialesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Productos_especialesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Productos_especialesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Productos_especialesMaxAggregateInputType
  }

  export type GetProductos_especialesAggregateType<T extends Productos_especialesAggregateArgs> = {
        [P in keyof T & keyof AggregateProductos_especiales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductos_especiales[P]>
      : GetScalarType<T[P], AggregateProductos_especiales[P]>
  }




  export type productos_especialesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productos_especialesWhereInput
    orderBy?: productos_especialesOrderByWithAggregationInput | productos_especialesOrderByWithAggregationInput[]
    by: Productos_especialesScalarFieldEnum[] | Productos_especialesScalarFieldEnum
    having?: productos_especialesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Productos_especialesCountAggregateInputType | true
    _avg?: Productos_especialesAvgAggregateInputType
    _sum?: Productos_especialesSumAggregateInputType
    _min?: Productos_especialesMinAggregateInputType
    _max?: Productos_especialesMaxAggregateInputType
  }

  export type Productos_especialesGroupByOutputType = {
    id_producto_especial: number
    id_producto: number
    rendimiento: Decimal
    unidad_rendimiento: number | null
    _count: Productos_especialesCountAggregateOutputType | null
    _avg: Productos_especialesAvgAggregateOutputType | null
    _sum: Productos_especialesSumAggregateOutputType | null
    _min: Productos_especialesMinAggregateOutputType | null
    _max: Productos_especialesMaxAggregateOutputType | null
  }

  type GetProductos_especialesGroupByPayload<T extends productos_especialesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Productos_especialesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Productos_especialesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Productos_especialesGroupByOutputType[P]>
            : GetScalarType<T[P], Productos_especialesGroupByOutputType[P]>
        }
      >
    >


  export type productos_especialesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_producto_especial?: boolean
    id_producto?: boolean
    rendimiento?: boolean
    unidad_rendimiento?: boolean
    producto_terminado?: boolean | productos_especiales$producto_terminadoArgs<ExtArgs>
    recetas?: boolean | productos_especiales$recetasArgs<ExtArgs>
    unidad?: boolean | productos_especiales$unidadArgs<ExtArgs>
    _count?: boolean | Productos_especialesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productos_especiales"]>

  export type productos_especialesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_producto_especial?: boolean
    id_producto?: boolean
    rendimiento?: boolean
    unidad_rendimiento?: boolean
    unidad?: boolean | productos_especiales$unidadArgs<ExtArgs>
  }, ExtArgs["result"]["productos_especiales"]>

  export type productos_especialesSelectScalar = {
    id_producto_especial?: boolean
    id_producto?: boolean
    rendimiento?: boolean
    unidad_rendimiento?: boolean
  }

  export type productos_especialesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto_terminado?: boolean | productos_especiales$producto_terminadoArgs<ExtArgs>
    recetas?: boolean | productos_especiales$recetasArgs<ExtArgs>
    unidad?: boolean | productos_especiales$unidadArgs<ExtArgs>
    _count?: boolean | Productos_especialesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productos_especialesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unidad?: boolean | productos_especiales$unidadArgs<ExtArgs>
  }

  export type $productos_especialesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "productos_especiales"
    objects: {
      producto_terminado: Prisma.$productos_terminadosPayload<ExtArgs> | null
      recetas: Prisma.$recetasPayload<ExtArgs>[]
      unidad: Prisma.$unidadesmedidaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_producto_especial: number
      id_producto: number
      rendimiento: Prisma.Decimal
      unidad_rendimiento: number | null
    }, ExtArgs["result"]["productos_especiales"]>
    composites: {}
  }

  type productos_especialesGetPayload<S extends boolean | null | undefined | productos_especialesDefaultArgs> = $Result.GetResult<Prisma.$productos_especialesPayload, S>

  type productos_especialesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productos_especialesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Productos_especialesCountAggregateInputType | true
    }

  export interface productos_especialesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['productos_especiales'], meta: { name: 'productos_especiales' } }
    /**
     * Find zero or one Productos_especiales that matches the filter.
     * @param {productos_especialesFindUniqueArgs} args - Arguments to find a Productos_especiales
     * @example
     * // Get one Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productos_especialesFindUniqueArgs>(args: SelectSubset<T, productos_especialesFindUniqueArgs<ExtArgs>>): Prisma__productos_especialesClient<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Productos_especiales that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {productos_especialesFindUniqueOrThrowArgs} args - Arguments to find a Productos_especiales
     * @example
     * // Get one Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productos_especialesFindUniqueOrThrowArgs>(args: SelectSubset<T, productos_especialesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productos_especialesClient<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Productos_especiales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_especialesFindFirstArgs} args - Arguments to find a Productos_especiales
     * @example
     * // Get one Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productos_especialesFindFirstArgs>(args?: SelectSubset<T, productos_especialesFindFirstArgs<ExtArgs>>): Prisma__productos_especialesClient<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Productos_especiales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_especialesFindFirstOrThrowArgs} args - Arguments to find a Productos_especiales
     * @example
     * // Get one Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productos_especialesFindFirstOrThrowArgs>(args?: SelectSubset<T, productos_especialesFindFirstOrThrowArgs<ExtArgs>>): Prisma__productos_especialesClient<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Productos_especiales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_especialesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.findMany()
     * 
     * // Get first 10 Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.findMany({ take: 10 })
     * 
     * // Only select the `id_producto_especial`
     * const productos_especialesWithId_producto_especialOnly = await prisma.productos_especiales.findMany({ select: { id_producto_especial: true } })
     * 
     */
    findMany<T extends productos_especialesFindManyArgs>(args?: SelectSubset<T, productos_especialesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Productos_especiales.
     * @param {productos_especialesCreateArgs} args - Arguments to create a Productos_especiales.
     * @example
     * // Create one Productos_especiales
     * const Productos_especiales = await prisma.productos_especiales.create({
     *   data: {
     *     // ... data to create a Productos_especiales
     *   }
     * })
     * 
     */
    create<T extends productos_especialesCreateArgs>(args: SelectSubset<T, productos_especialesCreateArgs<ExtArgs>>): Prisma__productos_especialesClient<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Productos_especiales.
     * @param {productos_especialesCreateManyArgs} args - Arguments to create many Productos_especiales.
     * @example
     * // Create many Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productos_especialesCreateManyArgs>(args?: SelectSubset<T, productos_especialesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Productos_especiales and returns the data saved in the database.
     * @param {productos_especialesCreateManyAndReturnArgs} args - Arguments to create many Productos_especiales.
     * @example
     * // Create many Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Productos_especiales and only return the `id_producto_especial`
     * const productos_especialesWithId_producto_especialOnly = await prisma.productos_especiales.createManyAndReturn({ 
     *   select: { id_producto_especial: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productos_especialesCreateManyAndReturnArgs>(args?: SelectSubset<T, productos_especialesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Productos_especiales.
     * @param {productos_especialesDeleteArgs} args - Arguments to delete one Productos_especiales.
     * @example
     * // Delete one Productos_especiales
     * const Productos_especiales = await prisma.productos_especiales.delete({
     *   where: {
     *     // ... filter to delete one Productos_especiales
     *   }
     * })
     * 
     */
    delete<T extends productos_especialesDeleteArgs>(args: SelectSubset<T, productos_especialesDeleteArgs<ExtArgs>>): Prisma__productos_especialesClient<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Productos_especiales.
     * @param {productos_especialesUpdateArgs} args - Arguments to update one Productos_especiales.
     * @example
     * // Update one Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productos_especialesUpdateArgs>(args: SelectSubset<T, productos_especialesUpdateArgs<ExtArgs>>): Prisma__productos_especialesClient<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Productos_especiales.
     * @param {productos_especialesDeleteManyArgs} args - Arguments to filter Productos_especiales to delete.
     * @example
     * // Delete a few Productos_especiales
     * const { count } = await prisma.productos_especiales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productos_especialesDeleteManyArgs>(args?: SelectSubset<T, productos_especialesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos_especiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_especialesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productos_especialesUpdateManyArgs>(args: SelectSubset<T, productos_especialesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Productos_especiales.
     * @param {productos_especialesUpsertArgs} args - Arguments to update or create a Productos_especiales.
     * @example
     * // Update or create a Productos_especiales
     * const productos_especiales = await prisma.productos_especiales.upsert({
     *   create: {
     *     // ... data to create a Productos_especiales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Productos_especiales we want to update
     *   }
     * })
     */
    upsert<T extends productos_especialesUpsertArgs>(args: SelectSubset<T, productos_especialesUpsertArgs<ExtArgs>>): Prisma__productos_especialesClient<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Productos_especiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_especialesCountArgs} args - Arguments to filter Productos_especiales to count.
     * @example
     * // Count the number of Productos_especiales
     * const count = await prisma.productos_especiales.count({
     *   where: {
     *     // ... the filter for the Productos_especiales we want to count
     *   }
     * })
    **/
    count<T extends productos_especialesCountArgs>(
      args?: Subset<T, productos_especialesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Productos_especialesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Productos_especiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Productos_especialesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Productos_especialesAggregateArgs>(args: Subset<T, Productos_especialesAggregateArgs>): Prisma.PrismaPromise<GetProductos_especialesAggregateType<T>>

    /**
     * Group by Productos_especiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productos_especialesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productos_especialesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productos_especialesGroupByArgs['orderBy'] }
        : { orderBy?: productos_especialesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productos_especialesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductos_especialesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the productos_especiales model
   */
  readonly fields: productos_especialesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for productos_especiales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productos_especialesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto_terminado<T extends productos_especiales$producto_terminadoArgs<ExtArgs> = {}>(args?: Subset<T, productos_especiales$producto_terminadoArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    recetas<T extends productos_especiales$recetasArgs<ExtArgs> = {}>(args?: Subset<T, productos_especiales$recetasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "findMany"> | Null>
    unidad<T extends productos_especiales$unidadArgs<ExtArgs> = {}>(args?: Subset<T, productos_especiales$unidadArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the productos_especiales model
   */ 
  interface productos_especialesFieldRefs {
    readonly id_producto_especial: FieldRef<"productos_especiales", 'Int'>
    readonly id_producto: FieldRef<"productos_especiales", 'Int'>
    readonly rendimiento: FieldRef<"productos_especiales", 'Decimal'>
    readonly unidad_rendimiento: FieldRef<"productos_especiales", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * productos_especiales findUnique
   */
  export type productos_especialesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    /**
     * Filter, which productos_especiales to fetch.
     */
    where: productos_especialesWhereUniqueInput
  }

  /**
   * productos_especiales findUniqueOrThrow
   */
  export type productos_especialesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    /**
     * Filter, which productos_especiales to fetch.
     */
    where: productos_especialesWhereUniqueInput
  }

  /**
   * productos_especiales findFirst
   */
  export type productos_especialesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    /**
     * Filter, which productos_especiales to fetch.
     */
    where?: productos_especialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos_especiales to fetch.
     */
    orderBy?: productos_especialesOrderByWithRelationInput | productos_especialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productos_especiales.
     */
    cursor?: productos_especialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos_especiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos_especiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productos_especiales.
     */
    distinct?: Productos_especialesScalarFieldEnum | Productos_especialesScalarFieldEnum[]
  }

  /**
   * productos_especiales findFirstOrThrow
   */
  export type productos_especialesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    /**
     * Filter, which productos_especiales to fetch.
     */
    where?: productos_especialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos_especiales to fetch.
     */
    orderBy?: productos_especialesOrderByWithRelationInput | productos_especialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productos_especiales.
     */
    cursor?: productos_especialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos_especiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos_especiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productos_especiales.
     */
    distinct?: Productos_especialesScalarFieldEnum | Productos_especialesScalarFieldEnum[]
  }

  /**
   * productos_especiales findMany
   */
  export type productos_especialesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    /**
     * Filter, which productos_especiales to fetch.
     */
    where?: productos_especialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos_especiales to fetch.
     */
    orderBy?: productos_especialesOrderByWithRelationInput | productos_especialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing productos_especiales.
     */
    cursor?: productos_especialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos_especiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos_especiales.
     */
    skip?: number
    distinct?: Productos_especialesScalarFieldEnum | Productos_especialesScalarFieldEnum[]
  }

  /**
   * productos_especiales create
   */
  export type productos_especialesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    /**
     * The data needed to create a productos_especiales.
     */
    data: XOR<productos_especialesCreateInput, productos_especialesUncheckedCreateInput>
  }

  /**
   * productos_especiales createMany
   */
  export type productos_especialesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many productos_especiales.
     */
    data: productos_especialesCreateManyInput | productos_especialesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * productos_especiales createManyAndReturn
   */
  export type productos_especialesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many productos_especiales.
     */
    data: productos_especialesCreateManyInput | productos_especialesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * productos_especiales update
   */
  export type productos_especialesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    /**
     * The data needed to update a productos_especiales.
     */
    data: XOR<productos_especialesUpdateInput, productos_especialesUncheckedUpdateInput>
    /**
     * Choose, which productos_especiales to update.
     */
    where: productos_especialesWhereUniqueInput
  }

  /**
   * productos_especiales updateMany
   */
  export type productos_especialesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update productos_especiales.
     */
    data: XOR<productos_especialesUpdateManyMutationInput, productos_especialesUncheckedUpdateManyInput>
    /**
     * Filter which productos_especiales to update
     */
    where?: productos_especialesWhereInput
  }

  /**
   * productos_especiales upsert
   */
  export type productos_especialesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    /**
     * The filter to search for the productos_especiales to update in case it exists.
     */
    where: productos_especialesWhereUniqueInput
    /**
     * In case the productos_especiales found by the `where` argument doesn't exist, create a new productos_especiales with this data.
     */
    create: XOR<productos_especialesCreateInput, productos_especialesUncheckedCreateInput>
    /**
     * In case the productos_especiales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productos_especialesUpdateInput, productos_especialesUncheckedUpdateInput>
  }

  /**
   * productos_especiales delete
   */
  export type productos_especialesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    /**
     * Filter which productos_especiales to delete.
     */
    where: productos_especialesWhereUniqueInput
  }

  /**
   * productos_especiales deleteMany
   */
  export type productos_especialesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productos_especiales to delete
     */
    where?: productos_especialesWhereInput
  }

  /**
   * productos_especiales.producto_terminado
   */
  export type productos_especiales$producto_terminadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    where?: productos_terminadosWhereInput
  }

  /**
   * productos_especiales.recetas
   */
  export type productos_especiales$recetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    where?: recetasWhereInput
    orderBy?: recetasOrderByWithRelationInput | recetasOrderByWithRelationInput[]
    cursor?: recetasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetasScalarFieldEnum | RecetasScalarFieldEnum[]
  }

  /**
   * productos_especiales.unidad
   */
  export type productos_especiales$unidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    where?: unidadesmedidaWhereInput
  }

  /**
   * productos_especiales without action
   */
  export type productos_especialesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
  }


  /**
   * Model proveedores
   */

  export type AggregateProveedores = {
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  export type ProveedoresAvgAggregateOutputType = {
    id_proveedor: number | null
  }

  export type ProveedoresSumAggregateOutputType = {
    id_proveedor: number | null
  }

  export type ProveedoresMinAggregateOutputType = {
    id_proveedor: number | null
    rif: string | null
    nombre: string | null
    contacto: string | null
    telefono: string | null
    direccion: string | null
    empresa_nombre: string | null
    fecha_registro: Date | null
  }

  export type ProveedoresMaxAggregateOutputType = {
    id_proveedor: number | null
    rif: string | null
    nombre: string | null
    contacto: string | null
    telefono: string | null
    direccion: string | null
    empresa_nombre: string | null
    fecha_registro: Date | null
  }

  export type ProveedoresCountAggregateOutputType = {
    id_proveedor: number
    rif: number
    nombre: number
    contacto: number
    telefono: number
    direccion: number
    empresa_nombre: number
    fecha_registro: number
    _all: number
  }


  export type ProveedoresAvgAggregateInputType = {
    id_proveedor?: true
  }

  export type ProveedoresSumAggregateInputType = {
    id_proveedor?: true
  }

  export type ProveedoresMinAggregateInputType = {
    id_proveedor?: true
    rif?: true
    nombre?: true
    contacto?: true
    telefono?: true
    direccion?: true
    empresa_nombre?: true
    fecha_registro?: true
  }

  export type ProveedoresMaxAggregateInputType = {
    id_proveedor?: true
    rif?: true
    nombre?: true
    contacto?: true
    telefono?: true
    direccion?: true
    empresa_nombre?: true
    fecha_registro?: true
  }

  export type ProveedoresCountAggregateInputType = {
    id_proveedor?: true
    rif?: true
    nombre?: true
    contacto?: true
    telefono?: true
    direccion?: true
    empresa_nombre?: true
    fecha_registro?: true
    _all?: true
  }

  export type ProveedoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedores to aggregate.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proveedores
    **/
    _count?: true | ProveedoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedoresMaxAggregateInputType
  }

  export type GetProveedoresAggregateType<T extends ProveedoresAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedores[P]>
      : GetScalarType<T[P], AggregateProveedores[P]>
  }




  export type proveedoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proveedoresWhereInput
    orderBy?: proveedoresOrderByWithAggregationInput | proveedoresOrderByWithAggregationInput[]
    by: ProveedoresScalarFieldEnum[] | ProveedoresScalarFieldEnum
    having?: proveedoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedoresCountAggregateInputType | true
    _avg?: ProveedoresAvgAggregateInputType
    _sum?: ProveedoresSumAggregateInputType
    _min?: ProveedoresMinAggregateInputType
    _max?: ProveedoresMaxAggregateInputType
  }

  export type ProveedoresGroupByOutputType = {
    id_proveedor: number
    rif: string
    nombre: string
    contacto: string | null
    telefono: string | null
    direccion: string | null
    empresa_nombre: string
    fecha_registro: Date | null
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  type GetProveedoresGroupByPayload<T extends proveedoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProveedoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
        }
      >
    >


  export type proveedoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_proveedor?: boolean
    rif?: boolean
    nombre?: boolean
    contacto?: boolean
    telefono?: boolean
    direccion?: boolean
    empresa_nombre?: boolean
    fecha_registro?: boolean
    facturas?: boolean | proveedores$facturasArgs<ExtArgs>
    _count?: boolean | ProveedoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proveedores"]>

  export type proveedoresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_proveedor?: boolean
    rif?: boolean
    nombre?: boolean
    contacto?: boolean
    telefono?: boolean
    direccion?: boolean
    empresa_nombre?: boolean
    fecha_registro?: boolean
  }, ExtArgs["result"]["proveedores"]>

  export type proveedoresSelectScalar = {
    id_proveedor?: boolean
    rif?: boolean
    nombre?: boolean
    contacto?: boolean
    telefono?: boolean
    direccion?: boolean
    empresa_nombre?: boolean
    fecha_registro?: boolean
  }

  export type proveedoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facturas?: boolean | proveedores$facturasArgs<ExtArgs>
    _count?: boolean | ProveedoresCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type proveedoresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $proveedoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "proveedores"
    objects: {
      facturas: Prisma.$facturasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_proveedor: number
      rif: string
      nombre: string
      contacto: string | null
      telefono: string | null
      direccion: string | null
      empresa_nombre: string
      fecha_registro: Date | null
    }, ExtArgs["result"]["proveedores"]>
    composites: {}
  }

  type proveedoresGetPayload<S extends boolean | null | undefined | proveedoresDefaultArgs> = $Result.GetResult<Prisma.$proveedoresPayload, S>

  type proveedoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<proveedoresFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProveedoresCountAggregateInputType | true
    }

  export interface proveedoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['proveedores'], meta: { name: 'proveedores' } }
    /**
     * Find zero or one Proveedores that matches the filter.
     * @param {proveedoresFindUniqueArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends proveedoresFindUniqueArgs>(args: SelectSubset<T, proveedoresFindUniqueArgs<ExtArgs>>): Prisma__proveedoresClient<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Proveedores that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {proveedoresFindUniqueOrThrowArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends proveedoresFindUniqueOrThrowArgs>(args: SelectSubset<T, proveedoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__proveedoresClient<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindFirstArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends proveedoresFindFirstArgs>(args?: SelectSubset<T, proveedoresFindFirstArgs<ExtArgs>>): Prisma__proveedoresClient<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Proveedores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindFirstOrThrowArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends proveedoresFindFirstOrThrowArgs>(args?: SelectSubset<T, proveedoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__proveedoresClient<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedores
     * const proveedores = await prisma.proveedores.findMany()
     * 
     * // Get first 10 Proveedores
     * const proveedores = await prisma.proveedores.findMany({ take: 10 })
     * 
     * // Only select the `id_proveedor`
     * const proveedoresWithId_proveedorOnly = await prisma.proveedores.findMany({ select: { id_proveedor: true } })
     * 
     */
    findMany<T extends proveedoresFindManyArgs>(args?: SelectSubset<T, proveedoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Proveedores.
     * @param {proveedoresCreateArgs} args - Arguments to create a Proveedores.
     * @example
     * // Create one Proveedores
     * const Proveedores = await prisma.proveedores.create({
     *   data: {
     *     // ... data to create a Proveedores
     *   }
     * })
     * 
     */
    create<T extends proveedoresCreateArgs>(args: SelectSubset<T, proveedoresCreateArgs<ExtArgs>>): Prisma__proveedoresClient<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Proveedores.
     * @param {proveedoresCreateManyArgs} args - Arguments to create many Proveedores.
     * @example
     * // Create many Proveedores
     * const proveedores = await prisma.proveedores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends proveedoresCreateManyArgs>(args?: SelectSubset<T, proveedoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proveedores and returns the data saved in the database.
     * @param {proveedoresCreateManyAndReturnArgs} args - Arguments to create many Proveedores.
     * @example
     * // Create many Proveedores
     * const proveedores = await prisma.proveedores.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proveedores and only return the `id_proveedor`
     * const proveedoresWithId_proveedorOnly = await prisma.proveedores.createManyAndReturn({ 
     *   select: { id_proveedor: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends proveedoresCreateManyAndReturnArgs>(args?: SelectSubset<T, proveedoresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Proveedores.
     * @param {proveedoresDeleteArgs} args - Arguments to delete one Proveedores.
     * @example
     * // Delete one Proveedores
     * const Proveedores = await prisma.proveedores.delete({
     *   where: {
     *     // ... filter to delete one Proveedores
     *   }
     * })
     * 
     */
    delete<T extends proveedoresDeleteArgs>(args: SelectSubset<T, proveedoresDeleteArgs<ExtArgs>>): Prisma__proveedoresClient<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Proveedores.
     * @param {proveedoresUpdateArgs} args - Arguments to update one Proveedores.
     * @example
     * // Update one Proveedores
     * const proveedores = await prisma.proveedores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends proveedoresUpdateArgs>(args: SelectSubset<T, proveedoresUpdateArgs<ExtArgs>>): Prisma__proveedoresClient<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Proveedores.
     * @param {proveedoresDeleteManyArgs} args - Arguments to filter Proveedores to delete.
     * @example
     * // Delete a few Proveedores
     * const { count } = await prisma.proveedores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends proveedoresDeleteManyArgs>(args?: SelectSubset<T, proveedoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedores
     * const proveedores = await prisma.proveedores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends proveedoresUpdateManyArgs>(args: SelectSubset<T, proveedoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proveedores.
     * @param {proveedoresUpsertArgs} args - Arguments to update or create a Proveedores.
     * @example
     * // Update or create a Proveedores
     * const proveedores = await prisma.proveedores.upsert({
     *   create: {
     *     // ... data to create a Proveedores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedores we want to update
     *   }
     * })
     */
    upsert<T extends proveedoresUpsertArgs>(args: SelectSubset<T, proveedoresUpsertArgs<ExtArgs>>): Prisma__proveedoresClient<$Result.GetResult<Prisma.$proveedoresPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresCountArgs} args - Arguments to filter Proveedores to count.
     * @example
     * // Count the number of Proveedores
     * const count = await prisma.proveedores.count({
     *   where: {
     *     // ... the filter for the Proveedores we want to count
     *   }
     * })
    **/
    count<T extends proveedoresCountArgs>(
      args?: Subset<T, proveedoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedoresAggregateArgs>(args: Subset<T, ProveedoresAggregateArgs>): Prisma.PrismaPromise<GetProveedoresAggregateType<T>>

    /**
     * Group by Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends proveedoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: proveedoresGroupByArgs['orderBy'] }
        : { orderBy?: proveedoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, proveedoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the proveedores model
   */
  readonly fields: proveedoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for proveedores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__proveedoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facturas<T extends proveedores$facturasArgs<ExtArgs> = {}>(args?: Subset<T, proveedores$facturasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturasPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the proveedores model
   */ 
  interface proveedoresFieldRefs {
    readonly id_proveedor: FieldRef<"proveedores", 'Int'>
    readonly rif: FieldRef<"proveedores", 'String'>
    readonly nombre: FieldRef<"proveedores", 'String'>
    readonly contacto: FieldRef<"proveedores", 'String'>
    readonly telefono: FieldRef<"proveedores", 'String'>
    readonly direccion: FieldRef<"proveedores", 'String'>
    readonly empresa_nombre: FieldRef<"proveedores", 'String'>
    readonly fecha_registro: FieldRef<"proveedores", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * proveedores findUnique
   */
  export type proveedoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where: proveedoresWhereUniqueInput
  }

  /**
   * proveedores findUniqueOrThrow
   */
  export type proveedoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where: proveedoresWhereUniqueInput
  }

  /**
   * proveedores findFirst
   */
  export type proveedoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedores.
     */
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }

  /**
   * proveedores findFirstOrThrow
   */
  export type proveedoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedores.
     */
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }

  /**
   * proveedores findMany
   */
  export type proveedoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }

  /**
   * proveedores create
   */
  export type proveedoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
    /**
     * The data needed to create a proveedores.
     */
    data: XOR<proveedoresCreateInput, proveedoresUncheckedCreateInput>
  }

  /**
   * proveedores createMany
   */
  export type proveedoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many proveedores.
     */
    data: proveedoresCreateManyInput | proveedoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * proveedores createManyAndReturn
   */
  export type proveedoresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many proveedores.
     */
    data: proveedoresCreateManyInput | proveedoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * proveedores update
   */
  export type proveedoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
    /**
     * The data needed to update a proveedores.
     */
    data: XOR<proveedoresUpdateInput, proveedoresUncheckedUpdateInput>
    /**
     * Choose, which proveedores to update.
     */
    where: proveedoresWhereUniqueInput
  }

  /**
   * proveedores updateMany
   */
  export type proveedoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update proveedores.
     */
    data: XOR<proveedoresUpdateManyMutationInput, proveedoresUncheckedUpdateManyInput>
    /**
     * Filter which proveedores to update
     */
    where?: proveedoresWhereInput
  }

  /**
   * proveedores upsert
   */
  export type proveedoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
    /**
     * The filter to search for the proveedores to update in case it exists.
     */
    where: proveedoresWhereUniqueInput
    /**
     * In case the proveedores found by the `where` argument doesn't exist, create a new proveedores with this data.
     */
    create: XOR<proveedoresCreateInput, proveedoresUncheckedCreateInput>
    /**
     * In case the proveedores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proveedoresUpdateInput, proveedoresUncheckedUpdateInput>
  }

  /**
   * proveedores delete
   */
  export type proveedoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
    /**
     * Filter which proveedores to delete.
     */
    where: proveedoresWhereUniqueInput
  }

  /**
   * proveedores deleteMany
   */
  export type proveedoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedores to delete
     */
    where?: proveedoresWhereInput
  }

  /**
   * proveedores.facturas
   */
  export type proveedores$facturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the facturas
     */
    select?: facturasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturasInclude<ExtArgs> | null
    where?: facturasWhereInput
    orderBy?: facturasOrderByWithRelationInput | facturasOrderByWithRelationInput[]
    cursor?: facturasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacturasScalarFieldEnum | FacturasScalarFieldEnum[]
  }

  /**
   * proveedores without action
   */
  export type proveedoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proveedoresInclude<ExtArgs> | null
  }


  /**
   * Model recetas
   */

  export type AggregateRecetas = {
    _count: RecetasCountAggregateOutputType | null
    _avg: RecetasAvgAggregateOutputType | null
    _sum: RecetasSumAggregateOutputType | null
    _min: RecetasMinAggregateOutputType | null
    _max: RecetasMaxAggregateOutputType | null
  }

  export type RecetasAvgAggregateOutputType = {
    id_receta: number | null
    id_producto: number | null
    id_materia_prima: number | null
    id_producto_especial: number | null
    cantidad_requerida: Decimal | null
    unidad_medida: number | null
  }

  export type RecetasSumAggregateOutputType = {
    id_receta: number | null
    id_producto: number | null
    id_materia_prima: number | null
    id_producto_especial: number | null
    cantidad_requerida: Decimal | null
    unidad_medida: number | null
  }

  export type RecetasMinAggregateOutputType = {
    id_receta: number | null
    id_producto: number | null
    id_materia_prima: number | null
    id_producto_especial: number | null
    cantidad_requerida: Decimal | null
    unidad_medida: number | null
    disponible: boolean | null
  }

  export type RecetasMaxAggregateOutputType = {
    id_receta: number | null
    id_producto: number | null
    id_materia_prima: number | null
    id_producto_especial: number | null
    cantidad_requerida: Decimal | null
    unidad_medida: number | null
    disponible: boolean | null
  }

  export type RecetasCountAggregateOutputType = {
    id_receta: number
    id_producto: number
    id_materia_prima: number
    id_producto_especial: number
    cantidad_requerida: number
    unidad_medida: number
    disponible: number
    _all: number
  }


  export type RecetasAvgAggregateInputType = {
    id_receta?: true
    id_producto?: true
    id_materia_prima?: true
    id_producto_especial?: true
    cantidad_requerida?: true
    unidad_medida?: true
  }

  export type RecetasSumAggregateInputType = {
    id_receta?: true
    id_producto?: true
    id_materia_prima?: true
    id_producto_especial?: true
    cantidad_requerida?: true
    unidad_medida?: true
  }

  export type RecetasMinAggregateInputType = {
    id_receta?: true
    id_producto?: true
    id_materia_prima?: true
    id_producto_especial?: true
    cantidad_requerida?: true
    unidad_medida?: true
    disponible?: true
  }

  export type RecetasMaxAggregateInputType = {
    id_receta?: true
    id_producto?: true
    id_materia_prima?: true
    id_producto_especial?: true
    cantidad_requerida?: true
    unidad_medida?: true
    disponible?: true
  }

  export type RecetasCountAggregateInputType = {
    id_receta?: true
    id_producto?: true
    id_materia_prima?: true
    id_producto_especial?: true
    cantidad_requerida?: true
    unidad_medida?: true
    disponible?: true
    _all?: true
  }

  export type RecetasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recetas to aggregate.
     */
    where?: recetasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetas to fetch.
     */
    orderBy?: recetasOrderByWithRelationInput | recetasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recetasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recetas
    **/
    _count?: true | RecetasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecetasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecetasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecetasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecetasMaxAggregateInputType
  }

  export type GetRecetasAggregateType<T extends RecetasAggregateArgs> = {
        [P in keyof T & keyof AggregateRecetas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecetas[P]>
      : GetScalarType<T[P], AggregateRecetas[P]>
  }




  export type recetasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recetasWhereInput
    orderBy?: recetasOrderByWithAggregationInput | recetasOrderByWithAggregationInput[]
    by: RecetasScalarFieldEnum[] | RecetasScalarFieldEnum
    having?: recetasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecetasCountAggregateInputType | true
    _avg?: RecetasAvgAggregateInputType
    _sum?: RecetasSumAggregateInputType
    _min?: RecetasMinAggregateInputType
    _max?: RecetasMaxAggregateInputType
  }

  export type RecetasGroupByOutputType = {
    id_receta: number
    id_producto: number | null
    id_materia_prima: number | null
    id_producto_especial: number | null
    cantidad_requerida: Decimal
    unidad_medida: number | null
    disponible: boolean
    _count: RecetasCountAggregateOutputType | null
    _avg: RecetasAvgAggregateOutputType | null
    _sum: RecetasSumAggregateOutputType | null
    _min: RecetasMinAggregateOutputType | null
    _max: RecetasMaxAggregateOutputType | null
  }

  type GetRecetasGroupByPayload<T extends recetasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecetasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecetasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecetasGroupByOutputType[P]>
            : GetScalarType<T[P], RecetasGroupByOutputType[P]>
        }
      >
    >


  export type recetasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_receta?: boolean
    id_producto?: boolean
    id_materia_prima?: boolean
    id_producto_especial?: boolean
    cantidad_requerida?: boolean
    unidad_medida?: boolean
    disponible?: boolean
    unidadesmedida?: boolean | recetas$unidadesmedidaArgs<ExtArgs>
    materia_prima?: boolean | recetas$materia_primaArgs<ExtArgs>
    productos_terminados?: boolean | recetas$productos_terminadosArgs<ExtArgs>
    productos_especiales?: boolean | recetas$productos_especialesArgs<ExtArgs>
  }, ExtArgs["result"]["recetas"]>

  export type recetasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_receta?: boolean
    id_producto?: boolean
    id_materia_prima?: boolean
    id_producto_especial?: boolean
    cantidad_requerida?: boolean
    unidad_medida?: boolean
    disponible?: boolean
    unidadesmedida?: boolean | recetas$unidadesmedidaArgs<ExtArgs>
    materia_prima?: boolean | recetas$materia_primaArgs<ExtArgs>
    productos_terminados?: boolean | recetas$productos_terminadosArgs<ExtArgs>
    productos_especiales?: boolean | recetas$productos_especialesArgs<ExtArgs>
  }, ExtArgs["result"]["recetas"]>

  export type recetasSelectScalar = {
    id_receta?: boolean
    id_producto?: boolean
    id_materia_prima?: boolean
    id_producto_especial?: boolean
    cantidad_requerida?: boolean
    unidad_medida?: boolean
    disponible?: boolean
  }

  export type recetasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unidadesmedida?: boolean | recetas$unidadesmedidaArgs<ExtArgs>
    materia_prima?: boolean | recetas$materia_primaArgs<ExtArgs>
    productos_terminados?: boolean | recetas$productos_terminadosArgs<ExtArgs>
    productos_especiales?: boolean | recetas$productos_especialesArgs<ExtArgs>
  }
  export type recetasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unidadesmedida?: boolean | recetas$unidadesmedidaArgs<ExtArgs>
    materia_prima?: boolean | recetas$materia_primaArgs<ExtArgs>
    productos_terminados?: boolean | recetas$productos_terminadosArgs<ExtArgs>
    productos_especiales?: boolean | recetas$productos_especialesArgs<ExtArgs>
  }

  export type $recetasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recetas"
    objects: {
      unidadesmedida: Prisma.$unidadesmedidaPayload<ExtArgs> | null
      materia_prima: Prisma.$materia_primaPayload<ExtArgs> | null
      productos_terminados: Prisma.$productos_terminadosPayload<ExtArgs> | null
      productos_especiales: Prisma.$productos_especialesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_receta: number
      id_producto: number | null
      id_materia_prima: number | null
      id_producto_especial: number | null
      cantidad_requerida: Prisma.Decimal
      unidad_medida: number | null
      disponible: boolean
    }, ExtArgs["result"]["recetas"]>
    composites: {}
  }

  type recetasGetPayload<S extends boolean | null | undefined | recetasDefaultArgs> = $Result.GetResult<Prisma.$recetasPayload, S>

  type recetasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<recetasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecetasCountAggregateInputType | true
    }

  export interface recetasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recetas'], meta: { name: 'recetas' } }
    /**
     * Find zero or one Recetas that matches the filter.
     * @param {recetasFindUniqueArgs} args - Arguments to find a Recetas
     * @example
     * // Get one Recetas
     * const recetas = await prisma.recetas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recetasFindUniqueArgs>(args: SelectSubset<T, recetasFindUniqueArgs<ExtArgs>>): Prisma__recetasClient<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recetas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {recetasFindUniqueOrThrowArgs} args - Arguments to find a Recetas
     * @example
     * // Get one Recetas
     * const recetas = await prisma.recetas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recetasFindUniqueOrThrowArgs>(args: SelectSubset<T, recetasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recetasClient<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetasFindFirstArgs} args - Arguments to find a Recetas
     * @example
     * // Get one Recetas
     * const recetas = await prisma.recetas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recetasFindFirstArgs>(args?: SelectSubset<T, recetasFindFirstArgs<ExtArgs>>): Prisma__recetasClient<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recetas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetasFindFirstOrThrowArgs} args - Arguments to find a Recetas
     * @example
     * // Get one Recetas
     * const recetas = await prisma.recetas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recetasFindFirstOrThrowArgs>(args?: SelectSubset<T, recetasFindFirstOrThrowArgs<ExtArgs>>): Prisma__recetasClient<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recetas
     * const recetas = await prisma.recetas.findMany()
     * 
     * // Get first 10 Recetas
     * const recetas = await prisma.recetas.findMany({ take: 10 })
     * 
     * // Only select the `id_receta`
     * const recetasWithId_recetaOnly = await prisma.recetas.findMany({ select: { id_receta: true } })
     * 
     */
    findMany<T extends recetasFindManyArgs>(args?: SelectSubset<T, recetasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recetas.
     * @param {recetasCreateArgs} args - Arguments to create a Recetas.
     * @example
     * // Create one Recetas
     * const Recetas = await prisma.recetas.create({
     *   data: {
     *     // ... data to create a Recetas
     *   }
     * })
     * 
     */
    create<T extends recetasCreateArgs>(args: SelectSubset<T, recetasCreateArgs<ExtArgs>>): Prisma__recetasClient<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recetas.
     * @param {recetasCreateManyArgs} args - Arguments to create many Recetas.
     * @example
     * // Create many Recetas
     * const recetas = await prisma.recetas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recetasCreateManyArgs>(args?: SelectSubset<T, recetasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recetas and returns the data saved in the database.
     * @param {recetasCreateManyAndReturnArgs} args - Arguments to create many Recetas.
     * @example
     * // Create many Recetas
     * const recetas = await prisma.recetas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recetas and only return the `id_receta`
     * const recetasWithId_recetaOnly = await prisma.recetas.createManyAndReturn({ 
     *   select: { id_receta: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends recetasCreateManyAndReturnArgs>(args?: SelectSubset<T, recetasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Recetas.
     * @param {recetasDeleteArgs} args - Arguments to delete one Recetas.
     * @example
     * // Delete one Recetas
     * const Recetas = await prisma.recetas.delete({
     *   where: {
     *     // ... filter to delete one Recetas
     *   }
     * })
     * 
     */
    delete<T extends recetasDeleteArgs>(args: SelectSubset<T, recetasDeleteArgs<ExtArgs>>): Prisma__recetasClient<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recetas.
     * @param {recetasUpdateArgs} args - Arguments to update one Recetas.
     * @example
     * // Update one Recetas
     * const recetas = await prisma.recetas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recetasUpdateArgs>(args: SelectSubset<T, recetasUpdateArgs<ExtArgs>>): Prisma__recetasClient<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recetas.
     * @param {recetasDeleteManyArgs} args - Arguments to filter Recetas to delete.
     * @example
     * // Delete a few Recetas
     * const { count } = await prisma.recetas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recetasDeleteManyArgs>(args?: SelectSubset<T, recetasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recetas
     * const recetas = await prisma.recetas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recetasUpdateManyArgs>(args: SelectSubset<T, recetasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recetas.
     * @param {recetasUpsertArgs} args - Arguments to update or create a Recetas.
     * @example
     * // Update or create a Recetas
     * const recetas = await prisma.recetas.upsert({
     *   create: {
     *     // ... data to create a Recetas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recetas we want to update
     *   }
     * })
     */
    upsert<T extends recetasUpsertArgs>(args: SelectSubset<T, recetasUpsertArgs<ExtArgs>>): Prisma__recetasClient<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetasCountArgs} args - Arguments to filter Recetas to count.
     * @example
     * // Count the number of Recetas
     * const count = await prisma.recetas.count({
     *   where: {
     *     // ... the filter for the Recetas we want to count
     *   }
     * })
    **/
    count<T extends recetasCountArgs>(
      args?: Subset<T, recetasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecetasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecetasAggregateArgs>(args: Subset<T, RecetasAggregateArgs>): Prisma.PrismaPromise<GetRecetasAggregateType<T>>

    /**
     * Group by Recetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recetasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recetasGroupByArgs['orderBy'] }
        : { orderBy?: recetasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recetasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecetasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recetas model
   */
  readonly fields: recetasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recetas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recetasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unidadesmedida<T extends recetas$unidadesmedidaArgs<ExtArgs> = {}>(args?: Subset<T, recetas$unidadesmedidaArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    materia_prima<T extends recetas$materia_primaArgs<ExtArgs> = {}>(args?: Subset<T, recetas$materia_primaArgs<ExtArgs>>): Prisma__materia_primaClient<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    productos_terminados<T extends recetas$productos_terminadosArgs<ExtArgs> = {}>(args?: Subset<T, recetas$productos_terminadosArgs<ExtArgs>>): Prisma__productos_terminadosClient<$Result.GetResult<Prisma.$productos_terminadosPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    productos_especiales<T extends recetas$productos_especialesArgs<ExtArgs> = {}>(args?: Subset<T, recetas$productos_especialesArgs<ExtArgs>>): Prisma__productos_especialesClient<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the recetas model
   */ 
  interface recetasFieldRefs {
    readonly id_receta: FieldRef<"recetas", 'Int'>
    readonly id_producto: FieldRef<"recetas", 'Int'>
    readonly id_materia_prima: FieldRef<"recetas", 'Int'>
    readonly id_producto_especial: FieldRef<"recetas", 'Int'>
    readonly cantidad_requerida: FieldRef<"recetas", 'Decimal'>
    readonly unidad_medida: FieldRef<"recetas", 'Int'>
    readonly disponible: FieldRef<"recetas", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * recetas findUnique
   */
  export type recetasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    /**
     * Filter, which recetas to fetch.
     */
    where: recetasWhereUniqueInput
  }

  /**
   * recetas findUniqueOrThrow
   */
  export type recetasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    /**
     * Filter, which recetas to fetch.
     */
    where: recetasWhereUniqueInput
  }

  /**
   * recetas findFirst
   */
  export type recetasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    /**
     * Filter, which recetas to fetch.
     */
    where?: recetasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetas to fetch.
     */
    orderBy?: recetasOrderByWithRelationInput | recetasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recetas.
     */
    cursor?: recetasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recetas.
     */
    distinct?: RecetasScalarFieldEnum | RecetasScalarFieldEnum[]
  }

  /**
   * recetas findFirstOrThrow
   */
  export type recetasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    /**
     * Filter, which recetas to fetch.
     */
    where?: recetasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetas to fetch.
     */
    orderBy?: recetasOrderByWithRelationInput | recetasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recetas.
     */
    cursor?: recetasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recetas.
     */
    distinct?: RecetasScalarFieldEnum | RecetasScalarFieldEnum[]
  }

  /**
   * recetas findMany
   */
  export type recetasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    /**
     * Filter, which recetas to fetch.
     */
    where?: recetasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetas to fetch.
     */
    orderBy?: recetasOrderByWithRelationInput | recetasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recetas.
     */
    cursor?: recetasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetas.
     */
    skip?: number
    distinct?: RecetasScalarFieldEnum | RecetasScalarFieldEnum[]
  }

  /**
   * recetas create
   */
  export type recetasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    /**
     * The data needed to create a recetas.
     */
    data: XOR<recetasCreateInput, recetasUncheckedCreateInput>
  }

  /**
   * recetas createMany
   */
  export type recetasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recetas.
     */
    data: recetasCreateManyInput | recetasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recetas createManyAndReturn
   */
  export type recetasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many recetas.
     */
    data: recetasCreateManyInput | recetasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * recetas update
   */
  export type recetasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    /**
     * The data needed to update a recetas.
     */
    data: XOR<recetasUpdateInput, recetasUncheckedUpdateInput>
    /**
     * Choose, which recetas to update.
     */
    where: recetasWhereUniqueInput
  }

  /**
   * recetas updateMany
   */
  export type recetasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recetas.
     */
    data: XOR<recetasUpdateManyMutationInput, recetasUncheckedUpdateManyInput>
    /**
     * Filter which recetas to update
     */
    where?: recetasWhereInput
  }

  /**
   * recetas upsert
   */
  export type recetasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    /**
     * The filter to search for the recetas to update in case it exists.
     */
    where: recetasWhereUniqueInput
    /**
     * In case the recetas found by the `where` argument doesn't exist, create a new recetas with this data.
     */
    create: XOR<recetasCreateInput, recetasUncheckedCreateInput>
    /**
     * In case the recetas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recetasUpdateInput, recetasUncheckedUpdateInput>
  }

  /**
   * recetas delete
   */
  export type recetasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    /**
     * Filter which recetas to delete.
     */
    where: recetasWhereUniqueInput
  }

  /**
   * recetas deleteMany
   */
  export type recetasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recetas to delete
     */
    where?: recetasWhereInput
  }

  /**
   * recetas.unidadesmedida
   */
  export type recetas$unidadesmedidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    where?: unidadesmedidaWhereInput
  }

  /**
   * recetas.materia_prima
   */
  export type recetas$materia_primaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    where?: materia_primaWhereInput
  }

  /**
   * recetas.productos_terminados
   */
  export type recetas$productos_terminadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_terminados
     */
    select?: productos_terminadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_terminadosInclude<ExtArgs> | null
    where?: productos_terminadosWhereInput
  }

  /**
   * recetas.productos_especiales
   */
  export type recetas$productos_especialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    where?: productos_especialesWhereInput
  }

  /**
   * recetas without action
   */
  export type recetasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
  }


  /**
   * Model unidadesmedida
   */

  export type AggregateUnidadesmedida = {
    _count: UnidadesmedidaCountAggregateOutputType | null
    _avg: UnidadesmedidaAvgAggregateOutputType | null
    _sum: UnidadesmedidaSumAggregateOutputType | null
    _min: UnidadesmedidaMinAggregateOutputType | null
    _max: UnidadesmedidaMaxAggregateOutputType | null
  }

  export type UnidadesmedidaAvgAggregateOutputType = {
    id: number | null
    factor_conversion: Decimal | null
  }

  export type UnidadesmedidaSumAggregateOutputType = {
    id: number | null
    factor_conversion: Decimal | null
  }

  export type UnidadesmedidaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    factor_conversion: Decimal | null
  }

  export type UnidadesmedidaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    factor_conversion: Decimal | null
  }

  export type UnidadesmedidaCountAggregateOutputType = {
    id: number
    nombre: number
    factor_conversion: number
    _all: number
  }


  export type UnidadesmedidaAvgAggregateInputType = {
    id?: true
    factor_conversion?: true
  }

  export type UnidadesmedidaSumAggregateInputType = {
    id?: true
    factor_conversion?: true
  }

  export type UnidadesmedidaMinAggregateInputType = {
    id?: true
    nombre?: true
    factor_conversion?: true
  }

  export type UnidadesmedidaMaxAggregateInputType = {
    id?: true
    nombre?: true
    factor_conversion?: true
  }

  export type UnidadesmedidaCountAggregateInputType = {
    id?: true
    nombre?: true
    factor_conversion?: true
    _all?: true
  }

  export type UnidadesmedidaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which unidadesmedida to aggregate.
     */
    where?: unidadesmedidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unidadesmedidas to fetch.
     */
    orderBy?: unidadesmedidaOrderByWithRelationInput | unidadesmedidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: unidadesmedidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unidadesmedidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unidadesmedidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned unidadesmedidas
    **/
    _count?: true | UnidadesmedidaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnidadesmedidaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnidadesmedidaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnidadesmedidaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnidadesmedidaMaxAggregateInputType
  }

  export type GetUnidadesmedidaAggregateType<T extends UnidadesmedidaAggregateArgs> = {
        [P in keyof T & keyof AggregateUnidadesmedida]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnidadesmedida[P]>
      : GetScalarType<T[P], AggregateUnidadesmedida[P]>
  }




  export type unidadesmedidaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unidadesmedidaWhereInput
    orderBy?: unidadesmedidaOrderByWithAggregationInput | unidadesmedidaOrderByWithAggregationInput[]
    by: UnidadesmedidaScalarFieldEnum[] | UnidadesmedidaScalarFieldEnum
    having?: unidadesmedidaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnidadesmedidaCountAggregateInputType | true
    _avg?: UnidadesmedidaAvgAggregateInputType
    _sum?: UnidadesmedidaSumAggregateInputType
    _min?: UnidadesmedidaMinAggregateInputType
    _max?: UnidadesmedidaMaxAggregateInputType
  }

  export type UnidadesmedidaGroupByOutputType = {
    id: number
    nombre: string
    factor_conversion: Decimal
    _count: UnidadesmedidaCountAggregateOutputType | null
    _avg: UnidadesmedidaAvgAggregateOutputType | null
    _sum: UnidadesmedidaSumAggregateOutputType | null
    _min: UnidadesmedidaMinAggregateOutputType | null
    _max: UnidadesmedidaMaxAggregateOutputType | null
  }

  type GetUnidadesmedidaGroupByPayload<T extends unidadesmedidaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnidadesmedidaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnidadesmedidaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnidadesmedidaGroupByOutputType[P]>
            : GetScalarType<T[P], UnidadesmedidaGroupByOutputType[P]>
        }
      >
    >


  export type unidadesmedidaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    factor_conversion?: boolean
    detalle_factura?: boolean | unidadesmedida$detalle_facturaArgs<ExtArgs>
    recetas?: boolean | unidadesmedida$recetasArgs<ExtArgs>
    materia_prima?: boolean | unidadesmedida$materia_primaArgs<ExtArgs>
    productos_especiales?: boolean | unidadesmedida$productos_especialesArgs<ExtArgs>
    _count?: boolean | UnidadesmedidaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unidadesmedida"]>

  export type unidadesmedidaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    factor_conversion?: boolean
  }, ExtArgs["result"]["unidadesmedida"]>

  export type unidadesmedidaSelectScalar = {
    id?: boolean
    nombre?: boolean
    factor_conversion?: boolean
  }

  export type unidadesmedidaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_factura?: boolean | unidadesmedida$detalle_facturaArgs<ExtArgs>
    recetas?: boolean | unidadesmedida$recetasArgs<ExtArgs>
    materia_prima?: boolean | unidadesmedida$materia_primaArgs<ExtArgs>
    productos_especiales?: boolean | unidadesmedida$productos_especialesArgs<ExtArgs>
    _count?: boolean | UnidadesmedidaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type unidadesmedidaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $unidadesmedidaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "unidadesmedida"
    objects: {
      detalle_factura: Prisma.$detalle_facturaPayload<ExtArgs>[]
      recetas: Prisma.$recetasPayload<ExtArgs>[]
      materia_prima: Prisma.$materia_primaPayload<ExtArgs>[]
      productos_especiales: Prisma.$productos_especialesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      factor_conversion: Prisma.Decimal
    }, ExtArgs["result"]["unidadesmedida"]>
    composites: {}
  }

  type unidadesmedidaGetPayload<S extends boolean | null | undefined | unidadesmedidaDefaultArgs> = $Result.GetResult<Prisma.$unidadesmedidaPayload, S>

  type unidadesmedidaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<unidadesmedidaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnidadesmedidaCountAggregateInputType | true
    }

  export interface unidadesmedidaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['unidadesmedida'], meta: { name: 'unidadesmedida' } }
    /**
     * Find zero or one Unidadesmedida that matches the filter.
     * @param {unidadesmedidaFindUniqueArgs} args - Arguments to find a Unidadesmedida
     * @example
     * // Get one Unidadesmedida
     * const unidadesmedida = await prisma.unidadesmedida.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends unidadesmedidaFindUniqueArgs>(args: SelectSubset<T, unidadesmedidaFindUniqueArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Unidadesmedida that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {unidadesmedidaFindUniqueOrThrowArgs} args - Arguments to find a Unidadesmedida
     * @example
     * // Get one Unidadesmedida
     * const unidadesmedida = await prisma.unidadesmedida.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends unidadesmedidaFindUniqueOrThrowArgs>(args: SelectSubset<T, unidadesmedidaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Unidadesmedida that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unidadesmedidaFindFirstArgs} args - Arguments to find a Unidadesmedida
     * @example
     * // Get one Unidadesmedida
     * const unidadesmedida = await prisma.unidadesmedida.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends unidadesmedidaFindFirstArgs>(args?: SelectSubset<T, unidadesmedidaFindFirstArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Unidadesmedida that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unidadesmedidaFindFirstOrThrowArgs} args - Arguments to find a Unidadesmedida
     * @example
     * // Get one Unidadesmedida
     * const unidadesmedida = await prisma.unidadesmedida.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends unidadesmedidaFindFirstOrThrowArgs>(args?: SelectSubset<T, unidadesmedidaFindFirstOrThrowArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Unidadesmedidas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unidadesmedidaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Unidadesmedidas
     * const unidadesmedidas = await prisma.unidadesmedida.findMany()
     * 
     * // Get first 10 Unidadesmedidas
     * const unidadesmedidas = await prisma.unidadesmedida.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unidadesmedidaWithIdOnly = await prisma.unidadesmedida.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends unidadesmedidaFindManyArgs>(args?: SelectSubset<T, unidadesmedidaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Unidadesmedida.
     * @param {unidadesmedidaCreateArgs} args - Arguments to create a Unidadesmedida.
     * @example
     * // Create one Unidadesmedida
     * const Unidadesmedida = await prisma.unidadesmedida.create({
     *   data: {
     *     // ... data to create a Unidadesmedida
     *   }
     * })
     * 
     */
    create<T extends unidadesmedidaCreateArgs>(args: SelectSubset<T, unidadesmedidaCreateArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Unidadesmedidas.
     * @param {unidadesmedidaCreateManyArgs} args - Arguments to create many Unidadesmedidas.
     * @example
     * // Create many Unidadesmedidas
     * const unidadesmedida = await prisma.unidadesmedida.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends unidadesmedidaCreateManyArgs>(args?: SelectSubset<T, unidadesmedidaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Unidadesmedidas and returns the data saved in the database.
     * @param {unidadesmedidaCreateManyAndReturnArgs} args - Arguments to create many Unidadesmedidas.
     * @example
     * // Create many Unidadesmedidas
     * const unidadesmedida = await prisma.unidadesmedida.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Unidadesmedidas and only return the `id`
     * const unidadesmedidaWithIdOnly = await prisma.unidadesmedida.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends unidadesmedidaCreateManyAndReturnArgs>(args?: SelectSubset<T, unidadesmedidaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Unidadesmedida.
     * @param {unidadesmedidaDeleteArgs} args - Arguments to delete one Unidadesmedida.
     * @example
     * // Delete one Unidadesmedida
     * const Unidadesmedida = await prisma.unidadesmedida.delete({
     *   where: {
     *     // ... filter to delete one Unidadesmedida
     *   }
     * })
     * 
     */
    delete<T extends unidadesmedidaDeleteArgs>(args: SelectSubset<T, unidadesmedidaDeleteArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Unidadesmedida.
     * @param {unidadesmedidaUpdateArgs} args - Arguments to update one Unidadesmedida.
     * @example
     * // Update one Unidadesmedida
     * const unidadesmedida = await prisma.unidadesmedida.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends unidadesmedidaUpdateArgs>(args: SelectSubset<T, unidadesmedidaUpdateArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Unidadesmedidas.
     * @param {unidadesmedidaDeleteManyArgs} args - Arguments to filter Unidadesmedidas to delete.
     * @example
     * // Delete a few Unidadesmedidas
     * const { count } = await prisma.unidadesmedida.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends unidadesmedidaDeleteManyArgs>(args?: SelectSubset<T, unidadesmedidaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Unidadesmedidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unidadesmedidaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Unidadesmedidas
     * const unidadesmedida = await prisma.unidadesmedida.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends unidadesmedidaUpdateManyArgs>(args: SelectSubset<T, unidadesmedidaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unidadesmedida.
     * @param {unidadesmedidaUpsertArgs} args - Arguments to update or create a Unidadesmedida.
     * @example
     * // Update or create a Unidadesmedida
     * const unidadesmedida = await prisma.unidadesmedida.upsert({
     *   create: {
     *     // ... data to create a Unidadesmedida
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unidadesmedida we want to update
     *   }
     * })
     */
    upsert<T extends unidadesmedidaUpsertArgs>(args: SelectSubset<T, unidadesmedidaUpsertArgs<ExtArgs>>): Prisma__unidadesmedidaClient<$Result.GetResult<Prisma.$unidadesmedidaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Unidadesmedidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unidadesmedidaCountArgs} args - Arguments to filter Unidadesmedidas to count.
     * @example
     * // Count the number of Unidadesmedidas
     * const count = await prisma.unidadesmedida.count({
     *   where: {
     *     // ... the filter for the Unidadesmedidas we want to count
     *   }
     * })
    **/
    count<T extends unidadesmedidaCountArgs>(
      args?: Subset<T, unidadesmedidaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnidadesmedidaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unidadesmedida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadesmedidaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnidadesmedidaAggregateArgs>(args: Subset<T, UnidadesmedidaAggregateArgs>): Prisma.PrismaPromise<GetUnidadesmedidaAggregateType<T>>

    /**
     * Group by Unidadesmedida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unidadesmedidaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends unidadesmedidaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: unidadesmedidaGroupByArgs['orderBy'] }
        : { orderBy?: unidadesmedidaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, unidadesmedidaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnidadesmedidaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the unidadesmedida model
   */
  readonly fields: unidadesmedidaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for unidadesmedida.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__unidadesmedidaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detalle_factura<T extends unidadesmedida$detalle_facturaArgs<ExtArgs> = {}>(args?: Subset<T, unidadesmedida$detalle_facturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_facturaPayload<ExtArgs>, T, "findMany"> | Null>
    recetas<T extends unidadesmedida$recetasArgs<ExtArgs> = {}>(args?: Subset<T, unidadesmedida$recetasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recetasPayload<ExtArgs>, T, "findMany"> | Null>
    materia_prima<T extends unidadesmedida$materia_primaArgs<ExtArgs> = {}>(args?: Subset<T, unidadesmedida$materia_primaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materia_primaPayload<ExtArgs>, T, "findMany"> | Null>
    productos_especiales<T extends unidadesmedida$productos_especialesArgs<ExtArgs> = {}>(args?: Subset<T, unidadesmedida$productos_especialesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productos_especialesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the unidadesmedida model
   */ 
  interface unidadesmedidaFieldRefs {
    readonly id: FieldRef<"unidadesmedida", 'Int'>
    readonly nombre: FieldRef<"unidadesmedida", 'String'>
    readonly factor_conversion: FieldRef<"unidadesmedida", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * unidadesmedida findUnique
   */
  export type unidadesmedidaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    /**
     * Filter, which unidadesmedida to fetch.
     */
    where: unidadesmedidaWhereUniqueInput
  }

  /**
   * unidadesmedida findUniqueOrThrow
   */
  export type unidadesmedidaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    /**
     * Filter, which unidadesmedida to fetch.
     */
    where: unidadesmedidaWhereUniqueInput
  }

  /**
   * unidadesmedida findFirst
   */
  export type unidadesmedidaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    /**
     * Filter, which unidadesmedida to fetch.
     */
    where?: unidadesmedidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unidadesmedidas to fetch.
     */
    orderBy?: unidadesmedidaOrderByWithRelationInput | unidadesmedidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unidadesmedidas.
     */
    cursor?: unidadesmedidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unidadesmedidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unidadesmedidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unidadesmedidas.
     */
    distinct?: UnidadesmedidaScalarFieldEnum | UnidadesmedidaScalarFieldEnum[]
  }

  /**
   * unidadesmedida findFirstOrThrow
   */
  export type unidadesmedidaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    /**
     * Filter, which unidadesmedida to fetch.
     */
    where?: unidadesmedidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unidadesmedidas to fetch.
     */
    orderBy?: unidadesmedidaOrderByWithRelationInput | unidadesmedidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unidadesmedidas.
     */
    cursor?: unidadesmedidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unidadesmedidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unidadesmedidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unidadesmedidas.
     */
    distinct?: UnidadesmedidaScalarFieldEnum | UnidadesmedidaScalarFieldEnum[]
  }

  /**
   * unidadesmedida findMany
   */
  export type unidadesmedidaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    /**
     * Filter, which unidadesmedidas to fetch.
     */
    where?: unidadesmedidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unidadesmedidas to fetch.
     */
    orderBy?: unidadesmedidaOrderByWithRelationInput | unidadesmedidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing unidadesmedidas.
     */
    cursor?: unidadesmedidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unidadesmedidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unidadesmedidas.
     */
    skip?: number
    distinct?: UnidadesmedidaScalarFieldEnum | UnidadesmedidaScalarFieldEnum[]
  }

  /**
   * unidadesmedida create
   */
  export type unidadesmedidaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    /**
     * The data needed to create a unidadesmedida.
     */
    data: XOR<unidadesmedidaCreateInput, unidadesmedidaUncheckedCreateInput>
  }

  /**
   * unidadesmedida createMany
   */
  export type unidadesmedidaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many unidadesmedidas.
     */
    data: unidadesmedidaCreateManyInput | unidadesmedidaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * unidadesmedida createManyAndReturn
   */
  export type unidadesmedidaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many unidadesmedidas.
     */
    data: unidadesmedidaCreateManyInput | unidadesmedidaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * unidadesmedida update
   */
  export type unidadesmedidaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    /**
     * The data needed to update a unidadesmedida.
     */
    data: XOR<unidadesmedidaUpdateInput, unidadesmedidaUncheckedUpdateInput>
    /**
     * Choose, which unidadesmedida to update.
     */
    where: unidadesmedidaWhereUniqueInput
  }

  /**
   * unidadesmedida updateMany
   */
  export type unidadesmedidaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update unidadesmedidas.
     */
    data: XOR<unidadesmedidaUpdateManyMutationInput, unidadesmedidaUncheckedUpdateManyInput>
    /**
     * Filter which unidadesmedidas to update
     */
    where?: unidadesmedidaWhereInput
  }

  /**
   * unidadesmedida upsert
   */
  export type unidadesmedidaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    /**
     * The filter to search for the unidadesmedida to update in case it exists.
     */
    where: unidadesmedidaWhereUniqueInput
    /**
     * In case the unidadesmedida found by the `where` argument doesn't exist, create a new unidadesmedida with this data.
     */
    create: XOR<unidadesmedidaCreateInput, unidadesmedidaUncheckedCreateInput>
    /**
     * In case the unidadesmedida was found with the provided `where` argument, update it with this data.
     */
    update: XOR<unidadesmedidaUpdateInput, unidadesmedidaUncheckedUpdateInput>
  }

  /**
   * unidadesmedida delete
   */
  export type unidadesmedidaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
    /**
     * Filter which unidadesmedida to delete.
     */
    where: unidadesmedidaWhereUniqueInput
  }

  /**
   * unidadesmedida deleteMany
   */
  export type unidadesmedidaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which unidadesmedidas to delete
     */
    where?: unidadesmedidaWhereInput
  }

  /**
   * unidadesmedida.detalle_factura
   */
  export type unidadesmedida$detalle_facturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_factura
     */
    select?: detalle_facturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_facturaInclude<ExtArgs> | null
    where?: detalle_facturaWhereInput
    orderBy?: detalle_facturaOrderByWithRelationInput | detalle_facturaOrderByWithRelationInput[]
    cursor?: detalle_facturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detalle_facturaScalarFieldEnum | Detalle_facturaScalarFieldEnum[]
  }

  /**
   * unidadesmedida.recetas
   */
  export type unidadesmedida$recetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recetas
     */
    select?: recetasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recetasInclude<ExtArgs> | null
    where?: recetasWhereInput
    orderBy?: recetasOrderByWithRelationInput | recetasOrderByWithRelationInput[]
    cursor?: recetasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetasScalarFieldEnum | RecetasScalarFieldEnum[]
  }

  /**
   * unidadesmedida.materia_prima
   */
  export type unidadesmedida$materia_primaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materia_prima
     */
    select?: materia_primaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materia_primaInclude<ExtArgs> | null
    where?: materia_primaWhereInput
    orderBy?: materia_primaOrderByWithRelationInput | materia_primaOrderByWithRelationInput[]
    cursor?: materia_primaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Materia_primaScalarFieldEnum | Materia_primaScalarFieldEnum[]
  }

  /**
   * unidadesmedida.productos_especiales
   */
  export type unidadesmedida$productos_especialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos_especiales
     */
    select?: productos_especialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productos_especialesInclude<ExtArgs> | null
    where?: productos_especialesWhereInput
    orderBy?: productos_especialesOrderByWithRelationInput | productos_especialesOrderByWithRelationInput[]
    cursor?: productos_especialesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Productos_especialesScalarFieldEnum | Productos_especialesScalarFieldEnum[]
  }

  /**
   * unidadesmedida without action
   */
  export type unidadesmedidaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unidadesmedida
     */
    select?: unidadesmedidaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unidadesmedidaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Detalle_facturaScalarFieldEnum: {
    id_detalle: 'id_detalle',
    id_factura: 'id_factura',
    id_materia_prima: 'id_materia_prima',
    cantidad: 'cantidad',
    precio_unitario: 'precio_unitario',
    subtotal: 'subtotal',
    unidad_medida: 'unidad_medida'
  };

  export type Detalle_facturaScalarFieldEnum = (typeof Detalle_facturaScalarFieldEnum)[keyof typeof Detalle_facturaScalarFieldEnum]


  export const FacturasScalarFieldEnum: {
    id_factura: 'id_factura',
    id_proveedor: 'id_proveedor',
    id_moneda: 'id_moneda',
    fecha_factura: 'fecha_factura',
    total: 'total',
    estado: 'estado',
    observaciones: 'observaciones'
  };

  export type FacturasScalarFieldEnum = (typeof FacturasScalarFieldEnum)[keyof typeof FacturasScalarFieldEnum]


  export const ConversionFactorScalarFieldEnum: {
    id: 'id',
    unidadOrigen: 'unidadOrigen',
    unidadDestino: 'unidadDestino',
    factorConversion: 'factorConversion'
  };

  export type ConversionFactorScalarFieldEnum = (typeof ConversionFactorScalarFieldEnum)[keyof typeof ConversionFactorScalarFieldEnum]


  export const Kardex_materia_primaScalarFieldEnum: {
    id_kardex: 'id_kardex',
    id_materia_prima: 'id_materia_prima',
    tipo_movimiento: 'tipo_movimiento',
    cantidad: 'cantidad',
    saldo: 'saldo',
    costo_unitario: 'costo_unitario',
    costo_total: 'costo_total',
    fecha_movimiento: 'fecha_movimiento',
    referencia: 'referencia',
    observaciones: 'observaciones'
  };

  export type Kardex_materia_primaScalarFieldEnum = (typeof Kardex_materia_primaScalarFieldEnum)[keyof typeof Kardex_materia_primaScalarFieldEnum]


  export const Kardex_productosScalarFieldEnum: {
    id_kardex: 'id_kardex',
    id_producto: 'id_producto',
    tipo_movimiento: 'tipo_movimiento',
    cantidad: 'cantidad',
    saldo: 'saldo',
    costo_produccion: 'costo_produccion',
    precio_venta: 'precio_venta',
    fecha_movimiento: 'fecha_movimiento',
    referencia: 'referencia',
    referencias_archivos: 'referencias_archivos',
    observaciones: 'observaciones'
  };

  export type Kardex_productosScalarFieldEnum = (typeof Kardex_productosScalarFieldEnum)[keyof typeof Kardex_productosScalarFieldEnum]


  export const Materia_primaScalarFieldEnum: {
    id_materia_prima: 'id_materia_prima',
    nombre: 'nombre',
    unidad_medida_id: 'unidad_medida_id',
    costo_unitario: 'costo_unitario',
    presentacion: 'presentacion',
    stock_actual: 'stock_actual',
    codigo_barras: 'codigo_barras',
    fecha_registro: 'fecha_registro',
    disponible: 'disponible'
  };

  export type Materia_primaScalarFieldEnum = (typeof Materia_primaScalarFieldEnum)[keyof typeof Materia_primaScalarFieldEnum]


  export const MonedasScalarFieldEnum: {
    id_moneda: 'id_moneda',
    nombre: 'nombre',
    tasa_cambio: 'tasa_cambio'
  };

  export type MonedasScalarFieldEnum = (typeof MonedasScalarFieldEnum)[keyof typeof MonedasScalarFieldEnum]


  export const Productos_terminadosScalarFieldEnum: {
    id_producto: 'id_producto',
    nombre: 'nombre',
    precio_venta: 'precio_venta',
    stock_actual: 'stock_actual',
    codigo_barras: 'codigo_barras',
    precio_produccion: 'precio_produccion',
    id_moneda: 'id_moneda',
    id_producto_especial: 'id_producto_especial'
  };

  export type Productos_terminadosScalarFieldEnum = (typeof Productos_terminadosScalarFieldEnum)[keyof typeof Productos_terminadosScalarFieldEnum]


  export const Productos_especialesScalarFieldEnum: {
    id_producto_especial: 'id_producto_especial',
    id_producto: 'id_producto',
    rendimiento: 'rendimiento',
    unidad_rendimiento: 'unidad_rendimiento'
  };

  export type Productos_especialesScalarFieldEnum = (typeof Productos_especialesScalarFieldEnum)[keyof typeof Productos_especialesScalarFieldEnum]


  export const ProveedoresScalarFieldEnum: {
    id_proveedor: 'id_proveedor',
    rif: 'rif',
    nombre: 'nombre',
    contacto: 'contacto',
    telefono: 'telefono',
    direccion: 'direccion',
    empresa_nombre: 'empresa_nombre',
    fecha_registro: 'fecha_registro'
  };

  export type ProveedoresScalarFieldEnum = (typeof ProveedoresScalarFieldEnum)[keyof typeof ProveedoresScalarFieldEnum]


  export const RecetasScalarFieldEnum: {
    id_receta: 'id_receta',
    id_producto: 'id_producto',
    id_materia_prima: 'id_materia_prima',
    id_producto_especial: 'id_producto_especial',
    cantidad_requerida: 'cantidad_requerida',
    unidad_medida: 'unidad_medida',
    disponible: 'disponible'
  };

  export type RecetasScalarFieldEnum = (typeof RecetasScalarFieldEnum)[keyof typeof RecetasScalarFieldEnum]


  export const UnidadesmedidaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    factor_conversion: 'factor_conversion'
  };

  export type UnidadesmedidaScalarFieldEnum = (typeof UnidadesmedidaScalarFieldEnum)[keyof typeof UnidadesmedidaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type detalle_facturaWhereInput = {
    AND?: detalle_facturaWhereInput | detalle_facturaWhereInput[]
    OR?: detalle_facturaWhereInput[]
    NOT?: detalle_facturaWhereInput | detalle_facturaWhereInput[]
    id_detalle?: IntFilter<"detalle_factura"> | number
    id_factura?: IntNullableFilter<"detalle_factura"> | number | null
    id_materia_prima?: IntNullableFilter<"detalle_factura"> | number | null
    cantidad?: DecimalFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalNullableFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string | null
    unidad_medida?: IntNullableFilter<"detalle_factura"> | number | null
    facturas?: XOR<FacturasNullableScalarRelationFilter, facturasWhereInput> | null
    materia_prima?: XOR<Materia_primaNullableScalarRelationFilter, materia_primaWhereInput> | null
    unidadesmedida?: XOR<UnidadesmedidaNullableScalarRelationFilter, unidadesmedidaWhereInput> | null
  }

  export type detalle_facturaOrderByWithRelationInput = {
    id_detalle?: SortOrder
    id_factura?: SortOrderInput | SortOrder
    id_materia_prima?: SortOrderInput | SortOrder
    cantidad?: SortOrder
    precio_unitario?: SortOrder
    subtotal?: SortOrderInput | SortOrder
    unidad_medida?: SortOrderInput | SortOrder
    facturas?: facturasOrderByWithRelationInput
    materia_prima?: materia_primaOrderByWithRelationInput
    unidadesmedida?: unidadesmedidaOrderByWithRelationInput
  }

  export type detalle_facturaWhereUniqueInput = Prisma.AtLeast<{
    id_detalle?: number
    AND?: detalle_facturaWhereInput | detalle_facturaWhereInput[]
    OR?: detalle_facturaWhereInput[]
    NOT?: detalle_facturaWhereInput | detalle_facturaWhereInput[]
    id_factura?: IntNullableFilter<"detalle_factura"> | number | null
    id_materia_prima?: IntNullableFilter<"detalle_factura"> | number | null
    cantidad?: DecimalFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalNullableFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string | null
    unidad_medida?: IntNullableFilter<"detalle_factura"> | number | null
    facturas?: XOR<FacturasNullableScalarRelationFilter, facturasWhereInput> | null
    materia_prima?: XOR<Materia_primaNullableScalarRelationFilter, materia_primaWhereInput> | null
    unidadesmedida?: XOR<UnidadesmedidaNullableScalarRelationFilter, unidadesmedidaWhereInput> | null
  }, "id_detalle">

  export type detalle_facturaOrderByWithAggregationInput = {
    id_detalle?: SortOrder
    id_factura?: SortOrderInput | SortOrder
    id_materia_prima?: SortOrderInput | SortOrder
    cantidad?: SortOrder
    precio_unitario?: SortOrder
    subtotal?: SortOrderInput | SortOrder
    unidad_medida?: SortOrderInput | SortOrder
    _count?: detalle_facturaCountOrderByAggregateInput
    _avg?: detalle_facturaAvgOrderByAggregateInput
    _max?: detalle_facturaMaxOrderByAggregateInput
    _min?: detalle_facturaMinOrderByAggregateInput
    _sum?: detalle_facturaSumOrderByAggregateInput
  }

  export type detalle_facturaScalarWhereWithAggregatesInput = {
    AND?: detalle_facturaScalarWhereWithAggregatesInput | detalle_facturaScalarWhereWithAggregatesInput[]
    OR?: detalle_facturaScalarWhereWithAggregatesInput[]
    NOT?: detalle_facturaScalarWhereWithAggregatesInput | detalle_facturaScalarWhereWithAggregatesInput[]
    id_detalle?: IntWithAggregatesFilter<"detalle_factura"> | number
    id_factura?: IntNullableWithAggregatesFilter<"detalle_factura"> | number | null
    id_materia_prima?: IntNullableWithAggregatesFilter<"detalle_factura"> | number | null
    cantidad?: DecimalWithAggregatesFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalWithAggregatesFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalNullableWithAggregatesFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string | null
    unidad_medida?: IntNullableWithAggregatesFilter<"detalle_factura"> | number | null
  }

  export type facturasWhereInput = {
    AND?: facturasWhereInput | facturasWhereInput[]
    OR?: facturasWhereInput[]
    NOT?: facturasWhereInput | facturasWhereInput[]
    id_factura?: IntFilter<"facturas"> | number
    id_proveedor?: IntNullableFilter<"facturas"> | number | null
    id_moneda?: IntFilter<"facturas"> | number
    fecha_factura?: DateTimeNullableFilter<"facturas"> | Date | string | null
    total?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    estado?: BoolNullableFilter<"facturas"> | boolean | null
    observaciones?: StringNullableFilter<"facturas"> | string | null
    detalle_factura?: Detalle_facturaListRelationFilter
    monedas?: XOR<MonedasScalarRelationFilter, monedasWhereInput>
    proveedores?: XOR<ProveedoresNullableScalarRelationFilter, proveedoresWhereInput> | null
  }

  export type facturasOrderByWithRelationInput = {
    id_factura?: SortOrder
    id_proveedor?: SortOrderInput | SortOrder
    id_moneda?: SortOrder
    fecha_factura?: SortOrderInput | SortOrder
    total?: SortOrder
    estado?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    detalle_factura?: detalle_facturaOrderByRelationAggregateInput
    monedas?: monedasOrderByWithRelationInput
    proveedores?: proveedoresOrderByWithRelationInput
  }

  export type facturasWhereUniqueInput = Prisma.AtLeast<{
    id_factura?: number
    AND?: facturasWhereInput | facturasWhereInput[]
    OR?: facturasWhereInput[]
    NOT?: facturasWhereInput | facturasWhereInput[]
    id_proveedor?: IntNullableFilter<"facturas"> | number | null
    id_moneda?: IntFilter<"facturas"> | number
    fecha_factura?: DateTimeNullableFilter<"facturas"> | Date | string | null
    total?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    estado?: BoolNullableFilter<"facturas"> | boolean | null
    observaciones?: StringNullableFilter<"facturas"> | string | null
    detalle_factura?: Detalle_facturaListRelationFilter
    monedas?: XOR<MonedasScalarRelationFilter, monedasWhereInput>
    proveedores?: XOR<ProveedoresNullableScalarRelationFilter, proveedoresWhereInput> | null
  }, "id_factura">

  export type facturasOrderByWithAggregationInput = {
    id_factura?: SortOrder
    id_proveedor?: SortOrderInput | SortOrder
    id_moneda?: SortOrder
    fecha_factura?: SortOrderInput | SortOrder
    total?: SortOrder
    estado?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    _count?: facturasCountOrderByAggregateInput
    _avg?: facturasAvgOrderByAggregateInput
    _max?: facturasMaxOrderByAggregateInput
    _min?: facturasMinOrderByAggregateInput
    _sum?: facturasSumOrderByAggregateInput
  }

  export type facturasScalarWhereWithAggregatesInput = {
    AND?: facturasScalarWhereWithAggregatesInput | facturasScalarWhereWithAggregatesInput[]
    OR?: facturasScalarWhereWithAggregatesInput[]
    NOT?: facturasScalarWhereWithAggregatesInput | facturasScalarWhereWithAggregatesInput[]
    id_factura?: IntWithAggregatesFilter<"facturas"> | number
    id_proveedor?: IntNullableWithAggregatesFilter<"facturas"> | number | null
    id_moneda?: IntWithAggregatesFilter<"facturas"> | number
    fecha_factura?: DateTimeNullableWithAggregatesFilter<"facturas"> | Date | string | null
    total?: DecimalWithAggregatesFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    estado?: BoolNullableWithAggregatesFilter<"facturas"> | boolean | null
    observaciones?: StringNullableWithAggregatesFilter<"facturas"> | string | null
  }

  export type ConversionFactorWhereInput = {
    AND?: ConversionFactorWhereInput | ConversionFactorWhereInput[]
    OR?: ConversionFactorWhereInput[]
    NOT?: ConversionFactorWhereInput | ConversionFactorWhereInput[]
    id?: IntFilter<"ConversionFactor"> | number
    unidadOrigen?: StringFilter<"ConversionFactor"> | string
    unidadDestino?: StringFilter<"ConversionFactor"> | string
    factorConversion?: FloatFilter<"ConversionFactor"> | number
  }

  export type ConversionFactorOrderByWithRelationInput = {
    id?: SortOrder
    unidadOrigen?: SortOrder
    unidadDestino?: SortOrder
    factorConversion?: SortOrder
  }

  export type ConversionFactorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    unidadOrigen_unidadDestino?: ConversionFactorUnidadOrigenUnidadDestinoCompoundUniqueInput
    AND?: ConversionFactorWhereInput | ConversionFactorWhereInput[]
    OR?: ConversionFactorWhereInput[]
    NOT?: ConversionFactorWhereInput | ConversionFactorWhereInput[]
    unidadOrigen?: StringFilter<"ConversionFactor"> | string
    unidadDestino?: StringFilter<"ConversionFactor"> | string
    factorConversion?: FloatFilter<"ConversionFactor"> | number
  }, "id" | "unidadOrigen_unidadDestino">

  export type ConversionFactorOrderByWithAggregationInput = {
    id?: SortOrder
    unidadOrigen?: SortOrder
    unidadDestino?: SortOrder
    factorConversion?: SortOrder
    _count?: ConversionFactorCountOrderByAggregateInput
    _avg?: ConversionFactorAvgOrderByAggregateInput
    _max?: ConversionFactorMaxOrderByAggregateInput
    _min?: ConversionFactorMinOrderByAggregateInput
    _sum?: ConversionFactorSumOrderByAggregateInput
  }

  export type ConversionFactorScalarWhereWithAggregatesInput = {
    AND?: ConversionFactorScalarWhereWithAggregatesInput | ConversionFactorScalarWhereWithAggregatesInput[]
    OR?: ConversionFactorScalarWhereWithAggregatesInput[]
    NOT?: ConversionFactorScalarWhereWithAggregatesInput | ConversionFactorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConversionFactor"> | number
    unidadOrigen?: StringWithAggregatesFilter<"ConversionFactor"> | string
    unidadDestino?: StringWithAggregatesFilter<"ConversionFactor"> | string
    factorConversion?: FloatWithAggregatesFilter<"ConversionFactor"> | number
  }

  export type kardex_materia_primaWhereInput = {
    AND?: kardex_materia_primaWhereInput | kardex_materia_primaWhereInput[]
    OR?: kardex_materia_primaWhereInput[]
    NOT?: kardex_materia_primaWhereInput | kardex_materia_primaWhereInput[]
    id_kardex?: IntFilter<"kardex_materia_prima"> | number
    id_materia_prima?: IntNullableFilter<"kardex_materia_prima"> | number | null
    tipo_movimiento?: StringFilter<"kardex_materia_prima"> | string
    cantidad?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: DateTimeNullableFilter<"kardex_materia_prima"> | Date | string | null
    referencia?: StringNullableFilter<"kardex_materia_prima"> | string | null
    observaciones?: StringNullableFilter<"kardex_materia_prima"> | string | null
    materia_prima?: XOR<Materia_primaNullableScalarRelationFilter, materia_primaWhereInput> | null
  }

  export type kardex_materia_primaOrderByWithRelationInput = {
    id_kardex?: SortOrder
    id_materia_prima?: SortOrderInput | SortOrder
    tipo_movimiento?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_unitario?: SortOrder
    costo_total?: SortOrder
    fecha_movimiento?: SortOrderInput | SortOrder
    referencia?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    materia_prima?: materia_primaOrderByWithRelationInput
  }

  export type kardex_materia_primaWhereUniqueInput = Prisma.AtLeast<{
    id_kardex?: number
    AND?: kardex_materia_primaWhereInput | kardex_materia_primaWhereInput[]
    OR?: kardex_materia_primaWhereInput[]
    NOT?: kardex_materia_primaWhereInput | kardex_materia_primaWhereInput[]
    id_materia_prima?: IntNullableFilter<"kardex_materia_prima"> | number | null
    tipo_movimiento?: StringFilter<"kardex_materia_prima"> | string
    cantidad?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: DateTimeNullableFilter<"kardex_materia_prima"> | Date | string | null
    referencia?: StringNullableFilter<"kardex_materia_prima"> | string | null
    observaciones?: StringNullableFilter<"kardex_materia_prima"> | string | null
    materia_prima?: XOR<Materia_primaNullableScalarRelationFilter, materia_primaWhereInput> | null
  }, "id_kardex">

  export type kardex_materia_primaOrderByWithAggregationInput = {
    id_kardex?: SortOrder
    id_materia_prima?: SortOrderInput | SortOrder
    tipo_movimiento?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_unitario?: SortOrder
    costo_total?: SortOrder
    fecha_movimiento?: SortOrderInput | SortOrder
    referencia?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    _count?: kardex_materia_primaCountOrderByAggregateInput
    _avg?: kardex_materia_primaAvgOrderByAggregateInput
    _max?: kardex_materia_primaMaxOrderByAggregateInput
    _min?: kardex_materia_primaMinOrderByAggregateInput
    _sum?: kardex_materia_primaSumOrderByAggregateInput
  }

  export type kardex_materia_primaScalarWhereWithAggregatesInput = {
    AND?: kardex_materia_primaScalarWhereWithAggregatesInput | kardex_materia_primaScalarWhereWithAggregatesInput[]
    OR?: kardex_materia_primaScalarWhereWithAggregatesInput[]
    NOT?: kardex_materia_primaScalarWhereWithAggregatesInput | kardex_materia_primaScalarWhereWithAggregatesInput[]
    id_kardex?: IntWithAggregatesFilter<"kardex_materia_prima"> | number
    id_materia_prima?: IntNullableWithAggregatesFilter<"kardex_materia_prima"> | number | null
    tipo_movimiento?: StringWithAggregatesFilter<"kardex_materia_prima"> | string
    cantidad?: DecimalWithAggregatesFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    saldo?: DecimalWithAggregatesFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalWithAggregatesFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalWithAggregatesFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: DateTimeNullableWithAggregatesFilter<"kardex_materia_prima"> | Date | string | null
    referencia?: StringNullableWithAggregatesFilter<"kardex_materia_prima"> | string | null
    observaciones?: StringNullableWithAggregatesFilter<"kardex_materia_prima"> | string | null
  }

  export type kardex_productosWhereInput = {
    AND?: kardex_productosWhereInput | kardex_productosWhereInput[]
    OR?: kardex_productosWhereInput[]
    NOT?: kardex_productosWhereInput | kardex_productosWhereInput[]
    id_kardex?: IntFilter<"kardex_productos"> | number
    id_producto?: IntNullableFilter<"kardex_productos"> | number | null
    tipo_movimiento?: StringFilter<"kardex_productos"> | string
    cantidad?: DecimalFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string
    costo_produccion?: DecimalNullableFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string | null
    precio_venta?: DecimalNullableFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: DateTimeNullableFilter<"kardex_productos"> | Date | string | null
    referencia?: StringNullableFilter<"kardex_productos"> | string | null
    referencias_archivos?: StringNullableListFilter<"kardex_productos">
    observaciones?: StringNullableFilter<"kardex_productos"> | string | null
    productos_terminados?: XOR<Productos_terminadosNullableScalarRelationFilter, productos_terminadosWhereInput> | null
  }

  export type kardex_productosOrderByWithRelationInput = {
    id_kardex?: SortOrder
    id_producto?: SortOrderInput | SortOrder
    tipo_movimiento?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_produccion?: SortOrderInput | SortOrder
    precio_venta?: SortOrderInput | SortOrder
    fecha_movimiento?: SortOrderInput | SortOrder
    referencia?: SortOrderInput | SortOrder
    referencias_archivos?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    productos_terminados?: productos_terminadosOrderByWithRelationInput
  }

  export type kardex_productosWhereUniqueInput = Prisma.AtLeast<{
    id_kardex?: number
    AND?: kardex_productosWhereInput | kardex_productosWhereInput[]
    OR?: kardex_productosWhereInput[]
    NOT?: kardex_productosWhereInput | kardex_productosWhereInput[]
    id_producto?: IntNullableFilter<"kardex_productos"> | number | null
    tipo_movimiento?: StringFilter<"kardex_productos"> | string
    cantidad?: DecimalFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string
    costo_produccion?: DecimalNullableFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string | null
    precio_venta?: DecimalNullableFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: DateTimeNullableFilter<"kardex_productos"> | Date | string | null
    referencia?: StringNullableFilter<"kardex_productos"> | string | null
    referencias_archivos?: StringNullableListFilter<"kardex_productos">
    observaciones?: StringNullableFilter<"kardex_productos"> | string | null
    productos_terminados?: XOR<Productos_terminadosNullableScalarRelationFilter, productos_terminadosWhereInput> | null
  }, "id_kardex">

  export type kardex_productosOrderByWithAggregationInput = {
    id_kardex?: SortOrder
    id_producto?: SortOrderInput | SortOrder
    tipo_movimiento?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_produccion?: SortOrderInput | SortOrder
    precio_venta?: SortOrderInput | SortOrder
    fecha_movimiento?: SortOrderInput | SortOrder
    referencia?: SortOrderInput | SortOrder
    referencias_archivos?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    _count?: kardex_productosCountOrderByAggregateInput
    _avg?: kardex_productosAvgOrderByAggregateInput
    _max?: kardex_productosMaxOrderByAggregateInput
    _min?: kardex_productosMinOrderByAggregateInput
    _sum?: kardex_productosSumOrderByAggregateInput
  }

  export type kardex_productosScalarWhereWithAggregatesInput = {
    AND?: kardex_productosScalarWhereWithAggregatesInput | kardex_productosScalarWhereWithAggregatesInput[]
    OR?: kardex_productosScalarWhereWithAggregatesInput[]
    NOT?: kardex_productosScalarWhereWithAggregatesInput | kardex_productosScalarWhereWithAggregatesInput[]
    id_kardex?: IntWithAggregatesFilter<"kardex_productos"> | number
    id_producto?: IntNullableWithAggregatesFilter<"kardex_productos"> | number | null
    tipo_movimiento?: StringWithAggregatesFilter<"kardex_productos"> | string
    cantidad?: DecimalWithAggregatesFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string
    saldo?: DecimalWithAggregatesFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string
    costo_produccion?: DecimalNullableWithAggregatesFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string | null
    precio_venta?: DecimalNullableWithAggregatesFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: DateTimeNullableWithAggregatesFilter<"kardex_productos"> | Date | string | null
    referencia?: StringNullableWithAggregatesFilter<"kardex_productos"> | string | null
    referencias_archivos?: StringNullableListFilter<"kardex_productos">
    observaciones?: StringNullableWithAggregatesFilter<"kardex_productos"> | string | null
  }

  export type materia_primaWhereInput = {
    AND?: materia_primaWhereInput | materia_primaWhereInput[]
    OR?: materia_primaWhereInput[]
    NOT?: materia_primaWhereInput | materia_primaWhereInput[]
    id_materia_prima?: IntFilter<"materia_prima"> | number
    nombre?: StringFilter<"materia_prima"> | string
    unidad_medida_id?: IntFilter<"materia_prima"> | number
    costo_unitario?: DecimalFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string
    stock_actual?: DecimalNullableFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFilter<"materia_prima"> | string
    fecha_registro?: DateTimeNullableFilter<"materia_prima"> | Date | string | null
    disponible?: BoolFilter<"materia_prima"> | boolean
    detalle_factura?: Detalle_facturaListRelationFilter
    kardex_materia_prima?: Kardex_materia_primaListRelationFilter
    recetas?: RecetasListRelationFilter
    unidad_medida?: XOR<UnidadesmedidaScalarRelationFilter, unidadesmedidaWhereInput>
  }

  export type materia_primaOrderByWithRelationInput = {
    id_materia_prima?: SortOrder
    nombre?: SortOrder
    unidad_medida_id?: SortOrder
    costo_unitario?: SortOrder
    presentacion?: SortOrder
    stock_actual?: SortOrderInput | SortOrder
    codigo_barras?: SortOrder
    fecha_registro?: SortOrderInput | SortOrder
    disponible?: SortOrder
    detalle_factura?: detalle_facturaOrderByRelationAggregateInput
    kardex_materia_prima?: kardex_materia_primaOrderByRelationAggregateInput
    recetas?: recetasOrderByRelationAggregateInput
    unidad_medida?: unidadesmedidaOrderByWithRelationInput
  }

  export type materia_primaWhereUniqueInput = Prisma.AtLeast<{
    id_materia_prima?: number
    codigo_barras?: string
    AND?: materia_primaWhereInput | materia_primaWhereInput[]
    OR?: materia_primaWhereInput[]
    NOT?: materia_primaWhereInput | materia_primaWhereInput[]
    nombre?: StringFilter<"materia_prima"> | string
    unidad_medida_id?: IntFilter<"materia_prima"> | number
    costo_unitario?: DecimalFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string
    stock_actual?: DecimalNullableFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string | null
    fecha_registro?: DateTimeNullableFilter<"materia_prima"> | Date | string | null
    disponible?: BoolFilter<"materia_prima"> | boolean
    detalle_factura?: Detalle_facturaListRelationFilter
    kardex_materia_prima?: Kardex_materia_primaListRelationFilter
    recetas?: RecetasListRelationFilter
    unidad_medida?: XOR<UnidadesmedidaScalarRelationFilter, unidadesmedidaWhereInput>
  }, "id_materia_prima" | "codigo_barras">

  export type materia_primaOrderByWithAggregationInput = {
    id_materia_prima?: SortOrder
    nombre?: SortOrder
    unidad_medida_id?: SortOrder
    costo_unitario?: SortOrder
    presentacion?: SortOrder
    stock_actual?: SortOrderInput | SortOrder
    codigo_barras?: SortOrder
    fecha_registro?: SortOrderInput | SortOrder
    disponible?: SortOrder
    _count?: materia_primaCountOrderByAggregateInput
    _avg?: materia_primaAvgOrderByAggregateInput
    _max?: materia_primaMaxOrderByAggregateInput
    _min?: materia_primaMinOrderByAggregateInput
    _sum?: materia_primaSumOrderByAggregateInput
  }

  export type materia_primaScalarWhereWithAggregatesInput = {
    AND?: materia_primaScalarWhereWithAggregatesInput | materia_primaScalarWhereWithAggregatesInput[]
    OR?: materia_primaScalarWhereWithAggregatesInput[]
    NOT?: materia_primaScalarWhereWithAggregatesInput | materia_primaScalarWhereWithAggregatesInput[]
    id_materia_prima?: IntWithAggregatesFilter<"materia_prima"> | number
    nombre?: StringWithAggregatesFilter<"materia_prima"> | string
    unidad_medida_id?: IntWithAggregatesFilter<"materia_prima"> | number
    costo_unitario?: DecimalWithAggregatesFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalWithAggregatesFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string
    stock_actual?: DecimalNullableWithAggregatesFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringWithAggregatesFilter<"materia_prima"> | string
    fecha_registro?: DateTimeNullableWithAggregatesFilter<"materia_prima"> | Date | string | null
    disponible?: BoolWithAggregatesFilter<"materia_prima"> | boolean
  }

  export type monedasWhereInput = {
    AND?: monedasWhereInput | monedasWhereInput[]
    OR?: monedasWhereInput[]
    NOT?: monedasWhereInput | monedasWhereInput[]
    id_moneda?: IntFilter<"monedas"> | number
    nombre?: StringFilter<"monedas"> | string
    tasa_cambio?: DecimalFilter<"monedas"> | Decimal | DecimalJsLike | number | string
    facturas?: FacturasListRelationFilter
    productos_terminados?: Productos_terminadosListRelationFilter
  }

  export type monedasOrderByWithRelationInput = {
    id_moneda?: SortOrder
    nombre?: SortOrder
    tasa_cambio?: SortOrder
    facturas?: facturasOrderByRelationAggregateInput
    productos_terminados?: productos_terminadosOrderByRelationAggregateInput
  }

  export type monedasWhereUniqueInput = Prisma.AtLeast<{
    id_moneda?: number
    AND?: monedasWhereInput | monedasWhereInput[]
    OR?: monedasWhereInput[]
    NOT?: monedasWhereInput | monedasWhereInput[]
    nombre?: StringFilter<"monedas"> | string
    tasa_cambio?: DecimalFilter<"monedas"> | Decimal | DecimalJsLike | number | string
    facturas?: FacturasListRelationFilter
    productos_terminados?: Productos_terminadosListRelationFilter
  }, "id_moneda">

  export type monedasOrderByWithAggregationInput = {
    id_moneda?: SortOrder
    nombre?: SortOrder
    tasa_cambio?: SortOrder
    _count?: monedasCountOrderByAggregateInput
    _avg?: monedasAvgOrderByAggregateInput
    _max?: monedasMaxOrderByAggregateInput
    _min?: monedasMinOrderByAggregateInput
    _sum?: monedasSumOrderByAggregateInput
  }

  export type monedasScalarWhereWithAggregatesInput = {
    AND?: monedasScalarWhereWithAggregatesInput | monedasScalarWhereWithAggregatesInput[]
    OR?: monedasScalarWhereWithAggregatesInput[]
    NOT?: monedasScalarWhereWithAggregatesInput | monedasScalarWhereWithAggregatesInput[]
    id_moneda?: IntWithAggregatesFilter<"monedas"> | number
    nombre?: StringWithAggregatesFilter<"monedas"> | string
    tasa_cambio?: DecimalWithAggregatesFilter<"monedas"> | Decimal | DecimalJsLike | number | string
  }

  export type productos_terminadosWhereInput = {
    AND?: productos_terminadosWhereInput | productos_terminadosWhereInput[]
    OR?: productos_terminadosWhereInput[]
    NOT?: productos_terminadosWhereInput | productos_terminadosWhereInput[]
    id_producto?: IntFilter<"productos_terminados"> | number
    nombre?: StringFilter<"productos_terminados"> | string
    precio_venta?: DecimalFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string
    stock_actual?: DecimalNullableFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFilter<"productos_terminados"> | string
    precio_produccion?: DecimalFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string
    id_moneda?: IntFilter<"productos_terminados"> | number
    id_producto_especial?: IntNullableFilter<"productos_terminados"> | number | null
    kardex_productos?: Kardex_productosListRelationFilter
    monedas?: XOR<MonedasScalarRelationFilter, monedasWhereInput>
    recetas?: RecetasListRelationFilter
    producto_especial?: XOR<Productos_especialesNullableScalarRelationFilter, productos_especialesWhereInput> | null
  }

  export type productos_terminadosOrderByWithRelationInput = {
    id_producto?: SortOrder
    nombre?: SortOrder
    precio_venta?: SortOrder
    stock_actual?: SortOrderInput | SortOrder
    codigo_barras?: SortOrder
    precio_produccion?: SortOrder
    id_moneda?: SortOrder
    id_producto_especial?: SortOrderInput | SortOrder
    kardex_productos?: kardex_productosOrderByRelationAggregateInput
    monedas?: monedasOrderByWithRelationInput
    recetas?: recetasOrderByRelationAggregateInput
    producto_especial?: productos_especialesOrderByWithRelationInput
  }

  export type productos_terminadosWhereUniqueInput = Prisma.AtLeast<{
    id_producto?: number
    id_producto_especial?: number
    AND?: productos_terminadosWhereInput | productos_terminadosWhereInput[]
    OR?: productos_terminadosWhereInput[]
    NOT?: productos_terminadosWhereInput | productos_terminadosWhereInput[]
    nombre?: StringFilter<"productos_terminados"> | string
    precio_venta?: DecimalFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string
    stock_actual?: DecimalNullableFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFilter<"productos_terminados"> | string
    precio_produccion?: DecimalFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string
    id_moneda?: IntFilter<"productos_terminados"> | number
    kardex_productos?: Kardex_productosListRelationFilter
    monedas?: XOR<MonedasScalarRelationFilter, monedasWhereInput>
    recetas?: RecetasListRelationFilter
    producto_especial?: XOR<Productos_especialesNullableScalarRelationFilter, productos_especialesWhereInput> | null
  }, "id_producto" | "id_producto_especial">

  export type productos_terminadosOrderByWithAggregationInput = {
    id_producto?: SortOrder
    nombre?: SortOrder
    precio_venta?: SortOrder
    stock_actual?: SortOrderInput | SortOrder
    codigo_barras?: SortOrder
    precio_produccion?: SortOrder
    id_moneda?: SortOrder
    id_producto_especial?: SortOrderInput | SortOrder
    _count?: productos_terminadosCountOrderByAggregateInput
    _avg?: productos_terminadosAvgOrderByAggregateInput
    _max?: productos_terminadosMaxOrderByAggregateInput
    _min?: productos_terminadosMinOrderByAggregateInput
    _sum?: productos_terminadosSumOrderByAggregateInput
  }

  export type productos_terminadosScalarWhereWithAggregatesInput = {
    AND?: productos_terminadosScalarWhereWithAggregatesInput | productos_terminadosScalarWhereWithAggregatesInput[]
    OR?: productos_terminadosScalarWhereWithAggregatesInput[]
    NOT?: productos_terminadosScalarWhereWithAggregatesInput | productos_terminadosScalarWhereWithAggregatesInput[]
    id_producto?: IntWithAggregatesFilter<"productos_terminados"> | number
    nombre?: StringWithAggregatesFilter<"productos_terminados"> | string
    precio_venta?: DecimalWithAggregatesFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string
    stock_actual?: DecimalNullableWithAggregatesFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringWithAggregatesFilter<"productos_terminados"> | string
    precio_produccion?: DecimalWithAggregatesFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string
    id_moneda?: IntWithAggregatesFilter<"productos_terminados"> | number
    id_producto_especial?: IntNullableWithAggregatesFilter<"productos_terminados"> | number | null
  }

  export type productos_especialesWhereInput = {
    AND?: productos_especialesWhereInput | productos_especialesWhereInput[]
    OR?: productos_especialesWhereInput[]
    NOT?: productos_especialesWhereInput | productos_especialesWhereInput[]
    id_producto_especial?: IntFilter<"productos_especiales"> | number
    id_producto?: IntFilter<"productos_especiales"> | number
    rendimiento?: DecimalFilter<"productos_especiales"> | Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: IntNullableFilter<"productos_especiales"> | number | null
    producto_terminado?: XOR<Productos_terminadosNullableScalarRelationFilter, productos_terminadosWhereInput> | null
    recetas?: RecetasListRelationFilter
    unidad?: XOR<UnidadesmedidaNullableScalarRelationFilter, unidadesmedidaWhereInput> | null
  }

  export type productos_especialesOrderByWithRelationInput = {
    id_producto_especial?: SortOrder
    id_producto?: SortOrder
    rendimiento?: SortOrder
    unidad_rendimiento?: SortOrderInput | SortOrder
    producto_terminado?: productos_terminadosOrderByWithRelationInput
    recetas?: recetasOrderByRelationAggregateInput
    unidad?: unidadesmedidaOrderByWithRelationInput
  }

  export type productos_especialesWhereUniqueInput = Prisma.AtLeast<{
    id_producto_especial?: number
    AND?: productos_especialesWhereInput | productos_especialesWhereInput[]
    OR?: productos_especialesWhereInput[]
    NOT?: productos_especialesWhereInput | productos_especialesWhereInput[]
    id_producto?: IntFilter<"productos_especiales"> | number
    rendimiento?: DecimalFilter<"productos_especiales"> | Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: IntNullableFilter<"productos_especiales"> | number | null
    producto_terminado?: XOR<Productos_terminadosNullableScalarRelationFilter, productos_terminadosWhereInput> | null
    recetas?: RecetasListRelationFilter
    unidad?: XOR<UnidadesmedidaNullableScalarRelationFilter, unidadesmedidaWhereInput> | null
  }, "id_producto_especial">

  export type productos_especialesOrderByWithAggregationInput = {
    id_producto_especial?: SortOrder
    id_producto?: SortOrder
    rendimiento?: SortOrder
    unidad_rendimiento?: SortOrderInput | SortOrder
    _count?: productos_especialesCountOrderByAggregateInput
    _avg?: productos_especialesAvgOrderByAggregateInput
    _max?: productos_especialesMaxOrderByAggregateInput
    _min?: productos_especialesMinOrderByAggregateInput
    _sum?: productos_especialesSumOrderByAggregateInput
  }

  export type productos_especialesScalarWhereWithAggregatesInput = {
    AND?: productos_especialesScalarWhereWithAggregatesInput | productos_especialesScalarWhereWithAggregatesInput[]
    OR?: productos_especialesScalarWhereWithAggregatesInput[]
    NOT?: productos_especialesScalarWhereWithAggregatesInput | productos_especialesScalarWhereWithAggregatesInput[]
    id_producto_especial?: IntWithAggregatesFilter<"productos_especiales"> | number
    id_producto?: IntWithAggregatesFilter<"productos_especiales"> | number
    rendimiento?: DecimalWithAggregatesFilter<"productos_especiales"> | Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: IntNullableWithAggregatesFilter<"productos_especiales"> | number | null
  }

  export type proveedoresWhereInput = {
    AND?: proveedoresWhereInput | proveedoresWhereInput[]
    OR?: proveedoresWhereInput[]
    NOT?: proveedoresWhereInput | proveedoresWhereInput[]
    id_proveedor?: IntFilter<"proveedores"> | number
    rif?: StringFilter<"proveedores"> | string
    nombre?: StringFilter<"proveedores"> | string
    contacto?: StringNullableFilter<"proveedores"> | string | null
    telefono?: StringNullableFilter<"proveedores"> | string | null
    direccion?: StringNullableFilter<"proveedores"> | string | null
    empresa_nombre?: StringFilter<"proveedores"> | string
    fecha_registro?: DateTimeNullableFilter<"proveedores"> | Date | string | null
    facturas?: FacturasListRelationFilter
  }

  export type proveedoresOrderByWithRelationInput = {
    id_proveedor?: SortOrder
    rif?: SortOrder
    nombre?: SortOrder
    contacto?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    empresa_nombre?: SortOrder
    fecha_registro?: SortOrderInput | SortOrder
    facturas?: facturasOrderByRelationAggregateInput
  }

  export type proveedoresWhereUniqueInput = Prisma.AtLeast<{
    id_proveedor?: number
    rif?: string
    empresa_nombre?: string
    AND?: proveedoresWhereInput | proveedoresWhereInput[]
    OR?: proveedoresWhereInput[]
    NOT?: proveedoresWhereInput | proveedoresWhereInput[]
    nombre?: StringFilter<"proveedores"> | string
    contacto?: StringNullableFilter<"proveedores"> | string | null
    telefono?: StringNullableFilter<"proveedores"> | string | null
    direccion?: StringNullableFilter<"proveedores"> | string | null
    fecha_registro?: DateTimeNullableFilter<"proveedores"> | Date | string | null
    facturas?: FacturasListRelationFilter
  }, "id_proveedor" | "rif" | "empresa_nombre">

  export type proveedoresOrderByWithAggregationInput = {
    id_proveedor?: SortOrder
    rif?: SortOrder
    nombre?: SortOrder
    contacto?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    empresa_nombre?: SortOrder
    fecha_registro?: SortOrderInput | SortOrder
    _count?: proveedoresCountOrderByAggregateInput
    _avg?: proveedoresAvgOrderByAggregateInput
    _max?: proveedoresMaxOrderByAggregateInput
    _min?: proveedoresMinOrderByAggregateInput
    _sum?: proveedoresSumOrderByAggregateInput
  }

  export type proveedoresScalarWhereWithAggregatesInput = {
    AND?: proveedoresScalarWhereWithAggregatesInput | proveedoresScalarWhereWithAggregatesInput[]
    OR?: proveedoresScalarWhereWithAggregatesInput[]
    NOT?: proveedoresScalarWhereWithAggregatesInput | proveedoresScalarWhereWithAggregatesInput[]
    id_proveedor?: IntWithAggregatesFilter<"proveedores"> | number
    rif?: StringWithAggregatesFilter<"proveedores"> | string
    nombre?: StringWithAggregatesFilter<"proveedores"> | string
    contacto?: StringNullableWithAggregatesFilter<"proveedores"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"proveedores"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"proveedores"> | string | null
    empresa_nombre?: StringWithAggregatesFilter<"proveedores"> | string
    fecha_registro?: DateTimeNullableWithAggregatesFilter<"proveedores"> | Date | string | null
  }

  export type recetasWhereInput = {
    AND?: recetasWhereInput | recetasWhereInput[]
    OR?: recetasWhereInput[]
    NOT?: recetasWhereInput | recetasWhereInput[]
    id_receta?: IntFilter<"recetas"> | number
    id_producto?: IntNullableFilter<"recetas"> | number | null
    id_materia_prima?: IntNullableFilter<"recetas"> | number | null
    id_producto_especial?: IntNullableFilter<"recetas"> | number | null
    cantidad_requerida?: DecimalFilter<"recetas"> | Decimal | DecimalJsLike | number | string
    unidad_medida?: IntNullableFilter<"recetas"> | number | null
    disponible?: BoolFilter<"recetas"> | boolean
    unidadesmedida?: XOR<UnidadesmedidaNullableScalarRelationFilter, unidadesmedidaWhereInput> | null
    materia_prima?: XOR<Materia_primaNullableScalarRelationFilter, materia_primaWhereInput> | null
    productos_terminados?: XOR<Productos_terminadosNullableScalarRelationFilter, productos_terminadosWhereInput> | null
    productos_especiales?: XOR<Productos_especialesNullableScalarRelationFilter, productos_especialesWhereInput> | null
  }

  export type recetasOrderByWithRelationInput = {
    id_receta?: SortOrder
    id_producto?: SortOrderInput | SortOrder
    id_materia_prima?: SortOrderInput | SortOrder
    id_producto_especial?: SortOrderInput | SortOrder
    cantidad_requerida?: SortOrder
    unidad_medida?: SortOrderInput | SortOrder
    disponible?: SortOrder
    unidadesmedida?: unidadesmedidaOrderByWithRelationInput
    materia_prima?: materia_primaOrderByWithRelationInput
    productos_terminados?: productos_terminadosOrderByWithRelationInput
    productos_especiales?: productos_especialesOrderByWithRelationInput
  }

  export type recetasWhereUniqueInput = Prisma.AtLeast<{
    id_receta?: number
    AND?: recetasWhereInput | recetasWhereInput[]
    OR?: recetasWhereInput[]
    NOT?: recetasWhereInput | recetasWhereInput[]
    id_producto?: IntNullableFilter<"recetas"> | number | null
    id_materia_prima?: IntNullableFilter<"recetas"> | number | null
    id_producto_especial?: IntNullableFilter<"recetas"> | number | null
    cantidad_requerida?: DecimalFilter<"recetas"> | Decimal | DecimalJsLike | number | string
    unidad_medida?: IntNullableFilter<"recetas"> | number | null
    disponible?: BoolFilter<"recetas"> | boolean
    unidadesmedida?: XOR<UnidadesmedidaNullableScalarRelationFilter, unidadesmedidaWhereInput> | null
    materia_prima?: XOR<Materia_primaNullableScalarRelationFilter, materia_primaWhereInput> | null
    productos_terminados?: XOR<Productos_terminadosNullableScalarRelationFilter, productos_terminadosWhereInput> | null
    productos_especiales?: XOR<Productos_especialesNullableScalarRelationFilter, productos_especialesWhereInput> | null
  }, "id_receta">

  export type recetasOrderByWithAggregationInput = {
    id_receta?: SortOrder
    id_producto?: SortOrderInput | SortOrder
    id_materia_prima?: SortOrderInput | SortOrder
    id_producto_especial?: SortOrderInput | SortOrder
    cantidad_requerida?: SortOrder
    unidad_medida?: SortOrderInput | SortOrder
    disponible?: SortOrder
    _count?: recetasCountOrderByAggregateInput
    _avg?: recetasAvgOrderByAggregateInput
    _max?: recetasMaxOrderByAggregateInput
    _min?: recetasMinOrderByAggregateInput
    _sum?: recetasSumOrderByAggregateInput
  }

  export type recetasScalarWhereWithAggregatesInput = {
    AND?: recetasScalarWhereWithAggregatesInput | recetasScalarWhereWithAggregatesInput[]
    OR?: recetasScalarWhereWithAggregatesInput[]
    NOT?: recetasScalarWhereWithAggregatesInput | recetasScalarWhereWithAggregatesInput[]
    id_receta?: IntWithAggregatesFilter<"recetas"> | number
    id_producto?: IntNullableWithAggregatesFilter<"recetas"> | number | null
    id_materia_prima?: IntNullableWithAggregatesFilter<"recetas"> | number | null
    id_producto_especial?: IntNullableWithAggregatesFilter<"recetas"> | number | null
    cantidad_requerida?: DecimalWithAggregatesFilter<"recetas"> | Decimal | DecimalJsLike | number | string
    unidad_medida?: IntNullableWithAggregatesFilter<"recetas"> | number | null
    disponible?: BoolWithAggregatesFilter<"recetas"> | boolean
  }

  export type unidadesmedidaWhereInput = {
    AND?: unidadesmedidaWhereInput | unidadesmedidaWhereInput[]
    OR?: unidadesmedidaWhereInput[]
    NOT?: unidadesmedidaWhereInput | unidadesmedidaWhereInput[]
    id?: IntFilter<"unidadesmedida"> | number
    nombre?: StringFilter<"unidadesmedida"> | string
    factor_conversion?: DecimalFilter<"unidadesmedida"> | Decimal | DecimalJsLike | number | string
    detalle_factura?: Detalle_facturaListRelationFilter
    recetas?: RecetasListRelationFilter
    materia_prima?: Materia_primaListRelationFilter
    productos_especiales?: Productos_especialesListRelationFilter
  }

  export type unidadesmedidaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    factor_conversion?: SortOrder
    detalle_factura?: detalle_facturaOrderByRelationAggregateInput
    recetas?: recetasOrderByRelationAggregateInput
    materia_prima?: materia_primaOrderByRelationAggregateInput
    productos_especiales?: productos_especialesOrderByRelationAggregateInput
  }

  export type unidadesmedidaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: unidadesmedidaWhereInput | unidadesmedidaWhereInput[]
    OR?: unidadesmedidaWhereInput[]
    NOT?: unidadesmedidaWhereInput | unidadesmedidaWhereInput[]
    factor_conversion?: DecimalFilter<"unidadesmedida"> | Decimal | DecimalJsLike | number | string
    detalle_factura?: Detalle_facturaListRelationFilter
    recetas?: RecetasListRelationFilter
    materia_prima?: Materia_primaListRelationFilter
    productos_especiales?: Productos_especialesListRelationFilter
  }, "id" | "nombre">

  export type unidadesmedidaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    factor_conversion?: SortOrder
    _count?: unidadesmedidaCountOrderByAggregateInput
    _avg?: unidadesmedidaAvgOrderByAggregateInput
    _max?: unidadesmedidaMaxOrderByAggregateInput
    _min?: unidadesmedidaMinOrderByAggregateInput
    _sum?: unidadesmedidaSumOrderByAggregateInput
  }

  export type unidadesmedidaScalarWhereWithAggregatesInput = {
    AND?: unidadesmedidaScalarWhereWithAggregatesInput | unidadesmedidaScalarWhereWithAggregatesInput[]
    OR?: unidadesmedidaScalarWhereWithAggregatesInput[]
    NOT?: unidadesmedidaScalarWhereWithAggregatesInput | unidadesmedidaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"unidadesmedida"> | number
    nombre?: StringWithAggregatesFilter<"unidadesmedida"> | string
    factor_conversion?: DecimalWithAggregatesFilter<"unidadesmedida"> | Decimal | DecimalJsLike | number | string
  }

  export type detalle_facturaCreateInput = {
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    facturas?: facturasCreateNestedOneWithoutDetalle_facturaInput
    materia_prima?: materia_primaCreateNestedOneWithoutDetalle_facturaInput
    unidadesmedida?: unidadesmedidaCreateNestedOneWithoutDetalle_facturaInput
  }

  export type detalle_facturaUncheckedCreateInput = {
    id_detalle?: number
    id_factura?: number | null
    id_materia_prima?: number | null
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    unidad_medida?: number | null
  }

  export type detalle_facturaUpdateInput = {
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    facturas?: facturasUpdateOneWithoutDetalle_facturaNestedInput
    materia_prima?: materia_primaUpdateOneWithoutDetalle_facturaNestedInput
    unidadesmedida?: unidadesmedidaUpdateOneWithoutDetalle_facturaNestedInput
  }

  export type detalle_facturaUncheckedUpdateInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_factura?: NullableIntFieldUpdateOperationsInput | number | null
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type detalle_facturaCreateManyInput = {
    id_detalle?: number
    id_factura?: number | null
    id_materia_prima?: number | null
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    unidad_medida?: number | null
  }

  export type detalle_facturaUpdateManyMutationInput = {
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_facturaUncheckedUpdateManyInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_factura?: NullableIntFieldUpdateOperationsInput | number | null
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type facturasCreateInput = {
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
    detalle_factura?: detalle_facturaCreateNestedManyWithoutFacturasInput
    monedas: monedasCreateNestedOneWithoutFacturasInput
    proveedores?: proveedoresCreateNestedOneWithoutFacturasInput
  }

  export type facturasUncheckedCreateInput = {
    id_factura?: number
    id_proveedor?: number | null
    id_moneda: number
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutFacturasInput
  }

  export type facturasUpdateInput = {
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    detalle_factura?: detalle_facturaUpdateManyWithoutFacturasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutFacturasNestedInput
    proveedores?: proveedoresUpdateOneWithoutFacturasNestedInput
  }

  export type facturasUncheckedUpdateInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    id_proveedor?: NullableIntFieldUpdateOperationsInput | number | null
    id_moneda?: IntFieldUpdateOperationsInput | number
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutFacturasNestedInput
  }

  export type facturasCreateManyInput = {
    id_factura?: number
    id_proveedor?: number | null
    id_moneda: number
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
  }

  export type facturasUpdateManyMutationInput = {
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type facturasUncheckedUpdateManyInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    id_proveedor?: NullableIntFieldUpdateOperationsInput | number | null
    id_moneda?: IntFieldUpdateOperationsInput | number
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversionFactorCreateInput = {
    unidadOrigen: string
    unidadDestino: string
    factorConversion: number
  }

  export type ConversionFactorUncheckedCreateInput = {
    id?: number
    unidadOrigen: string
    unidadDestino: string
    factorConversion: number
  }

  export type ConversionFactorUpdateInput = {
    unidadOrigen?: StringFieldUpdateOperationsInput | string
    unidadDestino?: StringFieldUpdateOperationsInput | string
    factorConversion?: FloatFieldUpdateOperationsInput | number
  }

  export type ConversionFactorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unidadOrigen?: StringFieldUpdateOperationsInput | string
    unidadDestino?: StringFieldUpdateOperationsInput | string
    factorConversion?: FloatFieldUpdateOperationsInput | number
  }

  export type ConversionFactorCreateManyInput = {
    id?: number
    unidadOrigen: string
    unidadDestino: string
    factorConversion: number
  }

  export type ConversionFactorUpdateManyMutationInput = {
    unidadOrigen?: StringFieldUpdateOperationsInput | string
    unidadDestino?: StringFieldUpdateOperationsInput | string
    factorConversion?: FloatFieldUpdateOperationsInput | number
  }

  export type ConversionFactorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unidadOrigen?: StringFieldUpdateOperationsInput | string
    unidadDestino?: StringFieldUpdateOperationsInput | string
    factorConversion?: FloatFieldUpdateOperationsInput | number
  }

  export type kardex_materia_primaCreateInput = {
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_unitario: Decimal | DecimalJsLike | number | string
    costo_total: Decimal | DecimalJsLike | number | string
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    observaciones?: string | null
    materia_prima?: materia_primaCreateNestedOneWithoutKardex_materia_primaInput
  }

  export type kardex_materia_primaUncheckedCreateInput = {
    id_kardex?: number
    id_materia_prima?: number | null
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_unitario: Decimal | DecimalJsLike | number | string
    costo_total: Decimal | DecimalJsLike | number | string
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    observaciones?: string | null
  }

  export type kardex_materia_primaUpdateInput = {
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    materia_prima?: materia_primaUpdateOneWithoutKardex_materia_primaNestedInput
  }

  export type kardex_materia_primaUncheckedUpdateInput = {
    id_kardex?: IntFieldUpdateOperationsInput | number
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kardex_materia_primaCreateManyInput = {
    id_kardex?: number
    id_materia_prima?: number | null
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_unitario: Decimal | DecimalJsLike | number | string
    costo_total: Decimal | DecimalJsLike | number | string
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    observaciones?: string | null
  }

  export type kardex_materia_primaUpdateManyMutationInput = {
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kardex_materia_primaUncheckedUpdateManyInput = {
    id_kardex?: IntFieldUpdateOperationsInput | number
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kardex_productosCreateInput = {
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_produccion?: Decimal | DecimalJsLike | number | string | null
    precio_venta?: Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    referencias_archivos?: kardex_productosCreatereferencias_archivosInput | string[]
    observaciones?: string | null
    productos_terminados?: productos_terminadosCreateNestedOneWithoutKardex_productosInput
  }

  export type kardex_productosUncheckedCreateInput = {
    id_kardex?: number
    id_producto?: number | null
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_produccion?: Decimal | DecimalJsLike | number | string | null
    precio_venta?: Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    referencias_archivos?: kardex_productosCreatereferencias_archivosInput | string[]
    observaciones?: string | null
  }

  export type kardex_productosUpdateInput = {
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_produccion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    precio_venta?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    referencias_archivos?: kardex_productosUpdatereferencias_archivosInput | string[]
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    productos_terminados?: productos_terminadosUpdateOneWithoutKardex_productosNestedInput
  }

  export type kardex_productosUncheckedUpdateInput = {
    id_kardex?: IntFieldUpdateOperationsInput | number
    id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_produccion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    precio_venta?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    referencias_archivos?: kardex_productosUpdatereferencias_archivosInput | string[]
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kardex_productosCreateManyInput = {
    id_kardex?: number
    id_producto?: number | null
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_produccion?: Decimal | DecimalJsLike | number | string | null
    precio_venta?: Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    referencias_archivos?: kardex_productosCreatereferencias_archivosInput | string[]
    observaciones?: string | null
  }

  export type kardex_productosUpdateManyMutationInput = {
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_produccion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    precio_venta?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    referencias_archivos?: kardex_productosUpdatereferencias_archivosInput | string[]
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kardex_productosUncheckedUpdateManyInput = {
    id_kardex?: IntFieldUpdateOperationsInput | number
    id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_produccion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    precio_venta?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    referencias_archivos?: kardex_productosUpdatereferencias_archivosInput | string[]
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type materia_primaCreateInput = {
    nombre: string
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
    detalle_factura?: detalle_facturaCreateNestedManyWithoutMateria_primaInput
    kardex_materia_prima?: kardex_materia_primaCreateNestedManyWithoutMateria_primaInput
    recetas?: recetasCreateNestedManyWithoutMateria_primaInput
    unidad_medida: unidadesmedidaCreateNestedOneWithoutMateria_primaInput
  }

  export type materia_primaUncheckedCreateInput = {
    id_materia_prima?: number
    nombre: string
    unidad_medida_id: number
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutMateria_primaInput
    kardex_materia_prima?: kardex_materia_primaUncheckedCreateNestedManyWithoutMateria_primaInput
    recetas?: recetasUncheckedCreateNestedManyWithoutMateria_primaInput
  }

  export type materia_primaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    detalle_factura?: detalle_facturaUpdateManyWithoutMateria_primaNestedInput
    kardex_materia_prima?: kardex_materia_primaUpdateManyWithoutMateria_primaNestedInput
    recetas?: recetasUpdateManyWithoutMateria_primaNestedInput
    unidad_medida?: unidadesmedidaUpdateOneRequiredWithoutMateria_primaNestedInput
  }

  export type materia_primaUncheckedUpdateInput = {
    id_materia_prima?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad_medida_id?: IntFieldUpdateOperationsInput | number
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutMateria_primaNestedInput
    kardex_materia_prima?: kardex_materia_primaUncheckedUpdateManyWithoutMateria_primaNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutMateria_primaNestedInput
  }

  export type materia_primaCreateManyInput = {
    id_materia_prima?: number
    nombre: string
    unidad_medida_id: number
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
  }

  export type materia_primaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type materia_primaUncheckedUpdateManyInput = {
    id_materia_prima?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad_medida_id?: IntFieldUpdateOperationsInput | number
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type monedasCreateInput = {
    nombre: string
    tasa_cambio: Decimal | DecimalJsLike | number | string
    facturas?: facturasCreateNestedManyWithoutMonedasInput
    productos_terminados?: productos_terminadosCreateNestedManyWithoutMonedasInput
  }

  export type monedasUncheckedCreateInput = {
    id_moneda?: number
    nombre: string
    tasa_cambio: Decimal | DecimalJsLike | number | string
    facturas?: facturasUncheckedCreateNestedManyWithoutMonedasInput
    productos_terminados?: productos_terminadosUncheckedCreateNestedManyWithoutMonedasInput
  }

  export type monedasUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tasa_cambio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facturas?: facturasUpdateManyWithoutMonedasNestedInput
    productos_terminados?: productos_terminadosUpdateManyWithoutMonedasNestedInput
  }

  export type monedasUncheckedUpdateInput = {
    id_moneda?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tasa_cambio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facturas?: facturasUncheckedUpdateManyWithoutMonedasNestedInput
    productos_terminados?: productos_terminadosUncheckedUpdateManyWithoutMonedasNestedInput
  }

  export type monedasCreateManyInput = {
    id_moneda?: number
    nombre: string
    tasa_cambio: Decimal | DecimalJsLike | number | string
  }

  export type monedasUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tasa_cambio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type monedasUncheckedUpdateManyInput = {
    id_moneda?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tasa_cambio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type productos_terminadosCreateInput = {
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    kardex_productos?: kardex_productosCreateNestedManyWithoutProductos_terminadosInput
    monedas: monedasCreateNestedOneWithoutProductos_terminadosInput
    recetas?: recetasCreateNestedManyWithoutProductos_terminadosInput
    producto_especial?: productos_especialesCreateNestedOneWithoutProducto_terminadoInput
  }

  export type productos_terminadosUncheckedCreateInput = {
    id_producto?: number
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    id_moneda: number
    id_producto_especial?: number | null
    kardex_productos?: kardex_productosUncheckedCreateNestedManyWithoutProductos_terminadosInput
    recetas?: recetasUncheckedCreateNestedManyWithoutProductos_terminadosInput
  }

  export type productos_terminadosUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kardex_productos?: kardex_productosUpdateManyWithoutProductos_terminadosNestedInput
    monedas?: monedasUpdateOneRequiredWithoutProductos_terminadosNestedInput
    recetas?: recetasUpdateManyWithoutProductos_terminadosNestedInput
    producto_especial?: productos_especialesUpdateOneWithoutProducto_terminadoNestedInput
  }

  export type productos_terminadosUncheckedUpdateInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_moneda?: IntFieldUpdateOperationsInput | number
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    kardex_productos?: kardex_productosUncheckedUpdateManyWithoutProductos_terminadosNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutProductos_terminadosNestedInput
  }

  export type productos_terminadosCreateManyInput = {
    id_producto?: number
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    id_moneda: number
    id_producto_especial?: number | null
  }

  export type productos_terminadosUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type productos_terminadosUncheckedUpdateManyInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_moneda?: IntFieldUpdateOperationsInput | number
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type productos_especialesCreateInput = {
    id_producto: number
    rendimiento?: Decimal | DecimalJsLike | number | string
    producto_terminado?: productos_terminadosCreateNestedOneWithoutProducto_especialInput
    recetas?: recetasCreateNestedManyWithoutProductos_especialesInput
    unidad?: unidadesmedidaCreateNestedOneWithoutProductos_especialesInput
  }

  export type productos_especialesUncheckedCreateInput = {
    id_producto_especial?: number
    id_producto: number
    rendimiento?: Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: number | null
    producto_terminado?: productos_terminadosUncheckedCreateNestedOneWithoutProducto_especialInput
    recetas?: recetasUncheckedCreateNestedManyWithoutProductos_especialesInput
  }

  export type productos_especialesUpdateInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    producto_terminado?: productos_terminadosUpdateOneWithoutProducto_especialNestedInput
    recetas?: recetasUpdateManyWithoutProductos_especialesNestedInput
    unidad?: unidadesmedidaUpdateOneWithoutProductos_especialesNestedInput
  }

  export type productos_especialesUncheckedUpdateInput = {
    id_producto_especial?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: NullableIntFieldUpdateOperationsInput | number | null
    producto_terminado?: productos_terminadosUncheckedUpdateOneWithoutProducto_especialNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutProductos_especialesNestedInput
  }

  export type productos_especialesCreateManyInput = {
    id_producto_especial?: number
    id_producto: number
    rendimiento?: Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: number | null
  }

  export type productos_especialesUpdateManyMutationInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type productos_especialesUncheckedUpdateManyInput = {
    id_producto_especial?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type proveedoresCreateInput = {
    rif: string
    nombre: string
    contacto?: string | null
    telefono?: string | null
    direccion?: string | null
    empresa_nombre: string
    fecha_registro?: Date | string | null
    facturas?: facturasCreateNestedManyWithoutProveedoresInput
  }

  export type proveedoresUncheckedCreateInput = {
    id_proveedor?: number
    rif: string
    nombre: string
    contacto?: string | null
    telefono?: string | null
    direccion?: string | null
    empresa_nombre: string
    fecha_registro?: Date | string | null
    facturas?: facturasUncheckedCreateNestedManyWithoutProveedoresInput
  }

  export type proveedoresUpdateInput = {
    rif?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    contacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    empresa_nombre?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facturas?: facturasUpdateManyWithoutProveedoresNestedInput
  }

  export type proveedoresUncheckedUpdateInput = {
    id_proveedor?: IntFieldUpdateOperationsInput | number
    rif?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    contacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    empresa_nombre?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facturas?: facturasUncheckedUpdateManyWithoutProveedoresNestedInput
  }

  export type proveedoresCreateManyInput = {
    id_proveedor?: number
    rif: string
    nombre: string
    contacto?: string | null
    telefono?: string | null
    direccion?: string | null
    empresa_nombre: string
    fecha_registro?: Date | string | null
  }

  export type proveedoresUpdateManyMutationInput = {
    rif?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    contacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    empresa_nombre?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type proveedoresUncheckedUpdateManyInput = {
    id_proveedor?: IntFieldUpdateOperationsInput | number
    rif?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    contacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    empresa_nombre?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type recetasCreateInput = {
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    disponible?: boolean
    unidadesmedida?: unidadesmedidaCreateNestedOneWithoutRecetasInput
    materia_prima?: materia_primaCreateNestedOneWithoutRecetasInput
    productos_terminados?: productos_terminadosCreateNestedOneWithoutRecetasInput
    productos_especiales?: productos_especialesCreateNestedOneWithoutRecetasInput
  }

  export type recetasUncheckedCreateInput = {
    id_receta?: number
    id_producto?: number | null
    id_materia_prima?: number | null
    id_producto_especial?: number | null
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    unidad_medida?: number | null
    disponible?: boolean
  }

  export type recetasUpdateInput = {
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    unidadesmedida?: unidadesmedidaUpdateOneWithoutRecetasNestedInput
    materia_prima?: materia_primaUpdateOneWithoutRecetasNestedInput
    productos_terminados?: productos_terminadosUpdateOneWithoutRecetasNestedInput
    productos_especiales?: productos_especialesUpdateOneWithoutRecetasNestedInput
  }

  export type recetasUncheckedUpdateInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recetasCreateManyInput = {
    id_receta?: number
    id_producto?: number | null
    id_materia_prima?: number | null
    id_producto_especial?: number | null
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    unidad_medida?: number | null
    disponible?: boolean
  }

  export type recetasUpdateManyMutationInput = {
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recetasUncheckedUpdateManyInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type unidadesmedidaCreateInput = {
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaCreateNestedManyWithoutUnidadesmedidaInput
    recetas?: recetasCreateNestedManyWithoutUnidadesmedidaInput
    materia_prima?: materia_primaCreateNestedManyWithoutUnidad_medidaInput
    productos_especiales?: productos_especialesCreateNestedManyWithoutUnidadInput
  }

  export type unidadesmedidaUncheckedCreateInput = {
    id?: number
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutUnidadesmedidaInput
    recetas?: recetasUncheckedCreateNestedManyWithoutUnidadesmedidaInput
    materia_prima?: materia_primaUncheckedCreateNestedManyWithoutUnidad_medidaInput
    productos_especiales?: productos_especialesUncheckedCreateNestedManyWithoutUnidadInput
  }

  export type unidadesmedidaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUpdateManyWithoutUnidadesmedidaNestedInput
    recetas?: recetasUpdateManyWithoutUnidadesmedidaNestedInput
    materia_prima?: materia_primaUpdateManyWithoutUnidad_medidaNestedInput
    productos_especiales?: productos_especialesUpdateManyWithoutUnidadNestedInput
  }

  export type unidadesmedidaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutUnidadesmedidaNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutUnidadesmedidaNestedInput
    materia_prima?: materia_primaUncheckedUpdateManyWithoutUnidad_medidaNestedInput
    productos_especiales?: productos_especialesUncheckedUpdateManyWithoutUnidadNestedInput
  }

  export type unidadesmedidaCreateManyInput = {
    id?: number
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
  }

  export type unidadesmedidaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type unidadesmedidaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type FacturasNullableScalarRelationFilter = {
    is?: facturasWhereInput | null
    isNot?: facturasWhereInput | null
  }

  export type Materia_primaNullableScalarRelationFilter = {
    is?: materia_primaWhereInput | null
    isNot?: materia_primaWhereInput | null
  }

  export type UnidadesmedidaNullableScalarRelationFilter = {
    is?: unidadesmedidaWhereInput | null
    isNot?: unidadesmedidaWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type detalle_facturaCountOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_factura?: SortOrder
    id_materia_prima?: SortOrder
    cantidad?: SortOrder
    precio_unitario?: SortOrder
    subtotal?: SortOrder
    unidad_medida?: SortOrder
  }

  export type detalle_facturaAvgOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_factura?: SortOrder
    id_materia_prima?: SortOrder
    cantidad?: SortOrder
    precio_unitario?: SortOrder
    subtotal?: SortOrder
    unidad_medida?: SortOrder
  }

  export type detalle_facturaMaxOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_factura?: SortOrder
    id_materia_prima?: SortOrder
    cantidad?: SortOrder
    precio_unitario?: SortOrder
    subtotal?: SortOrder
    unidad_medida?: SortOrder
  }

  export type detalle_facturaMinOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_factura?: SortOrder
    id_materia_prima?: SortOrder
    cantidad?: SortOrder
    precio_unitario?: SortOrder
    subtotal?: SortOrder
    unidad_medida?: SortOrder
  }

  export type detalle_facturaSumOrderByAggregateInput = {
    id_detalle?: SortOrder
    id_factura?: SortOrder
    id_materia_prima?: SortOrder
    cantidad?: SortOrder
    precio_unitario?: SortOrder
    subtotal?: SortOrder
    unidad_medida?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Detalle_facturaListRelationFilter = {
    every?: detalle_facturaWhereInput
    some?: detalle_facturaWhereInput
    none?: detalle_facturaWhereInput
  }

  export type MonedasScalarRelationFilter = {
    is?: monedasWhereInput
    isNot?: monedasWhereInput
  }

  export type ProveedoresNullableScalarRelationFilter = {
    is?: proveedoresWhereInput | null
    isNot?: proveedoresWhereInput | null
  }

  export type detalle_facturaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type facturasCountOrderByAggregateInput = {
    id_factura?: SortOrder
    id_proveedor?: SortOrder
    id_moneda?: SortOrder
    fecha_factura?: SortOrder
    total?: SortOrder
    estado?: SortOrder
    observaciones?: SortOrder
  }

  export type facturasAvgOrderByAggregateInput = {
    id_factura?: SortOrder
    id_proveedor?: SortOrder
    id_moneda?: SortOrder
    total?: SortOrder
  }

  export type facturasMaxOrderByAggregateInput = {
    id_factura?: SortOrder
    id_proveedor?: SortOrder
    id_moneda?: SortOrder
    fecha_factura?: SortOrder
    total?: SortOrder
    estado?: SortOrder
    observaciones?: SortOrder
  }

  export type facturasMinOrderByAggregateInput = {
    id_factura?: SortOrder
    id_proveedor?: SortOrder
    id_moneda?: SortOrder
    fecha_factura?: SortOrder
    total?: SortOrder
    estado?: SortOrder
    observaciones?: SortOrder
  }

  export type facturasSumOrderByAggregateInput = {
    id_factura?: SortOrder
    id_proveedor?: SortOrder
    id_moneda?: SortOrder
    total?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ConversionFactorUnidadOrigenUnidadDestinoCompoundUniqueInput = {
    unidadOrigen: string
    unidadDestino: string
  }

  export type ConversionFactorCountOrderByAggregateInput = {
    id?: SortOrder
    unidadOrigen?: SortOrder
    unidadDestino?: SortOrder
    factorConversion?: SortOrder
  }

  export type ConversionFactorAvgOrderByAggregateInput = {
    id?: SortOrder
    factorConversion?: SortOrder
  }

  export type ConversionFactorMaxOrderByAggregateInput = {
    id?: SortOrder
    unidadOrigen?: SortOrder
    unidadDestino?: SortOrder
    factorConversion?: SortOrder
  }

  export type ConversionFactorMinOrderByAggregateInput = {
    id?: SortOrder
    unidadOrigen?: SortOrder
    unidadDestino?: SortOrder
    factorConversion?: SortOrder
  }

  export type ConversionFactorSumOrderByAggregateInput = {
    id?: SortOrder
    factorConversion?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type kardex_materia_primaCountOrderByAggregateInput = {
    id_kardex?: SortOrder
    id_materia_prima?: SortOrder
    tipo_movimiento?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_unitario?: SortOrder
    costo_total?: SortOrder
    fecha_movimiento?: SortOrder
    referencia?: SortOrder
    observaciones?: SortOrder
  }

  export type kardex_materia_primaAvgOrderByAggregateInput = {
    id_kardex?: SortOrder
    id_materia_prima?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_unitario?: SortOrder
    costo_total?: SortOrder
  }

  export type kardex_materia_primaMaxOrderByAggregateInput = {
    id_kardex?: SortOrder
    id_materia_prima?: SortOrder
    tipo_movimiento?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_unitario?: SortOrder
    costo_total?: SortOrder
    fecha_movimiento?: SortOrder
    referencia?: SortOrder
    observaciones?: SortOrder
  }

  export type kardex_materia_primaMinOrderByAggregateInput = {
    id_kardex?: SortOrder
    id_materia_prima?: SortOrder
    tipo_movimiento?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_unitario?: SortOrder
    costo_total?: SortOrder
    fecha_movimiento?: SortOrder
    referencia?: SortOrder
    observaciones?: SortOrder
  }

  export type kardex_materia_primaSumOrderByAggregateInput = {
    id_kardex?: SortOrder
    id_materia_prima?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_unitario?: SortOrder
    costo_total?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Productos_terminadosNullableScalarRelationFilter = {
    is?: productos_terminadosWhereInput | null
    isNot?: productos_terminadosWhereInput | null
  }

  export type kardex_productosCountOrderByAggregateInput = {
    id_kardex?: SortOrder
    id_producto?: SortOrder
    tipo_movimiento?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_produccion?: SortOrder
    precio_venta?: SortOrder
    fecha_movimiento?: SortOrder
    referencia?: SortOrder
    referencias_archivos?: SortOrder
    observaciones?: SortOrder
  }

  export type kardex_productosAvgOrderByAggregateInput = {
    id_kardex?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_produccion?: SortOrder
    precio_venta?: SortOrder
  }

  export type kardex_productosMaxOrderByAggregateInput = {
    id_kardex?: SortOrder
    id_producto?: SortOrder
    tipo_movimiento?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_produccion?: SortOrder
    precio_venta?: SortOrder
    fecha_movimiento?: SortOrder
    referencia?: SortOrder
    observaciones?: SortOrder
  }

  export type kardex_productosMinOrderByAggregateInput = {
    id_kardex?: SortOrder
    id_producto?: SortOrder
    tipo_movimiento?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_produccion?: SortOrder
    precio_venta?: SortOrder
    fecha_movimiento?: SortOrder
    referencia?: SortOrder
    observaciones?: SortOrder
  }

  export type kardex_productosSumOrderByAggregateInput = {
    id_kardex?: SortOrder
    id_producto?: SortOrder
    cantidad?: SortOrder
    saldo?: SortOrder
    costo_produccion?: SortOrder
    precio_venta?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Kardex_materia_primaListRelationFilter = {
    every?: kardex_materia_primaWhereInput
    some?: kardex_materia_primaWhereInput
    none?: kardex_materia_primaWhereInput
  }

  export type RecetasListRelationFilter = {
    every?: recetasWhereInput
    some?: recetasWhereInput
    none?: recetasWhereInput
  }

  export type UnidadesmedidaScalarRelationFilter = {
    is?: unidadesmedidaWhereInput
    isNot?: unidadesmedidaWhereInput
  }

  export type kardex_materia_primaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type recetasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type materia_primaCountOrderByAggregateInput = {
    id_materia_prima?: SortOrder
    nombre?: SortOrder
    unidad_medida_id?: SortOrder
    costo_unitario?: SortOrder
    presentacion?: SortOrder
    stock_actual?: SortOrder
    codigo_barras?: SortOrder
    fecha_registro?: SortOrder
    disponible?: SortOrder
  }

  export type materia_primaAvgOrderByAggregateInput = {
    id_materia_prima?: SortOrder
    unidad_medida_id?: SortOrder
    costo_unitario?: SortOrder
    presentacion?: SortOrder
    stock_actual?: SortOrder
  }

  export type materia_primaMaxOrderByAggregateInput = {
    id_materia_prima?: SortOrder
    nombre?: SortOrder
    unidad_medida_id?: SortOrder
    costo_unitario?: SortOrder
    presentacion?: SortOrder
    stock_actual?: SortOrder
    codigo_barras?: SortOrder
    fecha_registro?: SortOrder
    disponible?: SortOrder
  }

  export type materia_primaMinOrderByAggregateInput = {
    id_materia_prima?: SortOrder
    nombre?: SortOrder
    unidad_medida_id?: SortOrder
    costo_unitario?: SortOrder
    presentacion?: SortOrder
    stock_actual?: SortOrder
    codigo_barras?: SortOrder
    fecha_registro?: SortOrder
    disponible?: SortOrder
  }

  export type materia_primaSumOrderByAggregateInput = {
    id_materia_prima?: SortOrder
    unidad_medida_id?: SortOrder
    costo_unitario?: SortOrder
    presentacion?: SortOrder
    stock_actual?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FacturasListRelationFilter = {
    every?: facturasWhereInput
    some?: facturasWhereInput
    none?: facturasWhereInput
  }

  export type Productos_terminadosListRelationFilter = {
    every?: productos_terminadosWhereInput
    some?: productos_terminadosWhereInput
    none?: productos_terminadosWhereInput
  }

  export type facturasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productos_terminadosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type monedasCountOrderByAggregateInput = {
    id_moneda?: SortOrder
    nombre?: SortOrder
    tasa_cambio?: SortOrder
  }

  export type monedasAvgOrderByAggregateInput = {
    id_moneda?: SortOrder
    tasa_cambio?: SortOrder
  }

  export type monedasMaxOrderByAggregateInput = {
    id_moneda?: SortOrder
    nombre?: SortOrder
    tasa_cambio?: SortOrder
  }

  export type monedasMinOrderByAggregateInput = {
    id_moneda?: SortOrder
    nombre?: SortOrder
    tasa_cambio?: SortOrder
  }

  export type monedasSumOrderByAggregateInput = {
    id_moneda?: SortOrder
    tasa_cambio?: SortOrder
  }

  export type Kardex_productosListRelationFilter = {
    every?: kardex_productosWhereInput
    some?: kardex_productosWhereInput
    none?: kardex_productosWhereInput
  }

  export type Productos_especialesNullableScalarRelationFilter = {
    is?: productos_especialesWhereInput | null
    isNot?: productos_especialesWhereInput | null
  }

  export type kardex_productosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productos_terminadosCountOrderByAggregateInput = {
    id_producto?: SortOrder
    nombre?: SortOrder
    precio_venta?: SortOrder
    stock_actual?: SortOrder
    codigo_barras?: SortOrder
    precio_produccion?: SortOrder
    id_moneda?: SortOrder
    id_producto_especial?: SortOrder
  }

  export type productos_terminadosAvgOrderByAggregateInput = {
    id_producto?: SortOrder
    precio_venta?: SortOrder
    stock_actual?: SortOrder
    precio_produccion?: SortOrder
    id_moneda?: SortOrder
    id_producto_especial?: SortOrder
  }

  export type productos_terminadosMaxOrderByAggregateInput = {
    id_producto?: SortOrder
    nombre?: SortOrder
    precio_venta?: SortOrder
    stock_actual?: SortOrder
    codigo_barras?: SortOrder
    precio_produccion?: SortOrder
    id_moneda?: SortOrder
    id_producto_especial?: SortOrder
  }

  export type productos_terminadosMinOrderByAggregateInput = {
    id_producto?: SortOrder
    nombre?: SortOrder
    precio_venta?: SortOrder
    stock_actual?: SortOrder
    codigo_barras?: SortOrder
    precio_produccion?: SortOrder
    id_moneda?: SortOrder
    id_producto_especial?: SortOrder
  }

  export type productos_terminadosSumOrderByAggregateInput = {
    id_producto?: SortOrder
    precio_venta?: SortOrder
    stock_actual?: SortOrder
    precio_produccion?: SortOrder
    id_moneda?: SortOrder
    id_producto_especial?: SortOrder
  }

  export type productos_especialesCountOrderByAggregateInput = {
    id_producto_especial?: SortOrder
    id_producto?: SortOrder
    rendimiento?: SortOrder
    unidad_rendimiento?: SortOrder
  }

  export type productos_especialesAvgOrderByAggregateInput = {
    id_producto_especial?: SortOrder
    id_producto?: SortOrder
    rendimiento?: SortOrder
    unidad_rendimiento?: SortOrder
  }

  export type productos_especialesMaxOrderByAggregateInput = {
    id_producto_especial?: SortOrder
    id_producto?: SortOrder
    rendimiento?: SortOrder
    unidad_rendimiento?: SortOrder
  }

  export type productos_especialesMinOrderByAggregateInput = {
    id_producto_especial?: SortOrder
    id_producto?: SortOrder
    rendimiento?: SortOrder
    unidad_rendimiento?: SortOrder
  }

  export type productos_especialesSumOrderByAggregateInput = {
    id_producto_especial?: SortOrder
    id_producto?: SortOrder
    rendimiento?: SortOrder
    unidad_rendimiento?: SortOrder
  }

  export type proveedoresCountOrderByAggregateInput = {
    id_proveedor?: SortOrder
    rif?: SortOrder
    nombre?: SortOrder
    contacto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    empresa_nombre?: SortOrder
    fecha_registro?: SortOrder
  }

  export type proveedoresAvgOrderByAggregateInput = {
    id_proveedor?: SortOrder
  }

  export type proveedoresMaxOrderByAggregateInput = {
    id_proveedor?: SortOrder
    rif?: SortOrder
    nombre?: SortOrder
    contacto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    empresa_nombre?: SortOrder
    fecha_registro?: SortOrder
  }

  export type proveedoresMinOrderByAggregateInput = {
    id_proveedor?: SortOrder
    rif?: SortOrder
    nombre?: SortOrder
    contacto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    empresa_nombre?: SortOrder
    fecha_registro?: SortOrder
  }

  export type proveedoresSumOrderByAggregateInput = {
    id_proveedor?: SortOrder
  }

  export type recetasCountOrderByAggregateInput = {
    id_receta?: SortOrder
    id_producto?: SortOrder
    id_materia_prima?: SortOrder
    id_producto_especial?: SortOrder
    cantidad_requerida?: SortOrder
    unidad_medida?: SortOrder
    disponible?: SortOrder
  }

  export type recetasAvgOrderByAggregateInput = {
    id_receta?: SortOrder
    id_producto?: SortOrder
    id_materia_prima?: SortOrder
    id_producto_especial?: SortOrder
    cantidad_requerida?: SortOrder
    unidad_medida?: SortOrder
  }

  export type recetasMaxOrderByAggregateInput = {
    id_receta?: SortOrder
    id_producto?: SortOrder
    id_materia_prima?: SortOrder
    id_producto_especial?: SortOrder
    cantidad_requerida?: SortOrder
    unidad_medida?: SortOrder
    disponible?: SortOrder
  }

  export type recetasMinOrderByAggregateInput = {
    id_receta?: SortOrder
    id_producto?: SortOrder
    id_materia_prima?: SortOrder
    id_producto_especial?: SortOrder
    cantidad_requerida?: SortOrder
    unidad_medida?: SortOrder
    disponible?: SortOrder
  }

  export type recetasSumOrderByAggregateInput = {
    id_receta?: SortOrder
    id_producto?: SortOrder
    id_materia_prima?: SortOrder
    id_producto_especial?: SortOrder
    cantidad_requerida?: SortOrder
    unidad_medida?: SortOrder
  }

  export type Materia_primaListRelationFilter = {
    every?: materia_primaWhereInput
    some?: materia_primaWhereInput
    none?: materia_primaWhereInput
  }

  export type Productos_especialesListRelationFilter = {
    every?: productos_especialesWhereInput
    some?: productos_especialesWhereInput
    none?: productos_especialesWhereInput
  }

  export type materia_primaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productos_especialesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type unidadesmedidaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    factor_conversion?: SortOrder
  }

  export type unidadesmedidaAvgOrderByAggregateInput = {
    id?: SortOrder
    factor_conversion?: SortOrder
  }

  export type unidadesmedidaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    factor_conversion?: SortOrder
  }

  export type unidadesmedidaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    factor_conversion?: SortOrder
  }

  export type unidadesmedidaSumOrderByAggregateInput = {
    id?: SortOrder
    factor_conversion?: SortOrder
  }

  export type facturasCreateNestedOneWithoutDetalle_facturaInput = {
    create?: XOR<facturasCreateWithoutDetalle_facturaInput, facturasUncheckedCreateWithoutDetalle_facturaInput>
    connectOrCreate?: facturasCreateOrConnectWithoutDetalle_facturaInput
    connect?: facturasWhereUniqueInput
  }

  export type materia_primaCreateNestedOneWithoutDetalle_facturaInput = {
    create?: XOR<materia_primaCreateWithoutDetalle_facturaInput, materia_primaUncheckedCreateWithoutDetalle_facturaInput>
    connectOrCreate?: materia_primaCreateOrConnectWithoutDetalle_facturaInput
    connect?: materia_primaWhereUniqueInput
  }

  export type unidadesmedidaCreateNestedOneWithoutDetalle_facturaInput = {
    create?: XOR<unidadesmedidaCreateWithoutDetalle_facturaInput, unidadesmedidaUncheckedCreateWithoutDetalle_facturaInput>
    connectOrCreate?: unidadesmedidaCreateOrConnectWithoutDetalle_facturaInput
    connect?: unidadesmedidaWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type facturasUpdateOneWithoutDetalle_facturaNestedInput = {
    create?: XOR<facturasCreateWithoutDetalle_facturaInput, facturasUncheckedCreateWithoutDetalle_facturaInput>
    connectOrCreate?: facturasCreateOrConnectWithoutDetalle_facturaInput
    upsert?: facturasUpsertWithoutDetalle_facturaInput
    disconnect?: facturasWhereInput | boolean
    delete?: facturasWhereInput | boolean
    connect?: facturasWhereUniqueInput
    update?: XOR<XOR<facturasUpdateToOneWithWhereWithoutDetalle_facturaInput, facturasUpdateWithoutDetalle_facturaInput>, facturasUncheckedUpdateWithoutDetalle_facturaInput>
  }

  export type materia_primaUpdateOneWithoutDetalle_facturaNestedInput = {
    create?: XOR<materia_primaCreateWithoutDetalle_facturaInput, materia_primaUncheckedCreateWithoutDetalle_facturaInput>
    connectOrCreate?: materia_primaCreateOrConnectWithoutDetalle_facturaInput
    upsert?: materia_primaUpsertWithoutDetalle_facturaInput
    disconnect?: materia_primaWhereInput | boolean
    delete?: materia_primaWhereInput | boolean
    connect?: materia_primaWhereUniqueInput
    update?: XOR<XOR<materia_primaUpdateToOneWithWhereWithoutDetalle_facturaInput, materia_primaUpdateWithoutDetalle_facturaInput>, materia_primaUncheckedUpdateWithoutDetalle_facturaInput>
  }

  export type unidadesmedidaUpdateOneWithoutDetalle_facturaNestedInput = {
    create?: XOR<unidadesmedidaCreateWithoutDetalle_facturaInput, unidadesmedidaUncheckedCreateWithoutDetalle_facturaInput>
    connectOrCreate?: unidadesmedidaCreateOrConnectWithoutDetalle_facturaInput
    upsert?: unidadesmedidaUpsertWithoutDetalle_facturaInput
    disconnect?: unidadesmedidaWhereInput | boolean
    delete?: unidadesmedidaWhereInput | boolean
    connect?: unidadesmedidaWhereUniqueInput
    update?: XOR<XOR<unidadesmedidaUpdateToOneWithWhereWithoutDetalle_facturaInput, unidadesmedidaUpdateWithoutDetalle_facturaInput>, unidadesmedidaUncheckedUpdateWithoutDetalle_facturaInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type detalle_facturaCreateNestedManyWithoutFacturasInput = {
    create?: XOR<detalle_facturaCreateWithoutFacturasInput, detalle_facturaUncheckedCreateWithoutFacturasInput> | detalle_facturaCreateWithoutFacturasInput[] | detalle_facturaUncheckedCreateWithoutFacturasInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutFacturasInput | detalle_facturaCreateOrConnectWithoutFacturasInput[]
    createMany?: detalle_facturaCreateManyFacturasInputEnvelope
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
  }

  export type monedasCreateNestedOneWithoutFacturasInput = {
    create?: XOR<monedasCreateWithoutFacturasInput, monedasUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: monedasCreateOrConnectWithoutFacturasInput
    connect?: monedasWhereUniqueInput
  }

  export type proveedoresCreateNestedOneWithoutFacturasInput = {
    create?: XOR<proveedoresCreateWithoutFacturasInput, proveedoresUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: proveedoresCreateOrConnectWithoutFacturasInput
    connect?: proveedoresWhereUniqueInput
  }

  export type detalle_facturaUncheckedCreateNestedManyWithoutFacturasInput = {
    create?: XOR<detalle_facturaCreateWithoutFacturasInput, detalle_facturaUncheckedCreateWithoutFacturasInput> | detalle_facturaCreateWithoutFacturasInput[] | detalle_facturaUncheckedCreateWithoutFacturasInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutFacturasInput | detalle_facturaCreateOrConnectWithoutFacturasInput[]
    createMany?: detalle_facturaCreateManyFacturasInputEnvelope
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type detalle_facturaUpdateManyWithoutFacturasNestedInput = {
    create?: XOR<detalle_facturaCreateWithoutFacturasInput, detalle_facturaUncheckedCreateWithoutFacturasInput> | detalle_facturaCreateWithoutFacturasInput[] | detalle_facturaUncheckedCreateWithoutFacturasInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutFacturasInput | detalle_facturaCreateOrConnectWithoutFacturasInput[]
    upsert?: detalle_facturaUpsertWithWhereUniqueWithoutFacturasInput | detalle_facturaUpsertWithWhereUniqueWithoutFacturasInput[]
    createMany?: detalle_facturaCreateManyFacturasInputEnvelope
    set?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    disconnect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    delete?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    update?: detalle_facturaUpdateWithWhereUniqueWithoutFacturasInput | detalle_facturaUpdateWithWhereUniqueWithoutFacturasInput[]
    updateMany?: detalle_facturaUpdateManyWithWhereWithoutFacturasInput | detalle_facturaUpdateManyWithWhereWithoutFacturasInput[]
    deleteMany?: detalle_facturaScalarWhereInput | detalle_facturaScalarWhereInput[]
  }

  export type monedasUpdateOneRequiredWithoutFacturasNestedInput = {
    create?: XOR<monedasCreateWithoutFacturasInput, monedasUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: monedasCreateOrConnectWithoutFacturasInput
    upsert?: monedasUpsertWithoutFacturasInput
    connect?: monedasWhereUniqueInput
    update?: XOR<XOR<monedasUpdateToOneWithWhereWithoutFacturasInput, monedasUpdateWithoutFacturasInput>, monedasUncheckedUpdateWithoutFacturasInput>
  }

  export type proveedoresUpdateOneWithoutFacturasNestedInput = {
    create?: XOR<proveedoresCreateWithoutFacturasInput, proveedoresUncheckedCreateWithoutFacturasInput>
    connectOrCreate?: proveedoresCreateOrConnectWithoutFacturasInput
    upsert?: proveedoresUpsertWithoutFacturasInput
    disconnect?: proveedoresWhereInput | boolean
    delete?: proveedoresWhereInput | boolean
    connect?: proveedoresWhereUniqueInput
    update?: XOR<XOR<proveedoresUpdateToOneWithWhereWithoutFacturasInput, proveedoresUpdateWithoutFacturasInput>, proveedoresUncheckedUpdateWithoutFacturasInput>
  }

  export type detalle_facturaUncheckedUpdateManyWithoutFacturasNestedInput = {
    create?: XOR<detalle_facturaCreateWithoutFacturasInput, detalle_facturaUncheckedCreateWithoutFacturasInput> | detalle_facturaCreateWithoutFacturasInput[] | detalle_facturaUncheckedCreateWithoutFacturasInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutFacturasInput | detalle_facturaCreateOrConnectWithoutFacturasInput[]
    upsert?: detalle_facturaUpsertWithWhereUniqueWithoutFacturasInput | detalle_facturaUpsertWithWhereUniqueWithoutFacturasInput[]
    createMany?: detalle_facturaCreateManyFacturasInputEnvelope
    set?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    disconnect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    delete?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    update?: detalle_facturaUpdateWithWhereUniqueWithoutFacturasInput | detalle_facturaUpdateWithWhereUniqueWithoutFacturasInput[]
    updateMany?: detalle_facturaUpdateManyWithWhereWithoutFacturasInput | detalle_facturaUpdateManyWithWhereWithoutFacturasInput[]
    deleteMany?: detalle_facturaScalarWhereInput | detalle_facturaScalarWhereInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type materia_primaCreateNestedOneWithoutKardex_materia_primaInput = {
    create?: XOR<materia_primaCreateWithoutKardex_materia_primaInput, materia_primaUncheckedCreateWithoutKardex_materia_primaInput>
    connectOrCreate?: materia_primaCreateOrConnectWithoutKardex_materia_primaInput
    connect?: materia_primaWhereUniqueInput
  }

  export type materia_primaUpdateOneWithoutKardex_materia_primaNestedInput = {
    create?: XOR<materia_primaCreateWithoutKardex_materia_primaInput, materia_primaUncheckedCreateWithoutKardex_materia_primaInput>
    connectOrCreate?: materia_primaCreateOrConnectWithoutKardex_materia_primaInput
    upsert?: materia_primaUpsertWithoutKardex_materia_primaInput
    disconnect?: materia_primaWhereInput | boolean
    delete?: materia_primaWhereInput | boolean
    connect?: materia_primaWhereUniqueInput
    update?: XOR<XOR<materia_primaUpdateToOneWithWhereWithoutKardex_materia_primaInput, materia_primaUpdateWithoutKardex_materia_primaInput>, materia_primaUncheckedUpdateWithoutKardex_materia_primaInput>
  }

  export type kardex_productosCreatereferencias_archivosInput = {
    set: string[]
  }

  export type productos_terminadosCreateNestedOneWithoutKardex_productosInput = {
    create?: XOR<productos_terminadosCreateWithoutKardex_productosInput, productos_terminadosUncheckedCreateWithoutKardex_productosInput>
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutKardex_productosInput
    connect?: productos_terminadosWhereUniqueInput
  }

  export type kardex_productosUpdatereferencias_archivosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type productos_terminadosUpdateOneWithoutKardex_productosNestedInput = {
    create?: XOR<productos_terminadosCreateWithoutKardex_productosInput, productos_terminadosUncheckedCreateWithoutKardex_productosInput>
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutKardex_productosInput
    upsert?: productos_terminadosUpsertWithoutKardex_productosInput
    disconnect?: productos_terminadosWhereInput | boolean
    delete?: productos_terminadosWhereInput | boolean
    connect?: productos_terminadosWhereUniqueInput
    update?: XOR<XOR<productos_terminadosUpdateToOneWithWhereWithoutKardex_productosInput, productos_terminadosUpdateWithoutKardex_productosInput>, productos_terminadosUncheckedUpdateWithoutKardex_productosInput>
  }

  export type detalle_facturaCreateNestedManyWithoutMateria_primaInput = {
    create?: XOR<detalle_facturaCreateWithoutMateria_primaInput, detalle_facturaUncheckedCreateWithoutMateria_primaInput> | detalle_facturaCreateWithoutMateria_primaInput[] | detalle_facturaUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutMateria_primaInput | detalle_facturaCreateOrConnectWithoutMateria_primaInput[]
    createMany?: detalle_facturaCreateManyMateria_primaInputEnvelope
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
  }

  export type kardex_materia_primaCreateNestedManyWithoutMateria_primaInput = {
    create?: XOR<kardex_materia_primaCreateWithoutMateria_primaInput, kardex_materia_primaUncheckedCreateWithoutMateria_primaInput> | kardex_materia_primaCreateWithoutMateria_primaInput[] | kardex_materia_primaUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: kardex_materia_primaCreateOrConnectWithoutMateria_primaInput | kardex_materia_primaCreateOrConnectWithoutMateria_primaInput[]
    createMany?: kardex_materia_primaCreateManyMateria_primaInputEnvelope
    connect?: kardex_materia_primaWhereUniqueInput | kardex_materia_primaWhereUniqueInput[]
  }

  export type recetasCreateNestedManyWithoutMateria_primaInput = {
    create?: XOR<recetasCreateWithoutMateria_primaInput, recetasUncheckedCreateWithoutMateria_primaInput> | recetasCreateWithoutMateria_primaInput[] | recetasUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutMateria_primaInput | recetasCreateOrConnectWithoutMateria_primaInput[]
    createMany?: recetasCreateManyMateria_primaInputEnvelope
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
  }

  export type unidadesmedidaCreateNestedOneWithoutMateria_primaInput = {
    create?: XOR<unidadesmedidaCreateWithoutMateria_primaInput, unidadesmedidaUncheckedCreateWithoutMateria_primaInput>
    connectOrCreate?: unidadesmedidaCreateOrConnectWithoutMateria_primaInput
    connect?: unidadesmedidaWhereUniqueInput
  }

  export type detalle_facturaUncheckedCreateNestedManyWithoutMateria_primaInput = {
    create?: XOR<detalle_facturaCreateWithoutMateria_primaInput, detalle_facturaUncheckedCreateWithoutMateria_primaInput> | detalle_facturaCreateWithoutMateria_primaInput[] | detalle_facturaUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutMateria_primaInput | detalle_facturaCreateOrConnectWithoutMateria_primaInput[]
    createMany?: detalle_facturaCreateManyMateria_primaInputEnvelope
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
  }

  export type kardex_materia_primaUncheckedCreateNestedManyWithoutMateria_primaInput = {
    create?: XOR<kardex_materia_primaCreateWithoutMateria_primaInput, kardex_materia_primaUncheckedCreateWithoutMateria_primaInput> | kardex_materia_primaCreateWithoutMateria_primaInput[] | kardex_materia_primaUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: kardex_materia_primaCreateOrConnectWithoutMateria_primaInput | kardex_materia_primaCreateOrConnectWithoutMateria_primaInput[]
    createMany?: kardex_materia_primaCreateManyMateria_primaInputEnvelope
    connect?: kardex_materia_primaWhereUniqueInput | kardex_materia_primaWhereUniqueInput[]
  }

  export type recetasUncheckedCreateNestedManyWithoutMateria_primaInput = {
    create?: XOR<recetasCreateWithoutMateria_primaInput, recetasUncheckedCreateWithoutMateria_primaInput> | recetasCreateWithoutMateria_primaInput[] | recetasUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutMateria_primaInput | recetasCreateOrConnectWithoutMateria_primaInput[]
    createMany?: recetasCreateManyMateria_primaInputEnvelope
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type detalle_facturaUpdateManyWithoutMateria_primaNestedInput = {
    create?: XOR<detalle_facturaCreateWithoutMateria_primaInput, detalle_facturaUncheckedCreateWithoutMateria_primaInput> | detalle_facturaCreateWithoutMateria_primaInput[] | detalle_facturaUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutMateria_primaInput | detalle_facturaCreateOrConnectWithoutMateria_primaInput[]
    upsert?: detalle_facturaUpsertWithWhereUniqueWithoutMateria_primaInput | detalle_facturaUpsertWithWhereUniqueWithoutMateria_primaInput[]
    createMany?: detalle_facturaCreateManyMateria_primaInputEnvelope
    set?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    disconnect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    delete?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    update?: detalle_facturaUpdateWithWhereUniqueWithoutMateria_primaInput | detalle_facturaUpdateWithWhereUniqueWithoutMateria_primaInput[]
    updateMany?: detalle_facturaUpdateManyWithWhereWithoutMateria_primaInput | detalle_facturaUpdateManyWithWhereWithoutMateria_primaInput[]
    deleteMany?: detalle_facturaScalarWhereInput | detalle_facturaScalarWhereInput[]
  }

  export type kardex_materia_primaUpdateManyWithoutMateria_primaNestedInput = {
    create?: XOR<kardex_materia_primaCreateWithoutMateria_primaInput, kardex_materia_primaUncheckedCreateWithoutMateria_primaInput> | kardex_materia_primaCreateWithoutMateria_primaInput[] | kardex_materia_primaUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: kardex_materia_primaCreateOrConnectWithoutMateria_primaInput | kardex_materia_primaCreateOrConnectWithoutMateria_primaInput[]
    upsert?: kardex_materia_primaUpsertWithWhereUniqueWithoutMateria_primaInput | kardex_materia_primaUpsertWithWhereUniqueWithoutMateria_primaInput[]
    createMany?: kardex_materia_primaCreateManyMateria_primaInputEnvelope
    set?: kardex_materia_primaWhereUniqueInput | kardex_materia_primaWhereUniqueInput[]
    disconnect?: kardex_materia_primaWhereUniqueInput | kardex_materia_primaWhereUniqueInput[]
    delete?: kardex_materia_primaWhereUniqueInput | kardex_materia_primaWhereUniqueInput[]
    connect?: kardex_materia_primaWhereUniqueInput | kardex_materia_primaWhereUniqueInput[]
    update?: kardex_materia_primaUpdateWithWhereUniqueWithoutMateria_primaInput | kardex_materia_primaUpdateWithWhereUniqueWithoutMateria_primaInput[]
    updateMany?: kardex_materia_primaUpdateManyWithWhereWithoutMateria_primaInput | kardex_materia_primaUpdateManyWithWhereWithoutMateria_primaInput[]
    deleteMany?: kardex_materia_primaScalarWhereInput | kardex_materia_primaScalarWhereInput[]
  }

  export type recetasUpdateManyWithoutMateria_primaNestedInput = {
    create?: XOR<recetasCreateWithoutMateria_primaInput, recetasUncheckedCreateWithoutMateria_primaInput> | recetasCreateWithoutMateria_primaInput[] | recetasUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutMateria_primaInput | recetasCreateOrConnectWithoutMateria_primaInput[]
    upsert?: recetasUpsertWithWhereUniqueWithoutMateria_primaInput | recetasUpsertWithWhereUniqueWithoutMateria_primaInput[]
    createMany?: recetasCreateManyMateria_primaInputEnvelope
    set?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    disconnect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    delete?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    update?: recetasUpdateWithWhereUniqueWithoutMateria_primaInput | recetasUpdateWithWhereUniqueWithoutMateria_primaInput[]
    updateMany?: recetasUpdateManyWithWhereWithoutMateria_primaInput | recetasUpdateManyWithWhereWithoutMateria_primaInput[]
    deleteMany?: recetasScalarWhereInput | recetasScalarWhereInput[]
  }

  export type unidadesmedidaUpdateOneRequiredWithoutMateria_primaNestedInput = {
    create?: XOR<unidadesmedidaCreateWithoutMateria_primaInput, unidadesmedidaUncheckedCreateWithoutMateria_primaInput>
    connectOrCreate?: unidadesmedidaCreateOrConnectWithoutMateria_primaInput
    upsert?: unidadesmedidaUpsertWithoutMateria_primaInput
    connect?: unidadesmedidaWhereUniqueInput
    update?: XOR<XOR<unidadesmedidaUpdateToOneWithWhereWithoutMateria_primaInput, unidadesmedidaUpdateWithoutMateria_primaInput>, unidadesmedidaUncheckedUpdateWithoutMateria_primaInput>
  }

  export type detalle_facturaUncheckedUpdateManyWithoutMateria_primaNestedInput = {
    create?: XOR<detalle_facturaCreateWithoutMateria_primaInput, detalle_facturaUncheckedCreateWithoutMateria_primaInput> | detalle_facturaCreateWithoutMateria_primaInput[] | detalle_facturaUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutMateria_primaInput | detalle_facturaCreateOrConnectWithoutMateria_primaInput[]
    upsert?: detalle_facturaUpsertWithWhereUniqueWithoutMateria_primaInput | detalle_facturaUpsertWithWhereUniqueWithoutMateria_primaInput[]
    createMany?: detalle_facturaCreateManyMateria_primaInputEnvelope
    set?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    disconnect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    delete?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    update?: detalle_facturaUpdateWithWhereUniqueWithoutMateria_primaInput | detalle_facturaUpdateWithWhereUniqueWithoutMateria_primaInput[]
    updateMany?: detalle_facturaUpdateManyWithWhereWithoutMateria_primaInput | detalle_facturaUpdateManyWithWhereWithoutMateria_primaInput[]
    deleteMany?: detalle_facturaScalarWhereInput | detalle_facturaScalarWhereInput[]
  }

  export type kardex_materia_primaUncheckedUpdateManyWithoutMateria_primaNestedInput = {
    create?: XOR<kardex_materia_primaCreateWithoutMateria_primaInput, kardex_materia_primaUncheckedCreateWithoutMateria_primaInput> | kardex_materia_primaCreateWithoutMateria_primaInput[] | kardex_materia_primaUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: kardex_materia_primaCreateOrConnectWithoutMateria_primaInput | kardex_materia_primaCreateOrConnectWithoutMateria_primaInput[]
    upsert?: kardex_materia_primaUpsertWithWhereUniqueWithoutMateria_primaInput | kardex_materia_primaUpsertWithWhereUniqueWithoutMateria_primaInput[]
    createMany?: kardex_materia_primaCreateManyMateria_primaInputEnvelope
    set?: kardex_materia_primaWhereUniqueInput | kardex_materia_primaWhereUniqueInput[]
    disconnect?: kardex_materia_primaWhereUniqueInput | kardex_materia_primaWhereUniqueInput[]
    delete?: kardex_materia_primaWhereUniqueInput | kardex_materia_primaWhereUniqueInput[]
    connect?: kardex_materia_primaWhereUniqueInput | kardex_materia_primaWhereUniqueInput[]
    update?: kardex_materia_primaUpdateWithWhereUniqueWithoutMateria_primaInput | kardex_materia_primaUpdateWithWhereUniqueWithoutMateria_primaInput[]
    updateMany?: kardex_materia_primaUpdateManyWithWhereWithoutMateria_primaInput | kardex_materia_primaUpdateManyWithWhereWithoutMateria_primaInput[]
    deleteMany?: kardex_materia_primaScalarWhereInput | kardex_materia_primaScalarWhereInput[]
  }

  export type recetasUncheckedUpdateManyWithoutMateria_primaNestedInput = {
    create?: XOR<recetasCreateWithoutMateria_primaInput, recetasUncheckedCreateWithoutMateria_primaInput> | recetasCreateWithoutMateria_primaInput[] | recetasUncheckedCreateWithoutMateria_primaInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutMateria_primaInput | recetasCreateOrConnectWithoutMateria_primaInput[]
    upsert?: recetasUpsertWithWhereUniqueWithoutMateria_primaInput | recetasUpsertWithWhereUniqueWithoutMateria_primaInput[]
    createMany?: recetasCreateManyMateria_primaInputEnvelope
    set?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    disconnect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    delete?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    update?: recetasUpdateWithWhereUniqueWithoutMateria_primaInput | recetasUpdateWithWhereUniqueWithoutMateria_primaInput[]
    updateMany?: recetasUpdateManyWithWhereWithoutMateria_primaInput | recetasUpdateManyWithWhereWithoutMateria_primaInput[]
    deleteMany?: recetasScalarWhereInput | recetasScalarWhereInput[]
  }

  export type facturasCreateNestedManyWithoutMonedasInput = {
    create?: XOR<facturasCreateWithoutMonedasInput, facturasUncheckedCreateWithoutMonedasInput> | facturasCreateWithoutMonedasInput[] | facturasUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutMonedasInput | facturasCreateOrConnectWithoutMonedasInput[]
    createMany?: facturasCreateManyMonedasInputEnvelope
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
  }

  export type productos_terminadosCreateNestedManyWithoutMonedasInput = {
    create?: XOR<productos_terminadosCreateWithoutMonedasInput, productos_terminadosUncheckedCreateWithoutMonedasInput> | productos_terminadosCreateWithoutMonedasInput[] | productos_terminadosUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutMonedasInput | productos_terminadosCreateOrConnectWithoutMonedasInput[]
    createMany?: productos_terminadosCreateManyMonedasInputEnvelope
    connect?: productos_terminadosWhereUniqueInput | productos_terminadosWhereUniqueInput[]
  }

  export type facturasUncheckedCreateNestedManyWithoutMonedasInput = {
    create?: XOR<facturasCreateWithoutMonedasInput, facturasUncheckedCreateWithoutMonedasInput> | facturasCreateWithoutMonedasInput[] | facturasUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutMonedasInput | facturasCreateOrConnectWithoutMonedasInput[]
    createMany?: facturasCreateManyMonedasInputEnvelope
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
  }

  export type productos_terminadosUncheckedCreateNestedManyWithoutMonedasInput = {
    create?: XOR<productos_terminadosCreateWithoutMonedasInput, productos_terminadosUncheckedCreateWithoutMonedasInput> | productos_terminadosCreateWithoutMonedasInput[] | productos_terminadosUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutMonedasInput | productos_terminadosCreateOrConnectWithoutMonedasInput[]
    createMany?: productos_terminadosCreateManyMonedasInputEnvelope
    connect?: productos_terminadosWhereUniqueInput | productos_terminadosWhereUniqueInput[]
  }

  export type facturasUpdateManyWithoutMonedasNestedInput = {
    create?: XOR<facturasCreateWithoutMonedasInput, facturasUncheckedCreateWithoutMonedasInput> | facturasCreateWithoutMonedasInput[] | facturasUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutMonedasInput | facturasCreateOrConnectWithoutMonedasInput[]
    upsert?: facturasUpsertWithWhereUniqueWithoutMonedasInput | facturasUpsertWithWhereUniqueWithoutMonedasInput[]
    createMany?: facturasCreateManyMonedasInputEnvelope
    set?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    disconnect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    delete?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    update?: facturasUpdateWithWhereUniqueWithoutMonedasInput | facturasUpdateWithWhereUniqueWithoutMonedasInput[]
    updateMany?: facturasUpdateManyWithWhereWithoutMonedasInput | facturasUpdateManyWithWhereWithoutMonedasInput[]
    deleteMany?: facturasScalarWhereInput | facturasScalarWhereInput[]
  }

  export type productos_terminadosUpdateManyWithoutMonedasNestedInput = {
    create?: XOR<productos_terminadosCreateWithoutMonedasInput, productos_terminadosUncheckedCreateWithoutMonedasInput> | productos_terminadosCreateWithoutMonedasInput[] | productos_terminadosUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutMonedasInput | productos_terminadosCreateOrConnectWithoutMonedasInput[]
    upsert?: productos_terminadosUpsertWithWhereUniqueWithoutMonedasInput | productos_terminadosUpsertWithWhereUniqueWithoutMonedasInput[]
    createMany?: productos_terminadosCreateManyMonedasInputEnvelope
    set?: productos_terminadosWhereUniqueInput | productos_terminadosWhereUniqueInput[]
    disconnect?: productos_terminadosWhereUniqueInput | productos_terminadosWhereUniqueInput[]
    delete?: productos_terminadosWhereUniqueInput | productos_terminadosWhereUniqueInput[]
    connect?: productos_terminadosWhereUniqueInput | productos_terminadosWhereUniqueInput[]
    update?: productos_terminadosUpdateWithWhereUniqueWithoutMonedasInput | productos_terminadosUpdateWithWhereUniqueWithoutMonedasInput[]
    updateMany?: productos_terminadosUpdateManyWithWhereWithoutMonedasInput | productos_terminadosUpdateManyWithWhereWithoutMonedasInput[]
    deleteMany?: productos_terminadosScalarWhereInput | productos_terminadosScalarWhereInput[]
  }

  export type facturasUncheckedUpdateManyWithoutMonedasNestedInput = {
    create?: XOR<facturasCreateWithoutMonedasInput, facturasUncheckedCreateWithoutMonedasInput> | facturasCreateWithoutMonedasInput[] | facturasUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutMonedasInput | facturasCreateOrConnectWithoutMonedasInput[]
    upsert?: facturasUpsertWithWhereUniqueWithoutMonedasInput | facturasUpsertWithWhereUniqueWithoutMonedasInput[]
    createMany?: facturasCreateManyMonedasInputEnvelope
    set?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    disconnect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    delete?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    update?: facturasUpdateWithWhereUniqueWithoutMonedasInput | facturasUpdateWithWhereUniqueWithoutMonedasInput[]
    updateMany?: facturasUpdateManyWithWhereWithoutMonedasInput | facturasUpdateManyWithWhereWithoutMonedasInput[]
    deleteMany?: facturasScalarWhereInput | facturasScalarWhereInput[]
  }

  export type productos_terminadosUncheckedUpdateManyWithoutMonedasNestedInput = {
    create?: XOR<productos_terminadosCreateWithoutMonedasInput, productos_terminadosUncheckedCreateWithoutMonedasInput> | productos_terminadosCreateWithoutMonedasInput[] | productos_terminadosUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutMonedasInput | productos_terminadosCreateOrConnectWithoutMonedasInput[]
    upsert?: productos_terminadosUpsertWithWhereUniqueWithoutMonedasInput | productos_terminadosUpsertWithWhereUniqueWithoutMonedasInput[]
    createMany?: productos_terminadosCreateManyMonedasInputEnvelope
    set?: productos_terminadosWhereUniqueInput | productos_terminadosWhereUniqueInput[]
    disconnect?: productos_terminadosWhereUniqueInput | productos_terminadosWhereUniqueInput[]
    delete?: productos_terminadosWhereUniqueInput | productos_terminadosWhereUniqueInput[]
    connect?: productos_terminadosWhereUniqueInput | productos_terminadosWhereUniqueInput[]
    update?: productos_terminadosUpdateWithWhereUniqueWithoutMonedasInput | productos_terminadosUpdateWithWhereUniqueWithoutMonedasInput[]
    updateMany?: productos_terminadosUpdateManyWithWhereWithoutMonedasInput | productos_terminadosUpdateManyWithWhereWithoutMonedasInput[]
    deleteMany?: productos_terminadosScalarWhereInput | productos_terminadosScalarWhereInput[]
  }

  export type kardex_productosCreateNestedManyWithoutProductos_terminadosInput = {
    create?: XOR<kardex_productosCreateWithoutProductos_terminadosInput, kardex_productosUncheckedCreateWithoutProductos_terminadosInput> | kardex_productosCreateWithoutProductos_terminadosInput[] | kardex_productosUncheckedCreateWithoutProductos_terminadosInput[]
    connectOrCreate?: kardex_productosCreateOrConnectWithoutProductos_terminadosInput | kardex_productosCreateOrConnectWithoutProductos_terminadosInput[]
    createMany?: kardex_productosCreateManyProductos_terminadosInputEnvelope
    connect?: kardex_productosWhereUniqueInput | kardex_productosWhereUniqueInput[]
  }

  export type monedasCreateNestedOneWithoutProductos_terminadosInput = {
    create?: XOR<monedasCreateWithoutProductos_terminadosInput, monedasUncheckedCreateWithoutProductos_terminadosInput>
    connectOrCreate?: monedasCreateOrConnectWithoutProductos_terminadosInput
    connect?: monedasWhereUniqueInput
  }

  export type recetasCreateNestedManyWithoutProductos_terminadosInput = {
    create?: XOR<recetasCreateWithoutProductos_terminadosInput, recetasUncheckedCreateWithoutProductos_terminadosInput> | recetasCreateWithoutProductos_terminadosInput[] | recetasUncheckedCreateWithoutProductos_terminadosInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutProductos_terminadosInput | recetasCreateOrConnectWithoutProductos_terminadosInput[]
    createMany?: recetasCreateManyProductos_terminadosInputEnvelope
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
  }

  export type productos_especialesCreateNestedOneWithoutProducto_terminadoInput = {
    create?: XOR<productos_especialesCreateWithoutProducto_terminadoInput, productos_especialesUncheckedCreateWithoutProducto_terminadoInput>
    connectOrCreate?: productos_especialesCreateOrConnectWithoutProducto_terminadoInput
    connect?: productos_especialesWhereUniqueInput
  }

  export type kardex_productosUncheckedCreateNestedManyWithoutProductos_terminadosInput = {
    create?: XOR<kardex_productosCreateWithoutProductos_terminadosInput, kardex_productosUncheckedCreateWithoutProductos_terminadosInput> | kardex_productosCreateWithoutProductos_terminadosInput[] | kardex_productosUncheckedCreateWithoutProductos_terminadosInput[]
    connectOrCreate?: kardex_productosCreateOrConnectWithoutProductos_terminadosInput | kardex_productosCreateOrConnectWithoutProductos_terminadosInput[]
    createMany?: kardex_productosCreateManyProductos_terminadosInputEnvelope
    connect?: kardex_productosWhereUniqueInput | kardex_productosWhereUniqueInput[]
  }

  export type recetasUncheckedCreateNestedManyWithoutProductos_terminadosInput = {
    create?: XOR<recetasCreateWithoutProductos_terminadosInput, recetasUncheckedCreateWithoutProductos_terminadosInput> | recetasCreateWithoutProductos_terminadosInput[] | recetasUncheckedCreateWithoutProductos_terminadosInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutProductos_terminadosInput | recetasCreateOrConnectWithoutProductos_terminadosInput[]
    createMany?: recetasCreateManyProductos_terminadosInputEnvelope
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
  }

  export type kardex_productosUpdateManyWithoutProductos_terminadosNestedInput = {
    create?: XOR<kardex_productosCreateWithoutProductos_terminadosInput, kardex_productosUncheckedCreateWithoutProductos_terminadosInput> | kardex_productosCreateWithoutProductos_terminadosInput[] | kardex_productosUncheckedCreateWithoutProductos_terminadosInput[]
    connectOrCreate?: kardex_productosCreateOrConnectWithoutProductos_terminadosInput | kardex_productosCreateOrConnectWithoutProductos_terminadosInput[]
    upsert?: kardex_productosUpsertWithWhereUniqueWithoutProductos_terminadosInput | kardex_productosUpsertWithWhereUniqueWithoutProductos_terminadosInput[]
    createMany?: kardex_productosCreateManyProductos_terminadosInputEnvelope
    set?: kardex_productosWhereUniqueInput | kardex_productosWhereUniqueInput[]
    disconnect?: kardex_productosWhereUniqueInput | kardex_productosWhereUniqueInput[]
    delete?: kardex_productosWhereUniqueInput | kardex_productosWhereUniqueInput[]
    connect?: kardex_productosWhereUniqueInput | kardex_productosWhereUniqueInput[]
    update?: kardex_productosUpdateWithWhereUniqueWithoutProductos_terminadosInput | kardex_productosUpdateWithWhereUniqueWithoutProductos_terminadosInput[]
    updateMany?: kardex_productosUpdateManyWithWhereWithoutProductos_terminadosInput | kardex_productosUpdateManyWithWhereWithoutProductos_terminadosInput[]
    deleteMany?: kardex_productosScalarWhereInput | kardex_productosScalarWhereInput[]
  }

  export type monedasUpdateOneRequiredWithoutProductos_terminadosNestedInput = {
    create?: XOR<monedasCreateWithoutProductos_terminadosInput, monedasUncheckedCreateWithoutProductos_terminadosInput>
    connectOrCreate?: monedasCreateOrConnectWithoutProductos_terminadosInput
    upsert?: monedasUpsertWithoutProductos_terminadosInput
    connect?: monedasWhereUniqueInput
    update?: XOR<XOR<monedasUpdateToOneWithWhereWithoutProductos_terminadosInput, monedasUpdateWithoutProductos_terminadosInput>, monedasUncheckedUpdateWithoutProductos_terminadosInput>
  }

  export type recetasUpdateManyWithoutProductos_terminadosNestedInput = {
    create?: XOR<recetasCreateWithoutProductos_terminadosInput, recetasUncheckedCreateWithoutProductos_terminadosInput> | recetasCreateWithoutProductos_terminadosInput[] | recetasUncheckedCreateWithoutProductos_terminadosInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutProductos_terminadosInput | recetasCreateOrConnectWithoutProductos_terminadosInput[]
    upsert?: recetasUpsertWithWhereUniqueWithoutProductos_terminadosInput | recetasUpsertWithWhereUniqueWithoutProductos_terminadosInput[]
    createMany?: recetasCreateManyProductos_terminadosInputEnvelope
    set?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    disconnect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    delete?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    update?: recetasUpdateWithWhereUniqueWithoutProductos_terminadosInput | recetasUpdateWithWhereUniqueWithoutProductos_terminadosInput[]
    updateMany?: recetasUpdateManyWithWhereWithoutProductos_terminadosInput | recetasUpdateManyWithWhereWithoutProductos_terminadosInput[]
    deleteMany?: recetasScalarWhereInput | recetasScalarWhereInput[]
  }

  export type productos_especialesUpdateOneWithoutProducto_terminadoNestedInput = {
    create?: XOR<productos_especialesCreateWithoutProducto_terminadoInput, productos_especialesUncheckedCreateWithoutProducto_terminadoInput>
    connectOrCreate?: productos_especialesCreateOrConnectWithoutProducto_terminadoInput
    upsert?: productos_especialesUpsertWithoutProducto_terminadoInput
    disconnect?: productos_especialesWhereInput | boolean
    delete?: productos_especialesWhereInput | boolean
    connect?: productos_especialesWhereUniqueInput
    update?: XOR<XOR<productos_especialesUpdateToOneWithWhereWithoutProducto_terminadoInput, productos_especialesUpdateWithoutProducto_terminadoInput>, productos_especialesUncheckedUpdateWithoutProducto_terminadoInput>
  }

  export type kardex_productosUncheckedUpdateManyWithoutProductos_terminadosNestedInput = {
    create?: XOR<kardex_productosCreateWithoutProductos_terminadosInput, kardex_productosUncheckedCreateWithoutProductos_terminadosInput> | kardex_productosCreateWithoutProductos_terminadosInput[] | kardex_productosUncheckedCreateWithoutProductos_terminadosInput[]
    connectOrCreate?: kardex_productosCreateOrConnectWithoutProductos_terminadosInput | kardex_productosCreateOrConnectWithoutProductos_terminadosInput[]
    upsert?: kardex_productosUpsertWithWhereUniqueWithoutProductos_terminadosInput | kardex_productosUpsertWithWhereUniqueWithoutProductos_terminadosInput[]
    createMany?: kardex_productosCreateManyProductos_terminadosInputEnvelope
    set?: kardex_productosWhereUniqueInput | kardex_productosWhereUniqueInput[]
    disconnect?: kardex_productosWhereUniqueInput | kardex_productosWhereUniqueInput[]
    delete?: kardex_productosWhereUniqueInput | kardex_productosWhereUniqueInput[]
    connect?: kardex_productosWhereUniqueInput | kardex_productosWhereUniqueInput[]
    update?: kardex_productosUpdateWithWhereUniqueWithoutProductos_terminadosInput | kardex_productosUpdateWithWhereUniqueWithoutProductos_terminadosInput[]
    updateMany?: kardex_productosUpdateManyWithWhereWithoutProductos_terminadosInput | kardex_productosUpdateManyWithWhereWithoutProductos_terminadosInput[]
    deleteMany?: kardex_productosScalarWhereInput | kardex_productosScalarWhereInput[]
  }

  export type recetasUncheckedUpdateManyWithoutProductos_terminadosNestedInput = {
    create?: XOR<recetasCreateWithoutProductos_terminadosInput, recetasUncheckedCreateWithoutProductos_terminadosInput> | recetasCreateWithoutProductos_terminadosInput[] | recetasUncheckedCreateWithoutProductos_terminadosInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutProductos_terminadosInput | recetasCreateOrConnectWithoutProductos_terminadosInput[]
    upsert?: recetasUpsertWithWhereUniqueWithoutProductos_terminadosInput | recetasUpsertWithWhereUniqueWithoutProductos_terminadosInput[]
    createMany?: recetasCreateManyProductos_terminadosInputEnvelope
    set?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    disconnect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    delete?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    update?: recetasUpdateWithWhereUniqueWithoutProductos_terminadosInput | recetasUpdateWithWhereUniqueWithoutProductos_terminadosInput[]
    updateMany?: recetasUpdateManyWithWhereWithoutProductos_terminadosInput | recetasUpdateManyWithWhereWithoutProductos_terminadosInput[]
    deleteMany?: recetasScalarWhereInput | recetasScalarWhereInput[]
  }

  export type productos_terminadosCreateNestedOneWithoutProducto_especialInput = {
    create?: XOR<productos_terminadosCreateWithoutProducto_especialInput, productos_terminadosUncheckedCreateWithoutProducto_especialInput>
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutProducto_especialInput
    connect?: productos_terminadosWhereUniqueInput
  }

  export type recetasCreateNestedManyWithoutProductos_especialesInput = {
    create?: XOR<recetasCreateWithoutProductos_especialesInput, recetasUncheckedCreateWithoutProductos_especialesInput> | recetasCreateWithoutProductos_especialesInput[] | recetasUncheckedCreateWithoutProductos_especialesInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutProductos_especialesInput | recetasCreateOrConnectWithoutProductos_especialesInput[]
    createMany?: recetasCreateManyProductos_especialesInputEnvelope
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
  }

  export type unidadesmedidaCreateNestedOneWithoutProductos_especialesInput = {
    create?: XOR<unidadesmedidaCreateWithoutProductos_especialesInput, unidadesmedidaUncheckedCreateWithoutProductos_especialesInput>
    connectOrCreate?: unidadesmedidaCreateOrConnectWithoutProductos_especialesInput
    connect?: unidadesmedidaWhereUniqueInput
  }

  export type productos_terminadosUncheckedCreateNestedOneWithoutProducto_especialInput = {
    create?: XOR<productos_terminadosCreateWithoutProducto_especialInput, productos_terminadosUncheckedCreateWithoutProducto_especialInput>
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutProducto_especialInput
    connect?: productos_terminadosWhereUniqueInput
  }

  export type recetasUncheckedCreateNestedManyWithoutProductos_especialesInput = {
    create?: XOR<recetasCreateWithoutProductos_especialesInput, recetasUncheckedCreateWithoutProductos_especialesInput> | recetasCreateWithoutProductos_especialesInput[] | recetasUncheckedCreateWithoutProductos_especialesInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutProductos_especialesInput | recetasCreateOrConnectWithoutProductos_especialesInput[]
    createMany?: recetasCreateManyProductos_especialesInputEnvelope
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
  }

  export type productos_terminadosUpdateOneWithoutProducto_especialNestedInput = {
    create?: XOR<productos_terminadosCreateWithoutProducto_especialInput, productos_terminadosUncheckedCreateWithoutProducto_especialInput>
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutProducto_especialInput
    upsert?: productos_terminadosUpsertWithoutProducto_especialInput
    disconnect?: productos_terminadosWhereInput | boolean
    delete?: productos_terminadosWhereInput | boolean
    connect?: productos_terminadosWhereUniqueInput
    update?: XOR<XOR<productos_terminadosUpdateToOneWithWhereWithoutProducto_especialInput, productos_terminadosUpdateWithoutProducto_especialInput>, productos_terminadosUncheckedUpdateWithoutProducto_especialInput>
  }

  export type recetasUpdateManyWithoutProductos_especialesNestedInput = {
    create?: XOR<recetasCreateWithoutProductos_especialesInput, recetasUncheckedCreateWithoutProductos_especialesInput> | recetasCreateWithoutProductos_especialesInput[] | recetasUncheckedCreateWithoutProductos_especialesInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutProductos_especialesInput | recetasCreateOrConnectWithoutProductos_especialesInput[]
    upsert?: recetasUpsertWithWhereUniqueWithoutProductos_especialesInput | recetasUpsertWithWhereUniqueWithoutProductos_especialesInput[]
    createMany?: recetasCreateManyProductos_especialesInputEnvelope
    set?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    disconnect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    delete?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    update?: recetasUpdateWithWhereUniqueWithoutProductos_especialesInput | recetasUpdateWithWhereUniqueWithoutProductos_especialesInput[]
    updateMany?: recetasUpdateManyWithWhereWithoutProductos_especialesInput | recetasUpdateManyWithWhereWithoutProductos_especialesInput[]
    deleteMany?: recetasScalarWhereInput | recetasScalarWhereInput[]
  }

  export type unidadesmedidaUpdateOneWithoutProductos_especialesNestedInput = {
    create?: XOR<unidadesmedidaCreateWithoutProductos_especialesInput, unidadesmedidaUncheckedCreateWithoutProductos_especialesInput>
    connectOrCreate?: unidadesmedidaCreateOrConnectWithoutProductos_especialesInput
    upsert?: unidadesmedidaUpsertWithoutProductos_especialesInput
    disconnect?: unidadesmedidaWhereInput | boolean
    delete?: unidadesmedidaWhereInput | boolean
    connect?: unidadesmedidaWhereUniqueInput
    update?: XOR<XOR<unidadesmedidaUpdateToOneWithWhereWithoutProductos_especialesInput, unidadesmedidaUpdateWithoutProductos_especialesInput>, unidadesmedidaUncheckedUpdateWithoutProductos_especialesInput>
  }

  export type productos_terminadosUncheckedUpdateOneWithoutProducto_especialNestedInput = {
    create?: XOR<productos_terminadosCreateWithoutProducto_especialInput, productos_terminadosUncheckedCreateWithoutProducto_especialInput>
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutProducto_especialInput
    upsert?: productos_terminadosUpsertWithoutProducto_especialInput
    disconnect?: productos_terminadosWhereInput | boolean
    delete?: productos_terminadosWhereInput | boolean
    connect?: productos_terminadosWhereUniqueInput
    update?: XOR<XOR<productos_terminadosUpdateToOneWithWhereWithoutProducto_especialInput, productos_terminadosUpdateWithoutProducto_especialInput>, productos_terminadosUncheckedUpdateWithoutProducto_especialInput>
  }

  export type recetasUncheckedUpdateManyWithoutProductos_especialesNestedInput = {
    create?: XOR<recetasCreateWithoutProductos_especialesInput, recetasUncheckedCreateWithoutProductos_especialesInput> | recetasCreateWithoutProductos_especialesInput[] | recetasUncheckedCreateWithoutProductos_especialesInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutProductos_especialesInput | recetasCreateOrConnectWithoutProductos_especialesInput[]
    upsert?: recetasUpsertWithWhereUniqueWithoutProductos_especialesInput | recetasUpsertWithWhereUniqueWithoutProductos_especialesInput[]
    createMany?: recetasCreateManyProductos_especialesInputEnvelope
    set?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    disconnect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    delete?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    update?: recetasUpdateWithWhereUniqueWithoutProductos_especialesInput | recetasUpdateWithWhereUniqueWithoutProductos_especialesInput[]
    updateMany?: recetasUpdateManyWithWhereWithoutProductos_especialesInput | recetasUpdateManyWithWhereWithoutProductos_especialesInput[]
    deleteMany?: recetasScalarWhereInput | recetasScalarWhereInput[]
  }

  export type facturasCreateNestedManyWithoutProveedoresInput = {
    create?: XOR<facturasCreateWithoutProveedoresInput, facturasUncheckedCreateWithoutProveedoresInput> | facturasCreateWithoutProveedoresInput[] | facturasUncheckedCreateWithoutProveedoresInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutProveedoresInput | facturasCreateOrConnectWithoutProveedoresInput[]
    createMany?: facturasCreateManyProveedoresInputEnvelope
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
  }

  export type facturasUncheckedCreateNestedManyWithoutProveedoresInput = {
    create?: XOR<facturasCreateWithoutProveedoresInput, facturasUncheckedCreateWithoutProveedoresInput> | facturasCreateWithoutProveedoresInput[] | facturasUncheckedCreateWithoutProveedoresInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutProveedoresInput | facturasCreateOrConnectWithoutProveedoresInput[]
    createMany?: facturasCreateManyProveedoresInputEnvelope
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
  }

  export type facturasUpdateManyWithoutProveedoresNestedInput = {
    create?: XOR<facturasCreateWithoutProveedoresInput, facturasUncheckedCreateWithoutProveedoresInput> | facturasCreateWithoutProveedoresInput[] | facturasUncheckedCreateWithoutProveedoresInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutProveedoresInput | facturasCreateOrConnectWithoutProveedoresInput[]
    upsert?: facturasUpsertWithWhereUniqueWithoutProveedoresInput | facturasUpsertWithWhereUniqueWithoutProveedoresInput[]
    createMany?: facturasCreateManyProveedoresInputEnvelope
    set?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    disconnect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    delete?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    update?: facturasUpdateWithWhereUniqueWithoutProveedoresInput | facturasUpdateWithWhereUniqueWithoutProveedoresInput[]
    updateMany?: facturasUpdateManyWithWhereWithoutProveedoresInput | facturasUpdateManyWithWhereWithoutProveedoresInput[]
    deleteMany?: facturasScalarWhereInput | facturasScalarWhereInput[]
  }

  export type facturasUncheckedUpdateManyWithoutProveedoresNestedInput = {
    create?: XOR<facturasCreateWithoutProveedoresInput, facturasUncheckedCreateWithoutProveedoresInput> | facturasCreateWithoutProveedoresInput[] | facturasUncheckedCreateWithoutProveedoresInput[]
    connectOrCreate?: facturasCreateOrConnectWithoutProveedoresInput | facturasCreateOrConnectWithoutProveedoresInput[]
    upsert?: facturasUpsertWithWhereUniqueWithoutProveedoresInput | facturasUpsertWithWhereUniqueWithoutProveedoresInput[]
    createMany?: facturasCreateManyProveedoresInputEnvelope
    set?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    disconnect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    delete?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    connect?: facturasWhereUniqueInput | facturasWhereUniqueInput[]
    update?: facturasUpdateWithWhereUniqueWithoutProveedoresInput | facturasUpdateWithWhereUniqueWithoutProveedoresInput[]
    updateMany?: facturasUpdateManyWithWhereWithoutProveedoresInput | facturasUpdateManyWithWhereWithoutProveedoresInput[]
    deleteMany?: facturasScalarWhereInput | facturasScalarWhereInput[]
  }

  export type unidadesmedidaCreateNestedOneWithoutRecetasInput = {
    create?: XOR<unidadesmedidaCreateWithoutRecetasInput, unidadesmedidaUncheckedCreateWithoutRecetasInput>
    connectOrCreate?: unidadesmedidaCreateOrConnectWithoutRecetasInput
    connect?: unidadesmedidaWhereUniqueInput
  }

  export type materia_primaCreateNestedOneWithoutRecetasInput = {
    create?: XOR<materia_primaCreateWithoutRecetasInput, materia_primaUncheckedCreateWithoutRecetasInput>
    connectOrCreate?: materia_primaCreateOrConnectWithoutRecetasInput
    connect?: materia_primaWhereUniqueInput
  }

  export type productos_terminadosCreateNestedOneWithoutRecetasInput = {
    create?: XOR<productos_terminadosCreateWithoutRecetasInput, productos_terminadosUncheckedCreateWithoutRecetasInput>
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutRecetasInput
    connect?: productos_terminadosWhereUniqueInput
  }

  export type productos_especialesCreateNestedOneWithoutRecetasInput = {
    create?: XOR<productos_especialesCreateWithoutRecetasInput, productos_especialesUncheckedCreateWithoutRecetasInput>
    connectOrCreate?: productos_especialesCreateOrConnectWithoutRecetasInput
    connect?: productos_especialesWhereUniqueInput
  }

  export type unidadesmedidaUpdateOneWithoutRecetasNestedInput = {
    create?: XOR<unidadesmedidaCreateWithoutRecetasInput, unidadesmedidaUncheckedCreateWithoutRecetasInput>
    connectOrCreate?: unidadesmedidaCreateOrConnectWithoutRecetasInput
    upsert?: unidadesmedidaUpsertWithoutRecetasInput
    disconnect?: unidadesmedidaWhereInput | boolean
    delete?: unidadesmedidaWhereInput | boolean
    connect?: unidadesmedidaWhereUniqueInput
    update?: XOR<XOR<unidadesmedidaUpdateToOneWithWhereWithoutRecetasInput, unidadesmedidaUpdateWithoutRecetasInput>, unidadesmedidaUncheckedUpdateWithoutRecetasInput>
  }

  export type materia_primaUpdateOneWithoutRecetasNestedInput = {
    create?: XOR<materia_primaCreateWithoutRecetasInput, materia_primaUncheckedCreateWithoutRecetasInput>
    connectOrCreate?: materia_primaCreateOrConnectWithoutRecetasInput
    upsert?: materia_primaUpsertWithoutRecetasInput
    disconnect?: materia_primaWhereInput | boolean
    delete?: materia_primaWhereInput | boolean
    connect?: materia_primaWhereUniqueInput
    update?: XOR<XOR<materia_primaUpdateToOneWithWhereWithoutRecetasInput, materia_primaUpdateWithoutRecetasInput>, materia_primaUncheckedUpdateWithoutRecetasInput>
  }

  export type productos_terminadosUpdateOneWithoutRecetasNestedInput = {
    create?: XOR<productos_terminadosCreateWithoutRecetasInput, productos_terminadosUncheckedCreateWithoutRecetasInput>
    connectOrCreate?: productos_terminadosCreateOrConnectWithoutRecetasInput
    upsert?: productos_terminadosUpsertWithoutRecetasInput
    disconnect?: productos_terminadosWhereInput | boolean
    delete?: productos_terminadosWhereInput | boolean
    connect?: productos_terminadosWhereUniqueInput
    update?: XOR<XOR<productos_terminadosUpdateToOneWithWhereWithoutRecetasInput, productos_terminadosUpdateWithoutRecetasInput>, productos_terminadosUncheckedUpdateWithoutRecetasInput>
  }

  export type productos_especialesUpdateOneWithoutRecetasNestedInput = {
    create?: XOR<productos_especialesCreateWithoutRecetasInput, productos_especialesUncheckedCreateWithoutRecetasInput>
    connectOrCreate?: productos_especialesCreateOrConnectWithoutRecetasInput
    upsert?: productos_especialesUpsertWithoutRecetasInput
    disconnect?: productos_especialesWhereInput | boolean
    delete?: productos_especialesWhereInput | boolean
    connect?: productos_especialesWhereUniqueInput
    update?: XOR<XOR<productos_especialesUpdateToOneWithWhereWithoutRecetasInput, productos_especialesUpdateWithoutRecetasInput>, productos_especialesUncheckedUpdateWithoutRecetasInput>
  }

  export type detalle_facturaCreateNestedManyWithoutUnidadesmedidaInput = {
    create?: XOR<detalle_facturaCreateWithoutUnidadesmedidaInput, detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput> | detalle_facturaCreateWithoutUnidadesmedidaInput[] | detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutUnidadesmedidaInput | detalle_facturaCreateOrConnectWithoutUnidadesmedidaInput[]
    createMany?: detalle_facturaCreateManyUnidadesmedidaInputEnvelope
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
  }

  export type recetasCreateNestedManyWithoutUnidadesmedidaInput = {
    create?: XOR<recetasCreateWithoutUnidadesmedidaInput, recetasUncheckedCreateWithoutUnidadesmedidaInput> | recetasCreateWithoutUnidadesmedidaInput[] | recetasUncheckedCreateWithoutUnidadesmedidaInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutUnidadesmedidaInput | recetasCreateOrConnectWithoutUnidadesmedidaInput[]
    createMany?: recetasCreateManyUnidadesmedidaInputEnvelope
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
  }

  export type materia_primaCreateNestedManyWithoutUnidad_medidaInput = {
    create?: XOR<materia_primaCreateWithoutUnidad_medidaInput, materia_primaUncheckedCreateWithoutUnidad_medidaInput> | materia_primaCreateWithoutUnidad_medidaInput[] | materia_primaUncheckedCreateWithoutUnidad_medidaInput[]
    connectOrCreate?: materia_primaCreateOrConnectWithoutUnidad_medidaInput | materia_primaCreateOrConnectWithoutUnidad_medidaInput[]
    createMany?: materia_primaCreateManyUnidad_medidaInputEnvelope
    connect?: materia_primaWhereUniqueInput | materia_primaWhereUniqueInput[]
  }

  export type productos_especialesCreateNestedManyWithoutUnidadInput = {
    create?: XOR<productos_especialesCreateWithoutUnidadInput, productos_especialesUncheckedCreateWithoutUnidadInput> | productos_especialesCreateWithoutUnidadInput[] | productos_especialesUncheckedCreateWithoutUnidadInput[]
    connectOrCreate?: productos_especialesCreateOrConnectWithoutUnidadInput | productos_especialesCreateOrConnectWithoutUnidadInput[]
    createMany?: productos_especialesCreateManyUnidadInputEnvelope
    connect?: productos_especialesWhereUniqueInput | productos_especialesWhereUniqueInput[]
  }

  export type detalle_facturaUncheckedCreateNestedManyWithoutUnidadesmedidaInput = {
    create?: XOR<detalle_facturaCreateWithoutUnidadesmedidaInput, detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput> | detalle_facturaCreateWithoutUnidadesmedidaInput[] | detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutUnidadesmedidaInput | detalle_facturaCreateOrConnectWithoutUnidadesmedidaInput[]
    createMany?: detalle_facturaCreateManyUnidadesmedidaInputEnvelope
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
  }

  export type recetasUncheckedCreateNestedManyWithoutUnidadesmedidaInput = {
    create?: XOR<recetasCreateWithoutUnidadesmedidaInput, recetasUncheckedCreateWithoutUnidadesmedidaInput> | recetasCreateWithoutUnidadesmedidaInput[] | recetasUncheckedCreateWithoutUnidadesmedidaInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutUnidadesmedidaInput | recetasCreateOrConnectWithoutUnidadesmedidaInput[]
    createMany?: recetasCreateManyUnidadesmedidaInputEnvelope
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
  }

  export type materia_primaUncheckedCreateNestedManyWithoutUnidad_medidaInput = {
    create?: XOR<materia_primaCreateWithoutUnidad_medidaInput, materia_primaUncheckedCreateWithoutUnidad_medidaInput> | materia_primaCreateWithoutUnidad_medidaInput[] | materia_primaUncheckedCreateWithoutUnidad_medidaInput[]
    connectOrCreate?: materia_primaCreateOrConnectWithoutUnidad_medidaInput | materia_primaCreateOrConnectWithoutUnidad_medidaInput[]
    createMany?: materia_primaCreateManyUnidad_medidaInputEnvelope
    connect?: materia_primaWhereUniqueInput | materia_primaWhereUniqueInput[]
  }

  export type productos_especialesUncheckedCreateNestedManyWithoutUnidadInput = {
    create?: XOR<productos_especialesCreateWithoutUnidadInput, productos_especialesUncheckedCreateWithoutUnidadInput> | productos_especialesCreateWithoutUnidadInput[] | productos_especialesUncheckedCreateWithoutUnidadInput[]
    connectOrCreate?: productos_especialesCreateOrConnectWithoutUnidadInput | productos_especialesCreateOrConnectWithoutUnidadInput[]
    createMany?: productos_especialesCreateManyUnidadInputEnvelope
    connect?: productos_especialesWhereUniqueInput | productos_especialesWhereUniqueInput[]
  }

  export type detalle_facturaUpdateManyWithoutUnidadesmedidaNestedInput = {
    create?: XOR<detalle_facturaCreateWithoutUnidadesmedidaInput, detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput> | detalle_facturaCreateWithoutUnidadesmedidaInput[] | detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutUnidadesmedidaInput | detalle_facturaCreateOrConnectWithoutUnidadesmedidaInput[]
    upsert?: detalle_facturaUpsertWithWhereUniqueWithoutUnidadesmedidaInput | detalle_facturaUpsertWithWhereUniqueWithoutUnidadesmedidaInput[]
    createMany?: detalle_facturaCreateManyUnidadesmedidaInputEnvelope
    set?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    disconnect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    delete?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    update?: detalle_facturaUpdateWithWhereUniqueWithoutUnidadesmedidaInput | detalle_facturaUpdateWithWhereUniqueWithoutUnidadesmedidaInput[]
    updateMany?: detalle_facturaUpdateManyWithWhereWithoutUnidadesmedidaInput | detalle_facturaUpdateManyWithWhereWithoutUnidadesmedidaInput[]
    deleteMany?: detalle_facturaScalarWhereInput | detalle_facturaScalarWhereInput[]
  }

  export type recetasUpdateManyWithoutUnidadesmedidaNestedInput = {
    create?: XOR<recetasCreateWithoutUnidadesmedidaInput, recetasUncheckedCreateWithoutUnidadesmedidaInput> | recetasCreateWithoutUnidadesmedidaInput[] | recetasUncheckedCreateWithoutUnidadesmedidaInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutUnidadesmedidaInput | recetasCreateOrConnectWithoutUnidadesmedidaInput[]
    upsert?: recetasUpsertWithWhereUniqueWithoutUnidadesmedidaInput | recetasUpsertWithWhereUniqueWithoutUnidadesmedidaInput[]
    createMany?: recetasCreateManyUnidadesmedidaInputEnvelope
    set?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    disconnect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    delete?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    update?: recetasUpdateWithWhereUniqueWithoutUnidadesmedidaInput | recetasUpdateWithWhereUniqueWithoutUnidadesmedidaInput[]
    updateMany?: recetasUpdateManyWithWhereWithoutUnidadesmedidaInput | recetasUpdateManyWithWhereWithoutUnidadesmedidaInput[]
    deleteMany?: recetasScalarWhereInput | recetasScalarWhereInput[]
  }

  export type materia_primaUpdateManyWithoutUnidad_medidaNestedInput = {
    create?: XOR<materia_primaCreateWithoutUnidad_medidaInput, materia_primaUncheckedCreateWithoutUnidad_medidaInput> | materia_primaCreateWithoutUnidad_medidaInput[] | materia_primaUncheckedCreateWithoutUnidad_medidaInput[]
    connectOrCreate?: materia_primaCreateOrConnectWithoutUnidad_medidaInput | materia_primaCreateOrConnectWithoutUnidad_medidaInput[]
    upsert?: materia_primaUpsertWithWhereUniqueWithoutUnidad_medidaInput | materia_primaUpsertWithWhereUniqueWithoutUnidad_medidaInput[]
    createMany?: materia_primaCreateManyUnidad_medidaInputEnvelope
    set?: materia_primaWhereUniqueInput | materia_primaWhereUniqueInput[]
    disconnect?: materia_primaWhereUniqueInput | materia_primaWhereUniqueInput[]
    delete?: materia_primaWhereUniqueInput | materia_primaWhereUniqueInput[]
    connect?: materia_primaWhereUniqueInput | materia_primaWhereUniqueInput[]
    update?: materia_primaUpdateWithWhereUniqueWithoutUnidad_medidaInput | materia_primaUpdateWithWhereUniqueWithoutUnidad_medidaInput[]
    updateMany?: materia_primaUpdateManyWithWhereWithoutUnidad_medidaInput | materia_primaUpdateManyWithWhereWithoutUnidad_medidaInput[]
    deleteMany?: materia_primaScalarWhereInput | materia_primaScalarWhereInput[]
  }

  export type productos_especialesUpdateManyWithoutUnidadNestedInput = {
    create?: XOR<productos_especialesCreateWithoutUnidadInput, productos_especialesUncheckedCreateWithoutUnidadInput> | productos_especialesCreateWithoutUnidadInput[] | productos_especialesUncheckedCreateWithoutUnidadInput[]
    connectOrCreate?: productos_especialesCreateOrConnectWithoutUnidadInput | productos_especialesCreateOrConnectWithoutUnidadInput[]
    upsert?: productos_especialesUpsertWithWhereUniqueWithoutUnidadInput | productos_especialesUpsertWithWhereUniqueWithoutUnidadInput[]
    createMany?: productos_especialesCreateManyUnidadInputEnvelope
    set?: productos_especialesWhereUniqueInput | productos_especialesWhereUniqueInput[]
    disconnect?: productos_especialesWhereUniqueInput | productos_especialesWhereUniqueInput[]
    delete?: productos_especialesWhereUniqueInput | productos_especialesWhereUniqueInput[]
    connect?: productos_especialesWhereUniqueInput | productos_especialesWhereUniqueInput[]
    update?: productos_especialesUpdateWithWhereUniqueWithoutUnidadInput | productos_especialesUpdateWithWhereUniqueWithoutUnidadInput[]
    updateMany?: productos_especialesUpdateManyWithWhereWithoutUnidadInput | productos_especialesUpdateManyWithWhereWithoutUnidadInput[]
    deleteMany?: productos_especialesScalarWhereInput | productos_especialesScalarWhereInput[]
  }

  export type detalle_facturaUncheckedUpdateManyWithoutUnidadesmedidaNestedInput = {
    create?: XOR<detalle_facturaCreateWithoutUnidadesmedidaInput, detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput> | detalle_facturaCreateWithoutUnidadesmedidaInput[] | detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput[]
    connectOrCreate?: detalle_facturaCreateOrConnectWithoutUnidadesmedidaInput | detalle_facturaCreateOrConnectWithoutUnidadesmedidaInput[]
    upsert?: detalle_facturaUpsertWithWhereUniqueWithoutUnidadesmedidaInput | detalle_facturaUpsertWithWhereUniqueWithoutUnidadesmedidaInput[]
    createMany?: detalle_facturaCreateManyUnidadesmedidaInputEnvelope
    set?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    disconnect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    delete?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    connect?: detalle_facturaWhereUniqueInput | detalle_facturaWhereUniqueInput[]
    update?: detalle_facturaUpdateWithWhereUniqueWithoutUnidadesmedidaInput | detalle_facturaUpdateWithWhereUniqueWithoutUnidadesmedidaInput[]
    updateMany?: detalle_facturaUpdateManyWithWhereWithoutUnidadesmedidaInput | detalle_facturaUpdateManyWithWhereWithoutUnidadesmedidaInput[]
    deleteMany?: detalle_facturaScalarWhereInput | detalle_facturaScalarWhereInput[]
  }

  export type recetasUncheckedUpdateManyWithoutUnidadesmedidaNestedInput = {
    create?: XOR<recetasCreateWithoutUnidadesmedidaInput, recetasUncheckedCreateWithoutUnidadesmedidaInput> | recetasCreateWithoutUnidadesmedidaInput[] | recetasUncheckedCreateWithoutUnidadesmedidaInput[]
    connectOrCreate?: recetasCreateOrConnectWithoutUnidadesmedidaInput | recetasCreateOrConnectWithoutUnidadesmedidaInput[]
    upsert?: recetasUpsertWithWhereUniqueWithoutUnidadesmedidaInput | recetasUpsertWithWhereUniqueWithoutUnidadesmedidaInput[]
    createMany?: recetasCreateManyUnidadesmedidaInputEnvelope
    set?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    disconnect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    delete?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    connect?: recetasWhereUniqueInput | recetasWhereUniqueInput[]
    update?: recetasUpdateWithWhereUniqueWithoutUnidadesmedidaInput | recetasUpdateWithWhereUniqueWithoutUnidadesmedidaInput[]
    updateMany?: recetasUpdateManyWithWhereWithoutUnidadesmedidaInput | recetasUpdateManyWithWhereWithoutUnidadesmedidaInput[]
    deleteMany?: recetasScalarWhereInput | recetasScalarWhereInput[]
  }

  export type materia_primaUncheckedUpdateManyWithoutUnidad_medidaNestedInput = {
    create?: XOR<materia_primaCreateWithoutUnidad_medidaInput, materia_primaUncheckedCreateWithoutUnidad_medidaInput> | materia_primaCreateWithoutUnidad_medidaInput[] | materia_primaUncheckedCreateWithoutUnidad_medidaInput[]
    connectOrCreate?: materia_primaCreateOrConnectWithoutUnidad_medidaInput | materia_primaCreateOrConnectWithoutUnidad_medidaInput[]
    upsert?: materia_primaUpsertWithWhereUniqueWithoutUnidad_medidaInput | materia_primaUpsertWithWhereUniqueWithoutUnidad_medidaInput[]
    createMany?: materia_primaCreateManyUnidad_medidaInputEnvelope
    set?: materia_primaWhereUniqueInput | materia_primaWhereUniqueInput[]
    disconnect?: materia_primaWhereUniqueInput | materia_primaWhereUniqueInput[]
    delete?: materia_primaWhereUniqueInput | materia_primaWhereUniqueInput[]
    connect?: materia_primaWhereUniqueInput | materia_primaWhereUniqueInput[]
    update?: materia_primaUpdateWithWhereUniqueWithoutUnidad_medidaInput | materia_primaUpdateWithWhereUniqueWithoutUnidad_medidaInput[]
    updateMany?: materia_primaUpdateManyWithWhereWithoutUnidad_medidaInput | materia_primaUpdateManyWithWhereWithoutUnidad_medidaInput[]
    deleteMany?: materia_primaScalarWhereInput | materia_primaScalarWhereInput[]
  }

  export type productos_especialesUncheckedUpdateManyWithoutUnidadNestedInput = {
    create?: XOR<productos_especialesCreateWithoutUnidadInput, productos_especialesUncheckedCreateWithoutUnidadInput> | productos_especialesCreateWithoutUnidadInput[] | productos_especialesUncheckedCreateWithoutUnidadInput[]
    connectOrCreate?: productos_especialesCreateOrConnectWithoutUnidadInput | productos_especialesCreateOrConnectWithoutUnidadInput[]
    upsert?: productos_especialesUpsertWithWhereUniqueWithoutUnidadInput | productos_especialesUpsertWithWhereUniqueWithoutUnidadInput[]
    createMany?: productos_especialesCreateManyUnidadInputEnvelope
    set?: productos_especialesWhereUniqueInput | productos_especialesWhereUniqueInput[]
    disconnect?: productos_especialesWhereUniqueInput | productos_especialesWhereUniqueInput[]
    delete?: productos_especialesWhereUniqueInput | productos_especialesWhereUniqueInput[]
    connect?: productos_especialesWhereUniqueInput | productos_especialesWhereUniqueInput[]
    update?: productos_especialesUpdateWithWhereUniqueWithoutUnidadInput | productos_especialesUpdateWithWhereUniqueWithoutUnidadInput[]
    updateMany?: productos_especialesUpdateManyWithWhereWithoutUnidadInput | productos_especialesUpdateManyWithWhereWithoutUnidadInput[]
    deleteMany?: productos_especialesScalarWhereInput | productos_especialesScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type facturasCreateWithoutDetalle_facturaInput = {
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
    monedas: monedasCreateNestedOneWithoutFacturasInput
    proveedores?: proveedoresCreateNestedOneWithoutFacturasInput
  }

  export type facturasUncheckedCreateWithoutDetalle_facturaInput = {
    id_factura?: number
    id_proveedor?: number | null
    id_moneda: number
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
  }

  export type facturasCreateOrConnectWithoutDetalle_facturaInput = {
    where: facturasWhereUniqueInput
    create: XOR<facturasCreateWithoutDetalle_facturaInput, facturasUncheckedCreateWithoutDetalle_facturaInput>
  }

  export type materia_primaCreateWithoutDetalle_facturaInput = {
    nombre: string
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
    kardex_materia_prima?: kardex_materia_primaCreateNestedManyWithoutMateria_primaInput
    recetas?: recetasCreateNestedManyWithoutMateria_primaInput
    unidad_medida: unidadesmedidaCreateNestedOneWithoutMateria_primaInput
  }

  export type materia_primaUncheckedCreateWithoutDetalle_facturaInput = {
    id_materia_prima?: number
    nombre: string
    unidad_medida_id: number
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
    kardex_materia_prima?: kardex_materia_primaUncheckedCreateNestedManyWithoutMateria_primaInput
    recetas?: recetasUncheckedCreateNestedManyWithoutMateria_primaInput
  }

  export type materia_primaCreateOrConnectWithoutDetalle_facturaInput = {
    where: materia_primaWhereUniqueInput
    create: XOR<materia_primaCreateWithoutDetalle_facturaInput, materia_primaUncheckedCreateWithoutDetalle_facturaInput>
  }

  export type unidadesmedidaCreateWithoutDetalle_facturaInput = {
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
    recetas?: recetasCreateNestedManyWithoutUnidadesmedidaInput
    materia_prima?: materia_primaCreateNestedManyWithoutUnidad_medidaInput
    productos_especiales?: productos_especialesCreateNestedManyWithoutUnidadInput
  }

  export type unidadesmedidaUncheckedCreateWithoutDetalle_facturaInput = {
    id?: number
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
    recetas?: recetasUncheckedCreateNestedManyWithoutUnidadesmedidaInput
    materia_prima?: materia_primaUncheckedCreateNestedManyWithoutUnidad_medidaInput
    productos_especiales?: productos_especialesUncheckedCreateNestedManyWithoutUnidadInput
  }

  export type unidadesmedidaCreateOrConnectWithoutDetalle_facturaInput = {
    where: unidadesmedidaWhereUniqueInput
    create: XOR<unidadesmedidaCreateWithoutDetalle_facturaInput, unidadesmedidaUncheckedCreateWithoutDetalle_facturaInput>
  }

  export type facturasUpsertWithoutDetalle_facturaInput = {
    update: XOR<facturasUpdateWithoutDetalle_facturaInput, facturasUncheckedUpdateWithoutDetalle_facturaInput>
    create: XOR<facturasCreateWithoutDetalle_facturaInput, facturasUncheckedCreateWithoutDetalle_facturaInput>
    where?: facturasWhereInput
  }

  export type facturasUpdateToOneWithWhereWithoutDetalle_facturaInput = {
    where?: facturasWhereInput
    data: XOR<facturasUpdateWithoutDetalle_facturaInput, facturasUncheckedUpdateWithoutDetalle_facturaInput>
  }

  export type facturasUpdateWithoutDetalle_facturaInput = {
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    monedas?: monedasUpdateOneRequiredWithoutFacturasNestedInput
    proveedores?: proveedoresUpdateOneWithoutFacturasNestedInput
  }

  export type facturasUncheckedUpdateWithoutDetalle_facturaInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    id_proveedor?: NullableIntFieldUpdateOperationsInput | number | null
    id_moneda?: IntFieldUpdateOperationsInput | number
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type materia_primaUpsertWithoutDetalle_facturaInput = {
    update: XOR<materia_primaUpdateWithoutDetalle_facturaInput, materia_primaUncheckedUpdateWithoutDetalle_facturaInput>
    create: XOR<materia_primaCreateWithoutDetalle_facturaInput, materia_primaUncheckedCreateWithoutDetalle_facturaInput>
    where?: materia_primaWhereInput
  }

  export type materia_primaUpdateToOneWithWhereWithoutDetalle_facturaInput = {
    where?: materia_primaWhereInput
    data: XOR<materia_primaUpdateWithoutDetalle_facturaInput, materia_primaUncheckedUpdateWithoutDetalle_facturaInput>
  }

  export type materia_primaUpdateWithoutDetalle_facturaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    kardex_materia_prima?: kardex_materia_primaUpdateManyWithoutMateria_primaNestedInput
    recetas?: recetasUpdateManyWithoutMateria_primaNestedInput
    unidad_medida?: unidadesmedidaUpdateOneRequiredWithoutMateria_primaNestedInput
  }

  export type materia_primaUncheckedUpdateWithoutDetalle_facturaInput = {
    id_materia_prima?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad_medida_id?: IntFieldUpdateOperationsInput | number
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    kardex_materia_prima?: kardex_materia_primaUncheckedUpdateManyWithoutMateria_primaNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutMateria_primaNestedInput
  }

  export type unidadesmedidaUpsertWithoutDetalle_facturaInput = {
    update: XOR<unidadesmedidaUpdateWithoutDetalle_facturaInput, unidadesmedidaUncheckedUpdateWithoutDetalle_facturaInput>
    create: XOR<unidadesmedidaCreateWithoutDetalle_facturaInput, unidadesmedidaUncheckedCreateWithoutDetalle_facturaInput>
    where?: unidadesmedidaWhereInput
  }

  export type unidadesmedidaUpdateToOneWithWhereWithoutDetalle_facturaInput = {
    where?: unidadesmedidaWhereInput
    data: XOR<unidadesmedidaUpdateWithoutDetalle_facturaInput, unidadesmedidaUncheckedUpdateWithoutDetalle_facturaInput>
  }

  export type unidadesmedidaUpdateWithoutDetalle_facturaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recetas?: recetasUpdateManyWithoutUnidadesmedidaNestedInput
    materia_prima?: materia_primaUpdateManyWithoutUnidad_medidaNestedInput
    productos_especiales?: productos_especialesUpdateManyWithoutUnidadNestedInput
  }

  export type unidadesmedidaUncheckedUpdateWithoutDetalle_facturaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recetas?: recetasUncheckedUpdateManyWithoutUnidadesmedidaNestedInput
    materia_prima?: materia_primaUncheckedUpdateManyWithoutUnidad_medidaNestedInput
    productos_especiales?: productos_especialesUncheckedUpdateManyWithoutUnidadNestedInput
  }

  export type detalle_facturaCreateWithoutFacturasInput = {
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    materia_prima?: materia_primaCreateNestedOneWithoutDetalle_facturaInput
    unidadesmedida?: unidadesmedidaCreateNestedOneWithoutDetalle_facturaInput
  }

  export type detalle_facturaUncheckedCreateWithoutFacturasInput = {
    id_detalle?: number
    id_materia_prima?: number | null
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    unidad_medida?: number | null
  }

  export type detalle_facturaCreateOrConnectWithoutFacturasInput = {
    where: detalle_facturaWhereUniqueInput
    create: XOR<detalle_facturaCreateWithoutFacturasInput, detalle_facturaUncheckedCreateWithoutFacturasInput>
  }

  export type detalle_facturaCreateManyFacturasInputEnvelope = {
    data: detalle_facturaCreateManyFacturasInput | detalle_facturaCreateManyFacturasInput[]
    skipDuplicates?: boolean
  }

  export type monedasCreateWithoutFacturasInput = {
    nombre: string
    tasa_cambio: Decimal | DecimalJsLike | number | string
    productos_terminados?: productos_terminadosCreateNestedManyWithoutMonedasInput
  }

  export type monedasUncheckedCreateWithoutFacturasInput = {
    id_moneda?: number
    nombre: string
    tasa_cambio: Decimal | DecimalJsLike | number | string
    productos_terminados?: productos_terminadosUncheckedCreateNestedManyWithoutMonedasInput
  }

  export type monedasCreateOrConnectWithoutFacturasInput = {
    where: monedasWhereUniqueInput
    create: XOR<monedasCreateWithoutFacturasInput, monedasUncheckedCreateWithoutFacturasInput>
  }

  export type proveedoresCreateWithoutFacturasInput = {
    rif: string
    nombre: string
    contacto?: string | null
    telefono?: string | null
    direccion?: string | null
    empresa_nombre: string
    fecha_registro?: Date | string | null
  }

  export type proveedoresUncheckedCreateWithoutFacturasInput = {
    id_proveedor?: number
    rif: string
    nombre: string
    contacto?: string | null
    telefono?: string | null
    direccion?: string | null
    empresa_nombre: string
    fecha_registro?: Date | string | null
  }

  export type proveedoresCreateOrConnectWithoutFacturasInput = {
    where: proveedoresWhereUniqueInput
    create: XOR<proveedoresCreateWithoutFacturasInput, proveedoresUncheckedCreateWithoutFacturasInput>
  }

  export type detalle_facturaUpsertWithWhereUniqueWithoutFacturasInput = {
    where: detalle_facturaWhereUniqueInput
    update: XOR<detalle_facturaUpdateWithoutFacturasInput, detalle_facturaUncheckedUpdateWithoutFacturasInput>
    create: XOR<detalle_facturaCreateWithoutFacturasInput, detalle_facturaUncheckedCreateWithoutFacturasInput>
  }

  export type detalle_facturaUpdateWithWhereUniqueWithoutFacturasInput = {
    where: detalle_facturaWhereUniqueInput
    data: XOR<detalle_facturaUpdateWithoutFacturasInput, detalle_facturaUncheckedUpdateWithoutFacturasInput>
  }

  export type detalle_facturaUpdateManyWithWhereWithoutFacturasInput = {
    where: detalle_facturaScalarWhereInput
    data: XOR<detalle_facturaUpdateManyMutationInput, detalle_facturaUncheckedUpdateManyWithoutFacturasInput>
  }

  export type detalle_facturaScalarWhereInput = {
    AND?: detalle_facturaScalarWhereInput | detalle_facturaScalarWhereInput[]
    OR?: detalle_facturaScalarWhereInput[]
    NOT?: detalle_facturaScalarWhereInput | detalle_facturaScalarWhereInput[]
    id_detalle?: IntFilter<"detalle_factura"> | number
    id_factura?: IntNullableFilter<"detalle_factura"> | number | null
    id_materia_prima?: IntNullableFilter<"detalle_factura"> | number | null
    cantidad?: DecimalFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalNullableFilter<"detalle_factura"> | Decimal | DecimalJsLike | number | string | null
    unidad_medida?: IntNullableFilter<"detalle_factura"> | number | null
  }

  export type monedasUpsertWithoutFacturasInput = {
    update: XOR<monedasUpdateWithoutFacturasInput, monedasUncheckedUpdateWithoutFacturasInput>
    create: XOR<monedasCreateWithoutFacturasInput, monedasUncheckedCreateWithoutFacturasInput>
    where?: monedasWhereInput
  }

  export type monedasUpdateToOneWithWhereWithoutFacturasInput = {
    where?: monedasWhereInput
    data: XOR<monedasUpdateWithoutFacturasInput, monedasUncheckedUpdateWithoutFacturasInput>
  }

  export type monedasUpdateWithoutFacturasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tasa_cambio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productos_terminados?: productos_terminadosUpdateManyWithoutMonedasNestedInput
  }

  export type monedasUncheckedUpdateWithoutFacturasInput = {
    id_moneda?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tasa_cambio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productos_terminados?: productos_terminadosUncheckedUpdateManyWithoutMonedasNestedInput
  }

  export type proveedoresUpsertWithoutFacturasInput = {
    update: XOR<proveedoresUpdateWithoutFacturasInput, proveedoresUncheckedUpdateWithoutFacturasInput>
    create: XOR<proveedoresCreateWithoutFacturasInput, proveedoresUncheckedCreateWithoutFacturasInput>
    where?: proveedoresWhereInput
  }

  export type proveedoresUpdateToOneWithWhereWithoutFacturasInput = {
    where?: proveedoresWhereInput
    data: XOR<proveedoresUpdateWithoutFacturasInput, proveedoresUncheckedUpdateWithoutFacturasInput>
  }

  export type proveedoresUpdateWithoutFacturasInput = {
    rif?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    contacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    empresa_nombre?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type proveedoresUncheckedUpdateWithoutFacturasInput = {
    id_proveedor?: IntFieldUpdateOperationsInput | number
    rif?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    contacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    empresa_nombre?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type materia_primaCreateWithoutKardex_materia_primaInput = {
    nombre: string
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
    detalle_factura?: detalle_facturaCreateNestedManyWithoutMateria_primaInput
    recetas?: recetasCreateNestedManyWithoutMateria_primaInput
    unidad_medida: unidadesmedidaCreateNestedOneWithoutMateria_primaInput
  }

  export type materia_primaUncheckedCreateWithoutKardex_materia_primaInput = {
    id_materia_prima?: number
    nombre: string
    unidad_medida_id: number
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutMateria_primaInput
    recetas?: recetasUncheckedCreateNestedManyWithoutMateria_primaInput
  }

  export type materia_primaCreateOrConnectWithoutKardex_materia_primaInput = {
    where: materia_primaWhereUniqueInput
    create: XOR<materia_primaCreateWithoutKardex_materia_primaInput, materia_primaUncheckedCreateWithoutKardex_materia_primaInput>
  }

  export type materia_primaUpsertWithoutKardex_materia_primaInput = {
    update: XOR<materia_primaUpdateWithoutKardex_materia_primaInput, materia_primaUncheckedUpdateWithoutKardex_materia_primaInput>
    create: XOR<materia_primaCreateWithoutKardex_materia_primaInput, materia_primaUncheckedCreateWithoutKardex_materia_primaInput>
    where?: materia_primaWhereInput
  }

  export type materia_primaUpdateToOneWithWhereWithoutKardex_materia_primaInput = {
    where?: materia_primaWhereInput
    data: XOR<materia_primaUpdateWithoutKardex_materia_primaInput, materia_primaUncheckedUpdateWithoutKardex_materia_primaInput>
  }

  export type materia_primaUpdateWithoutKardex_materia_primaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    detalle_factura?: detalle_facturaUpdateManyWithoutMateria_primaNestedInput
    recetas?: recetasUpdateManyWithoutMateria_primaNestedInput
    unidad_medida?: unidadesmedidaUpdateOneRequiredWithoutMateria_primaNestedInput
  }

  export type materia_primaUncheckedUpdateWithoutKardex_materia_primaInput = {
    id_materia_prima?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad_medida_id?: IntFieldUpdateOperationsInput | number
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutMateria_primaNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutMateria_primaNestedInput
  }

  export type productos_terminadosCreateWithoutKardex_productosInput = {
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    monedas: monedasCreateNestedOneWithoutProductos_terminadosInput
    recetas?: recetasCreateNestedManyWithoutProductos_terminadosInput
    producto_especial?: productos_especialesCreateNestedOneWithoutProducto_terminadoInput
  }

  export type productos_terminadosUncheckedCreateWithoutKardex_productosInput = {
    id_producto?: number
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    id_moneda: number
    id_producto_especial?: number | null
    recetas?: recetasUncheckedCreateNestedManyWithoutProductos_terminadosInput
  }

  export type productos_terminadosCreateOrConnectWithoutKardex_productosInput = {
    where: productos_terminadosWhereUniqueInput
    create: XOR<productos_terminadosCreateWithoutKardex_productosInput, productos_terminadosUncheckedCreateWithoutKardex_productosInput>
  }

  export type productos_terminadosUpsertWithoutKardex_productosInput = {
    update: XOR<productos_terminadosUpdateWithoutKardex_productosInput, productos_terminadosUncheckedUpdateWithoutKardex_productosInput>
    create: XOR<productos_terminadosCreateWithoutKardex_productosInput, productos_terminadosUncheckedCreateWithoutKardex_productosInput>
    where?: productos_terminadosWhereInput
  }

  export type productos_terminadosUpdateToOneWithWhereWithoutKardex_productosInput = {
    where?: productos_terminadosWhereInput
    data: XOR<productos_terminadosUpdateWithoutKardex_productosInput, productos_terminadosUncheckedUpdateWithoutKardex_productosInput>
  }

  export type productos_terminadosUpdateWithoutKardex_productosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monedas?: monedasUpdateOneRequiredWithoutProductos_terminadosNestedInput
    recetas?: recetasUpdateManyWithoutProductos_terminadosNestedInput
    producto_especial?: productos_especialesUpdateOneWithoutProducto_terminadoNestedInput
  }

  export type productos_terminadosUncheckedUpdateWithoutKardex_productosInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_moneda?: IntFieldUpdateOperationsInput | number
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    recetas?: recetasUncheckedUpdateManyWithoutProductos_terminadosNestedInput
  }

  export type detalle_facturaCreateWithoutMateria_primaInput = {
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    facturas?: facturasCreateNestedOneWithoutDetalle_facturaInput
    unidadesmedida?: unidadesmedidaCreateNestedOneWithoutDetalle_facturaInput
  }

  export type detalle_facturaUncheckedCreateWithoutMateria_primaInput = {
    id_detalle?: number
    id_factura?: number | null
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    unidad_medida?: number | null
  }

  export type detalle_facturaCreateOrConnectWithoutMateria_primaInput = {
    where: detalle_facturaWhereUniqueInput
    create: XOR<detalle_facturaCreateWithoutMateria_primaInput, detalle_facturaUncheckedCreateWithoutMateria_primaInput>
  }

  export type detalle_facturaCreateManyMateria_primaInputEnvelope = {
    data: detalle_facturaCreateManyMateria_primaInput | detalle_facturaCreateManyMateria_primaInput[]
    skipDuplicates?: boolean
  }

  export type kardex_materia_primaCreateWithoutMateria_primaInput = {
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_unitario: Decimal | DecimalJsLike | number | string
    costo_total: Decimal | DecimalJsLike | number | string
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    observaciones?: string | null
  }

  export type kardex_materia_primaUncheckedCreateWithoutMateria_primaInput = {
    id_kardex?: number
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_unitario: Decimal | DecimalJsLike | number | string
    costo_total: Decimal | DecimalJsLike | number | string
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    observaciones?: string | null
  }

  export type kardex_materia_primaCreateOrConnectWithoutMateria_primaInput = {
    where: kardex_materia_primaWhereUniqueInput
    create: XOR<kardex_materia_primaCreateWithoutMateria_primaInput, kardex_materia_primaUncheckedCreateWithoutMateria_primaInput>
  }

  export type kardex_materia_primaCreateManyMateria_primaInputEnvelope = {
    data: kardex_materia_primaCreateManyMateria_primaInput | kardex_materia_primaCreateManyMateria_primaInput[]
    skipDuplicates?: boolean
  }

  export type recetasCreateWithoutMateria_primaInput = {
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    disponible?: boolean
    unidadesmedida?: unidadesmedidaCreateNestedOneWithoutRecetasInput
    productos_terminados?: productos_terminadosCreateNestedOneWithoutRecetasInput
    productos_especiales?: productos_especialesCreateNestedOneWithoutRecetasInput
  }

  export type recetasUncheckedCreateWithoutMateria_primaInput = {
    id_receta?: number
    id_producto?: number | null
    id_producto_especial?: number | null
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    unidad_medida?: number | null
    disponible?: boolean
  }

  export type recetasCreateOrConnectWithoutMateria_primaInput = {
    where: recetasWhereUniqueInput
    create: XOR<recetasCreateWithoutMateria_primaInput, recetasUncheckedCreateWithoutMateria_primaInput>
  }

  export type recetasCreateManyMateria_primaInputEnvelope = {
    data: recetasCreateManyMateria_primaInput | recetasCreateManyMateria_primaInput[]
    skipDuplicates?: boolean
  }

  export type unidadesmedidaCreateWithoutMateria_primaInput = {
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaCreateNestedManyWithoutUnidadesmedidaInput
    recetas?: recetasCreateNestedManyWithoutUnidadesmedidaInput
    productos_especiales?: productos_especialesCreateNestedManyWithoutUnidadInput
  }

  export type unidadesmedidaUncheckedCreateWithoutMateria_primaInput = {
    id?: number
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutUnidadesmedidaInput
    recetas?: recetasUncheckedCreateNestedManyWithoutUnidadesmedidaInput
    productos_especiales?: productos_especialesUncheckedCreateNestedManyWithoutUnidadInput
  }

  export type unidadesmedidaCreateOrConnectWithoutMateria_primaInput = {
    where: unidadesmedidaWhereUniqueInput
    create: XOR<unidadesmedidaCreateWithoutMateria_primaInput, unidadesmedidaUncheckedCreateWithoutMateria_primaInput>
  }

  export type detalle_facturaUpsertWithWhereUniqueWithoutMateria_primaInput = {
    where: detalle_facturaWhereUniqueInput
    update: XOR<detalle_facturaUpdateWithoutMateria_primaInput, detalle_facturaUncheckedUpdateWithoutMateria_primaInput>
    create: XOR<detalle_facturaCreateWithoutMateria_primaInput, detalle_facturaUncheckedCreateWithoutMateria_primaInput>
  }

  export type detalle_facturaUpdateWithWhereUniqueWithoutMateria_primaInput = {
    where: detalle_facturaWhereUniqueInput
    data: XOR<detalle_facturaUpdateWithoutMateria_primaInput, detalle_facturaUncheckedUpdateWithoutMateria_primaInput>
  }

  export type detalle_facturaUpdateManyWithWhereWithoutMateria_primaInput = {
    where: detalle_facturaScalarWhereInput
    data: XOR<detalle_facturaUpdateManyMutationInput, detalle_facturaUncheckedUpdateManyWithoutMateria_primaInput>
  }

  export type kardex_materia_primaUpsertWithWhereUniqueWithoutMateria_primaInput = {
    where: kardex_materia_primaWhereUniqueInput
    update: XOR<kardex_materia_primaUpdateWithoutMateria_primaInput, kardex_materia_primaUncheckedUpdateWithoutMateria_primaInput>
    create: XOR<kardex_materia_primaCreateWithoutMateria_primaInput, kardex_materia_primaUncheckedCreateWithoutMateria_primaInput>
  }

  export type kardex_materia_primaUpdateWithWhereUniqueWithoutMateria_primaInput = {
    where: kardex_materia_primaWhereUniqueInput
    data: XOR<kardex_materia_primaUpdateWithoutMateria_primaInput, kardex_materia_primaUncheckedUpdateWithoutMateria_primaInput>
  }

  export type kardex_materia_primaUpdateManyWithWhereWithoutMateria_primaInput = {
    where: kardex_materia_primaScalarWhereInput
    data: XOR<kardex_materia_primaUpdateManyMutationInput, kardex_materia_primaUncheckedUpdateManyWithoutMateria_primaInput>
  }

  export type kardex_materia_primaScalarWhereInput = {
    AND?: kardex_materia_primaScalarWhereInput | kardex_materia_primaScalarWhereInput[]
    OR?: kardex_materia_primaScalarWhereInput[]
    NOT?: kardex_materia_primaScalarWhereInput | kardex_materia_primaScalarWhereInput[]
    id_kardex?: IntFilter<"kardex_materia_prima"> | number
    id_materia_prima?: IntNullableFilter<"kardex_materia_prima"> | number | null
    tipo_movimiento?: StringFilter<"kardex_materia_prima"> | string
    cantidad?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalFilter<"kardex_materia_prima"> | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: DateTimeNullableFilter<"kardex_materia_prima"> | Date | string | null
    referencia?: StringNullableFilter<"kardex_materia_prima"> | string | null
    observaciones?: StringNullableFilter<"kardex_materia_prima"> | string | null
  }

  export type recetasUpsertWithWhereUniqueWithoutMateria_primaInput = {
    where: recetasWhereUniqueInput
    update: XOR<recetasUpdateWithoutMateria_primaInput, recetasUncheckedUpdateWithoutMateria_primaInput>
    create: XOR<recetasCreateWithoutMateria_primaInput, recetasUncheckedCreateWithoutMateria_primaInput>
  }

  export type recetasUpdateWithWhereUniqueWithoutMateria_primaInput = {
    where: recetasWhereUniqueInput
    data: XOR<recetasUpdateWithoutMateria_primaInput, recetasUncheckedUpdateWithoutMateria_primaInput>
  }

  export type recetasUpdateManyWithWhereWithoutMateria_primaInput = {
    where: recetasScalarWhereInput
    data: XOR<recetasUpdateManyMutationInput, recetasUncheckedUpdateManyWithoutMateria_primaInput>
  }

  export type recetasScalarWhereInput = {
    AND?: recetasScalarWhereInput | recetasScalarWhereInput[]
    OR?: recetasScalarWhereInput[]
    NOT?: recetasScalarWhereInput | recetasScalarWhereInput[]
    id_receta?: IntFilter<"recetas"> | number
    id_producto?: IntNullableFilter<"recetas"> | number | null
    id_materia_prima?: IntNullableFilter<"recetas"> | number | null
    id_producto_especial?: IntNullableFilter<"recetas"> | number | null
    cantidad_requerida?: DecimalFilter<"recetas"> | Decimal | DecimalJsLike | number | string
    unidad_medida?: IntNullableFilter<"recetas"> | number | null
    disponible?: BoolFilter<"recetas"> | boolean
  }

  export type unidadesmedidaUpsertWithoutMateria_primaInput = {
    update: XOR<unidadesmedidaUpdateWithoutMateria_primaInput, unidadesmedidaUncheckedUpdateWithoutMateria_primaInput>
    create: XOR<unidadesmedidaCreateWithoutMateria_primaInput, unidadesmedidaUncheckedCreateWithoutMateria_primaInput>
    where?: unidadesmedidaWhereInput
  }

  export type unidadesmedidaUpdateToOneWithWhereWithoutMateria_primaInput = {
    where?: unidadesmedidaWhereInput
    data: XOR<unidadesmedidaUpdateWithoutMateria_primaInput, unidadesmedidaUncheckedUpdateWithoutMateria_primaInput>
  }

  export type unidadesmedidaUpdateWithoutMateria_primaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUpdateManyWithoutUnidadesmedidaNestedInput
    recetas?: recetasUpdateManyWithoutUnidadesmedidaNestedInput
    productos_especiales?: productos_especialesUpdateManyWithoutUnidadNestedInput
  }

  export type unidadesmedidaUncheckedUpdateWithoutMateria_primaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutUnidadesmedidaNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutUnidadesmedidaNestedInput
    productos_especiales?: productos_especialesUncheckedUpdateManyWithoutUnidadNestedInput
  }

  export type facturasCreateWithoutMonedasInput = {
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
    detalle_factura?: detalle_facturaCreateNestedManyWithoutFacturasInput
    proveedores?: proveedoresCreateNestedOneWithoutFacturasInput
  }

  export type facturasUncheckedCreateWithoutMonedasInput = {
    id_factura?: number
    id_proveedor?: number | null
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutFacturasInput
  }

  export type facturasCreateOrConnectWithoutMonedasInput = {
    where: facturasWhereUniqueInput
    create: XOR<facturasCreateWithoutMonedasInput, facturasUncheckedCreateWithoutMonedasInput>
  }

  export type facturasCreateManyMonedasInputEnvelope = {
    data: facturasCreateManyMonedasInput | facturasCreateManyMonedasInput[]
    skipDuplicates?: boolean
  }

  export type productos_terminadosCreateWithoutMonedasInput = {
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    kardex_productos?: kardex_productosCreateNestedManyWithoutProductos_terminadosInput
    recetas?: recetasCreateNestedManyWithoutProductos_terminadosInput
    producto_especial?: productos_especialesCreateNestedOneWithoutProducto_terminadoInput
  }

  export type productos_terminadosUncheckedCreateWithoutMonedasInput = {
    id_producto?: number
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    id_producto_especial?: number | null
    kardex_productos?: kardex_productosUncheckedCreateNestedManyWithoutProductos_terminadosInput
    recetas?: recetasUncheckedCreateNestedManyWithoutProductos_terminadosInput
  }

  export type productos_terminadosCreateOrConnectWithoutMonedasInput = {
    where: productos_terminadosWhereUniqueInput
    create: XOR<productos_terminadosCreateWithoutMonedasInput, productos_terminadosUncheckedCreateWithoutMonedasInput>
  }

  export type productos_terminadosCreateManyMonedasInputEnvelope = {
    data: productos_terminadosCreateManyMonedasInput | productos_terminadosCreateManyMonedasInput[]
    skipDuplicates?: boolean
  }

  export type facturasUpsertWithWhereUniqueWithoutMonedasInput = {
    where: facturasWhereUniqueInput
    update: XOR<facturasUpdateWithoutMonedasInput, facturasUncheckedUpdateWithoutMonedasInput>
    create: XOR<facturasCreateWithoutMonedasInput, facturasUncheckedCreateWithoutMonedasInput>
  }

  export type facturasUpdateWithWhereUniqueWithoutMonedasInput = {
    where: facturasWhereUniqueInput
    data: XOR<facturasUpdateWithoutMonedasInput, facturasUncheckedUpdateWithoutMonedasInput>
  }

  export type facturasUpdateManyWithWhereWithoutMonedasInput = {
    where: facturasScalarWhereInput
    data: XOR<facturasUpdateManyMutationInput, facturasUncheckedUpdateManyWithoutMonedasInput>
  }

  export type facturasScalarWhereInput = {
    AND?: facturasScalarWhereInput | facturasScalarWhereInput[]
    OR?: facturasScalarWhereInput[]
    NOT?: facturasScalarWhereInput | facturasScalarWhereInput[]
    id_factura?: IntFilter<"facturas"> | number
    id_proveedor?: IntNullableFilter<"facturas"> | number | null
    id_moneda?: IntFilter<"facturas"> | number
    fecha_factura?: DateTimeNullableFilter<"facturas"> | Date | string | null
    total?: DecimalFilter<"facturas"> | Decimal | DecimalJsLike | number | string
    estado?: BoolNullableFilter<"facturas"> | boolean | null
    observaciones?: StringNullableFilter<"facturas"> | string | null
  }

  export type productos_terminadosUpsertWithWhereUniqueWithoutMonedasInput = {
    where: productos_terminadosWhereUniqueInput
    update: XOR<productos_terminadosUpdateWithoutMonedasInput, productos_terminadosUncheckedUpdateWithoutMonedasInput>
    create: XOR<productos_terminadosCreateWithoutMonedasInput, productos_terminadosUncheckedCreateWithoutMonedasInput>
  }

  export type productos_terminadosUpdateWithWhereUniqueWithoutMonedasInput = {
    where: productos_terminadosWhereUniqueInput
    data: XOR<productos_terminadosUpdateWithoutMonedasInput, productos_terminadosUncheckedUpdateWithoutMonedasInput>
  }

  export type productos_terminadosUpdateManyWithWhereWithoutMonedasInput = {
    where: productos_terminadosScalarWhereInput
    data: XOR<productos_terminadosUpdateManyMutationInput, productos_terminadosUncheckedUpdateManyWithoutMonedasInput>
  }

  export type productos_terminadosScalarWhereInput = {
    AND?: productos_terminadosScalarWhereInput | productos_terminadosScalarWhereInput[]
    OR?: productos_terminadosScalarWhereInput[]
    NOT?: productos_terminadosScalarWhereInput | productos_terminadosScalarWhereInput[]
    id_producto?: IntFilter<"productos_terminados"> | number
    nombre?: StringFilter<"productos_terminados"> | string
    precio_venta?: DecimalFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string
    stock_actual?: DecimalNullableFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFilter<"productos_terminados"> | string
    precio_produccion?: DecimalFilter<"productos_terminados"> | Decimal | DecimalJsLike | number | string
    id_moneda?: IntFilter<"productos_terminados"> | number
    id_producto_especial?: IntNullableFilter<"productos_terminados"> | number | null
  }

  export type kardex_productosCreateWithoutProductos_terminadosInput = {
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_produccion?: Decimal | DecimalJsLike | number | string | null
    precio_venta?: Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    referencias_archivos?: kardex_productosCreatereferencias_archivosInput | string[]
    observaciones?: string | null
  }

  export type kardex_productosUncheckedCreateWithoutProductos_terminadosInput = {
    id_kardex?: number
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_produccion?: Decimal | DecimalJsLike | number | string | null
    precio_venta?: Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    referencias_archivos?: kardex_productosCreatereferencias_archivosInput | string[]
    observaciones?: string | null
  }

  export type kardex_productosCreateOrConnectWithoutProductos_terminadosInput = {
    where: kardex_productosWhereUniqueInput
    create: XOR<kardex_productosCreateWithoutProductos_terminadosInput, kardex_productosUncheckedCreateWithoutProductos_terminadosInput>
  }

  export type kardex_productosCreateManyProductos_terminadosInputEnvelope = {
    data: kardex_productosCreateManyProductos_terminadosInput | kardex_productosCreateManyProductos_terminadosInput[]
    skipDuplicates?: boolean
  }

  export type monedasCreateWithoutProductos_terminadosInput = {
    nombre: string
    tasa_cambio: Decimal | DecimalJsLike | number | string
    facturas?: facturasCreateNestedManyWithoutMonedasInput
  }

  export type monedasUncheckedCreateWithoutProductos_terminadosInput = {
    id_moneda?: number
    nombre: string
    tasa_cambio: Decimal | DecimalJsLike | number | string
    facturas?: facturasUncheckedCreateNestedManyWithoutMonedasInput
  }

  export type monedasCreateOrConnectWithoutProductos_terminadosInput = {
    where: monedasWhereUniqueInput
    create: XOR<monedasCreateWithoutProductos_terminadosInput, monedasUncheckedCreateWithoutProductos_terminadosInput>
  }

  export type recetasCreateWithoutProductos_terminadosInput = {
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    disponible?: boolean
    unidadesmedida?: unidadesmedidaCreateNestedOneWithoutRecetasInput
    materia_prima?: materia_primaCreateNestedOneWithoutRecetasInput
    productos_especiales?: productos_especialesCreateNestedOneWithoutRecetasInput
  }

  export type recetasUncheckedCreateWithoutProductos_terminadosInput = {
    id_receta?: number
    id_materia_prima?: number | null
    id_producto_especial?: number | null
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    unidad_medida?: number | null
    disponible?: boolean
  }

  export type recetasCreateOrConnectWithoutProductos_terminadosInput = {
    where: recetasWhereUniqueInput
    create: XOR<recetasCreateWithoutProductos_terminadosInput, recetasUncheckedCreateWithoutProductos_terminadosInput>
  }

  export type recetasCreateManyProductos_terminadosInputEnvelope = {
    data: recetasCreateManyProductos_terminadosInput | recetasCreateManyProductos_terminadosInput[]
    skipDuplicates?: boolean
  }

  export type productos_especialesCreateWithoutProducto_terminadoInput = {
    id_producto: number
    rendimiento?: Decimal | DecimalJsLike | number | string
    recetas?: recetasCreateNestedManyWithoutProductos_especialesInput
    unidad?: unidadesmedidaCreateNestedOneWithoutProductos_especialesInput
  }

  export type productos_especialesUncheckedCreateWithoutProducto_terminadoInput = {
    id_producto_especial?: number
    id_producto: number
    rendimiento?: Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: number | null
    recetas?: recetasUncheckedCreateNestedManyWithoutProductos_especialesInput
  }

  export type productos_especialesCreateOrConnectWithoutProducto_terminadoInput = {
    where: productos_especialesWhereUniqueInput
    create: XOR<productos_especialesCreateWithoutProducto_terminadoInput, productos_especialesUncheckedCreateWithoutProducto_terminadoInput>
  }

  export type kardex_productosUpsertWithWhereUniqueWithoutProductos_terminadosInput = {
    where: kardex_productosWhereUniqueInput
    update: XOR<kardex_productosUpdateWithoutProductos_terminadosInput, kardex_productosUncheckedUpdateWithoutProductos_terminadosInput>
    create: XOR<kardex_productosCreateWithoutProductos_terminadosInput, kardex_productosUncheckedCreateWithoutProductos_terminadosInput>
  }

  export type kardex_productosUpdateWithWhereUniqueWithoutProductos_terminadosInput = {
    where: kardex_productosWhereUniqueInput
    data: XOR<kardex_productosUpdateWithoutProductos_terminadosInput, kardex_productosUncheckedUpdateWithoutProductos_terminadosInput>
  }

  export type kardex_productosUpdateManyWithWhereWithoutProductos_terminadosInput = {
    where: kardex_productosScalarWhereInput
    data: XOR<kardex_productosUpdateManyMutationInput, kardex_productosUncheckedUpdateManyWithoutProductos_terminadosInput>
  }

  export type kardex_productosScalarWhereInput = {
    AND?: kardex_productosScalarWhereInput | kardex_productosScalarWhereInput[]
    OR?: kardex_productosScalarWhereInput[]
    NOT?: kardex_productosScalarWhereInput | kardex_productosScalarWhereInput[]
    id_kardex?: IntFilter<"kardex_productos"> | number
    id_producto?: IntNullableFilter<"kardex_productos"> | number | null
    tipo_movimiento?: StringFilter<"kardex_productos"> | string
    cantidad?: DecimalFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string
    costo_produccion?: DecimalNullableFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string | null
    precio_venta?: DecimalNullableFilter<"kardex_productos"> | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: DateTimeNullableFilter<"kardex_productos"> | Date | string | null
    referencia?: StringNullableFilter<"kardex_productos"> | string | null
    referencias_archivos?: StringNullableListFilter<"kardex_productos">
    observaciones?: StringNullableFilter<"kardex_productos"> | string | null
  }

  export type monedasUpsertWithoutProductos_terminadosInput = {
    update: XOR<monedasUpdateWithoutProductos_terminadosInput, monedasUncheckedUpdateWithoutProductos_terminadosInput>
    create: XOR<monedasCreateWithoutProductos_terminadosInput, monedasUncheckedCreateWithoutProductos_terminadosInput>
    where?: monedasWhereInput
  }

  export type monedasUpdateToOneWithWhereWithoutProductos_terminadosInput = {
    where?: monedasWhereInput
    data: XOR<monedasUpdateWithoutProductos_terminadosInput, monedasUncheckedUpdateWithoutProductos_terminadosInput>
  }

  export type monedasUpdateWithoutProductos_terminadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tasa_cambio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facturas?: facturasUpdateManyWithoutMonedasNestedInput
  }

  export type monedasUncheckedUpdateWithoutProductos_terminadosInput = {
    id_moneda?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tasa_cambio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facturas?: facturasUncheckedUpdateManyWithoutMonedasNestedInput
  }

  export type recetasUpsertWithWhereUniqueWithoutProductos_terminadosInput = {
    where: recetasWhereUniqueInput
    update: XOR<recetasUpdateWithoutProductos_terminadosInput, recetasUncheckedUpdateWithoutProductos_terminadosInput>
    create: XOR<recetasCreateWithoutProductos_terminadosInput, recetasUncheckedCreateWithoutProductos_terminadosInput>
  }

  export type recetasUpdateWithWhereUniqueWithoutProductos_terminadosInput = {
    where: recetasWhereUniqueInput
    data: XOR<recetasUpdateWithoutProductos_terminadosInput, recetasUncheckedUpdateWithoutProductos_terminadosInput>
  }

  export type recetasUpdateManyWithWhereWithoutProductos_terminadosInput = {
    where: recetasScalarWhereInput
    data: XOR<recetasUpdateManyMutationInput, recetasUncheckedUpdateManyWithoutProductos_terminadosInput>
  }

  export type productos_especialesUpsertWithoutProducto_terminadoInput = {
    update: XOR<productos_especialesUpdateWithoutProducto_terminadoInput, productos_especialesUncheckedUpdateWithoutProducto_terminadoInput>
    create: XOR<productos_especialesCreateWithoutProducto_terminadoInput, productos_especialesUncheckedCreateWithoutProducto_terminadoInput>
    where?: productos_especialesWhereInput
  }

  export type productos_especialesUpdateToOneWithWhereWithoutProducto_terminadoInput = {
    where?: productos_especialesWhereInput
    data: XOR<productos_especialesUpdateWithoutProducto_terminadoInput, productos_especialesUncheckedUpdateWithoutProducto_terminadoInput>
  }

  export type productos_especialesUpdateWithoutProducto_terminadoInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recetas?: recetasUpdateManyWithoutProductos_especialesNestedInput
    unidad?: unidadesmedidaUpdateOneWithoutProductos_especialesNestedInput
  }

  export type productos_especialesUncheckedUpdateWithoutProducto_terminadoInput = {
    id_producto_especial?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: NullableIntFieldUpdateOperationsInput | number | null
    recetas?: recetasUncheckedUpdateManyWithoutProductos_especialesNestedInput
  }

  export type productos_terminadosCreateWithoutProducto_especialInput = {
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    kardex_productos?: kardex_productosCreateNestedManyWithoutProductos_terminadosInput
    monedas: monedasCreateNestedOneWithoutProductos_terminadosInput
    recetas?: recetasCreateNestedManyWithoutProductos_terminadosInput
  }

  export type productos_terminadosUncheckedCreateWithoutProducto_especialInput = {
    id_producto?: number
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    id_moneda: number
    kardex_productos?: kardex_productosUncheckedCreateNestedManyWithoutProductos_terminadosInput
    recetas?: recetasUncheckedCreateNestedManyWithoutProductos_terminadosInput
  }

  export type productos_terminadosCreateOrConnectWithoutProducto_especialInput = {
    where: productos_terminadosWhereUniqueInput
    create: XOR<productos_terminadosCreateWithoutProducto_especialInput, productos_terminadosUncheckedCreateWithoutProducto_especialInput>
  }

  export type recetasCreateWithoutProductos_especialesInput = {
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    disponible?: boolean
    unidadesmedida?: unidadesmedidaCreateNestedOneWithoutRecetasInput
    materia_prima?: materia_primaCreateNestedOneWithoutRecetasInput
    productos_terminados?: productos_terminadosCreateNestedOneWithoutRecetasInput
  }

  export type recetasUncheckedCreateWithoutProductos_especialesInput = {
    id_receta?: number
    id_producto?: number | null
    id_materia_prima?: number | null
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    unidad_medida?: number | null
    disponible?: boolean
  }

  export type recetasCreateOrConnectWithoutProductos_especialesInput = {
    where: recetasWhereUniqueInput
    create: XOR<recetasCreateWithoutProductos_especialesInput, recetasUncheckedCreateWithoutProductos_especialesInput>
  }

  export type recetasCreateManyProductos_especialesInputEnvelope = {
    data: recetasCreateManyProductos_especialesInput | recetasCreateManyProductos_especialesInput[]
    skipDuplicates?: boolean
  }

  export type unidadesmedidaCreateWithoutProductos_especialesInput = {
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaCreateNestedManyWithoutUnidadesmedidaInput
    recetas?: recetasCreateNestedManyWithoutUnidadesmedidaInput
    materia_prima?: materia_primaCreateNestedManyWithoutUnidad_medidaInput
  }

  export type unidadesmedidaUncheckedCreateWithoutProductos_especialesInput = {
    id?: number
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutUnidadesmedidaInput
    recetas?: recetasUncheckedCreateNestedManyWithoutUnidadesmedidaInput
    materia_prima?: materia_primaUncheckedCreateNestedManyWithoutUnidad_medidaInput
  }

  export type unidadesmedidaCreateOrConnectWithoutProductos_especialesInput = {
    where: unidadesmedidaWhereUniqueInput
    create: XOR<unidadesmedidaCreateWithoutProductos_especialesInput, unidadesmedidaUncheckedCreateWithoutProductos_especialesInput>
  }

  export type productos_terminadosUpsertWithoutProducto_especialInput = {
    update: XOR<productos_terminadosUpdateWithoutProducto_especialInput, productos_terminadosUncheckedUpdateWithoutProducto_especialInput>
    create: XOR<productos_terminadosCreateWithoutProducto_especialInput, productos_terminadosUncheckedCreateWithoutProducto_especialInput>
    where?: productos_terminadosWhereInput
  }

  export type productos_terminadosUpdateToOneWithWhereWithoutProducto_especialInput = {
    where?: productos_terminadosWhereInput
    data: XOR<productos_terminadosUpdateWithoutProducto_especialInput, productos_terminadosUncheckedUpdateWithoutProducto_especialInput>
  }

  export type productos_terminadosUpdateWithoutProducto_especialInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kardex_productos?: kardex_productosUpdateManyWithoutProductos_terminadosNestedInput
    monedas?: monedasUpdateOneRequiredWithoutProductos_terminadosNestedInput
    recetas?: recetasUpdateManyWithoutProductos_terminadosNestedInput
  }

  export type productos_terminadosUncheckedUpdateWithoutProducto_especialInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_moneda?: IntFieldUpdateOperationsInput | number
    kardex_productos?: kardex_productosUncheckedUpdateManyWithoutProductos_terminadosNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutProductos_terminadosNestedInput
  }

  export type recetasUpsertWithWhereUniqueWithoutProductos_especialesInput = {
    where: recetasWhereUniqueInput
    update: XOR<recetasUpdateWithoutProductos_especialesInput, recetasUncheckedUpdateWithoutProductos_especialesInput>
    create: XOR<recetasCreateWithoutProductos_especialesInput, recetasUncheckedCreateWithoutProductos_especialesInput>
  }

  export type recetasUpdateWithWhereUniqueWithoutProductos_especialesInput = {
    where: recetasWhereUniqueInput
    data: XOR<recetasUpdateWithoutProductos_especialesInput, recetasUncheckedUpdateWithoutProductos_especialesInput>
  }

  export type recetasUpdateManyWithWhereWithoutProductos_especialesInput = {
    where: recetasScalarWhereInput
    data: XOR<recetasUpdateManyMutationInput, recetasUncheckedUpdateManyWithoutProductos_especialesInput>
  }

  export type unidadesmedidaUpsertWithoutProductos_especialesInput = {
    update: XOR<unidadesmedidaUpdateWithoutProductos_especialesInput, unidadesmedidaUncheckedUpdateWithoutProductos_especialesInput>
    create: XOR<unidadesmedidaCreateWithoutProductos_especialesInput, unidadesmedidaUncheckedCreateWithoutProductos_especialesInput>
    where?: unidadesmedidaWhereInput
  }

  export type unidadesmedidaUpdateToOneWithWhereWithoutProductos_especialesInput = {
    where?: unidadesmedidaWhereInput
    data: XOR<unidadesmedidaUpdateWithoutProductos_especialesInput, unidadesmedidaUncheckedUpdateWithoutProductos_especialesInput>
  }

  export type unidadesmedidaUpdateWithoutProductos_especialesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUpdateManyWithoutUnidadesmedidaNestedInput
    recetas?: recetasUpdateManyWithoutUnidadesmedidaNestedInput
    materia_prima?: materia_primaUpdateManyWithoutUnidad_medidaNestedInput
  }

  export type unidadesmedidaUncheckedUpdateWithoutProductos_especialesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutUnidadesmedidaNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutUnidadesmedidaNestedInput
    materia_prima?: materia_primaUncheckedUpdateManyWithoutUnidad_medidaNestedInput
  }

  export type facturasCreateWithoutProveedoresInput = {
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
    detalle_factura?: detalle_facturaCreateNestedManyWithoutFacturasInput
    monedas: monedasCreateNestedOneWithoutFacturasInput
  }

  export type facturasUncheckedCreateWithoutProveedoresInput = {
    id_factura?: number
    id_moneda: number
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutFacturasInput
  }

  export type facturasCreateOrConnectWithoutProveedoresInput = {
    where: facturasWhereUniqueInput
    create: XOR<facturasCreateWithoutProveedoresInput, facturasUncheckedCreateWithoutProveedoresInput>
  }

  export type facturasCreateManyProveedoresInputEnvelope = {
    data: facturasCreateManyProveedoresInput | facturasCreateManyProveedoresInput[]
    skipDuplicates?: boolean
  }

  export type facturasUpsertWithWhereUniqueWithoutProveedoresInput = {
    where: facturasWhereUniqueInput
    update: XOR<facturasUpdateWithoutProveedoresInput, facturasUncheckedUpdateWithoutProveedoresInput>
    create: XOR<facturasCreateWithoutProveedoresInput, facturasUncheckedCreateWithoutProveedoresInput>
  }

  export type facturasUpdateWithWhereUniqueWithoutProveedoresInput = {
    where: facturasWhereUniqueInput
    data: XOR<facturasUpdateWithoutProveedoresInput, facturasUncheckedUpdateWithoutProveedoresInput>
  }

  export type facturasUpdateManyWithWhereWithoutProveedoresInput = {
    where: facturasScalarWhereInput
    data: XOR<facturasUpdateManyMutationInput, facturasUncheckedUpdateManyWithoutProveedoresInput>
  }

  export type unidadesmedidaCreateWithoutRecetasInput = {
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaCreateNestedManyWithoutUnidadesmedidaInput
    materia_prima?: materia_primaCreateNestedManyWithoutUnidad_medidaInput
    productos_especiales?: productos_especialesCreateNestedManyWithoutUnidadInput
  }

  export type unidadesmedidaUncheckedCreateWithoutRecetasInput = {
    id?: number
    nombre: string
    factor_conversion: Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutUnidadesmedidaInput
    materia_prima?: materia_primaUncheckedCreateNestedManyWithoutUnidad_medidaInput
    productos_especiales?: productos_especialesUncheckedCreateNestedManyWithoutUnidadInput
  }

  export type unidadesmedidaCreateOrConnectWithoutRecetasInput = {
    where: unidadesmedidaWhereUniqueInput
    create: XOR<unidadesmedidaCreateWithoutRecetasInput, unidadesmedidaUncheckedCreateWithoutRecetasInput>
  }

  export type materia_primaCreateWithoutRecetasInput = {
    nombre: string
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
    detalle_factura?: detalle_facturaCreateNestedManyWithoutMateria_primaInput
    kardex_materia_prima?: kardex_materia_primaCreateNestedManyWithoutMateria_primaInput
    unidad_medida: unidadesmedidaCreateNestedOneWithoutMateria_primaInput
  }

  export type materia_primaUncheckedCreateWithoutRecetasInput = {
    id_materia_prima?: number
    nombre: string
    unidad_medida_id: number
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutMateria_primaInput
    kardex_materia_prima?: kardex_materia_primaUncheckedCreateNestedManyWithoutMateria_primaInput
  }

  export type materia_primaCreateOrConnectWithoutRecetasInput = {
    where: materia_primaWhereUniqueInput
    create: XOR<materia_primaCreateWithoutRecetasInput, materia_primaUncheckedCreateWithoutRecetasInput>
  }

  export type productos_terminadosCreateWithoutRecetasInput = {
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    kardex_productos?: kardex_productosCreateNestedManyWithoutProductos_terminadosInput
    monedas: monedasCreateNestedOneWithoutProductos_terminadosInput
    producto_especial?: productos_especialesCreateNestedOneWithoutProducto_terminadoInput
  }

  export type productos_terminadosUncheckedCreateWithoutRecetasInput = {
    id_producto?: number
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    id_moneda: number
    id_producto_especial?: number | null
    kardex_productos?: kardex_productosUncheckedCreateNestedManyWithoutProductos_terminadosInput
  }

  export type productos_terminadosCreateOrConnectWithoutRecetasInput = {
    where: productos_terminadosWhereUniqueInput
    create: XOR<productos_terminadosCreateWithoutRecetasInput, productos_terminadosUncheckedCreateWithoutRecetasInput>
  }

  export type productos_especialesCreateWithoutRecetasInput = {
    id_producto: number
    rendimiento?: Decimal | DecimalJsLike | number | string
    producto_terminado?: productos_terminadosCreateNestedOneWithoutProducto_especialInput
    unidad?: unidadesmedidaCreateNestedOneWithoutProductos_especialesInput
  }

  export type productos_especialesUncheckedCreateWithoutRecetasInput = {
    id_producto_especial?: number
    id_producto: number
    rendimiento?: Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: number | null
    producto_terminado?: productos_terminadosUncheckedCreateNestedOneWithoutProducto_especialInput
  }

  export type productos_especialesCreateOrConnectWithoutRecetasInput = {
    where: productos_especialesWhereUniqueInput
    create: XOR<productos_especialesCreateWithoutRecetasInput, productos_especialesUncheckedCreateWithoutRecetasInput>
  }

  export type unidadesmedidaUpsertWithoutRecetasInput = {
    update: XOR<unidadesmedidaUpdateWithoutRecetasInput, unidadesmedidaUncheckedUpdateWithoutRecetasInput>
    create: XOR<unidadesmedidaCreateWithoutRecetasInput, unidadesmedidaUncheckedCreateWithoutRecetasInput>
    where?: unidadesmedidaWhereInput
  }

  export type unidadesmedidaUpdateToOneWithWhereWithoutRecetasInput = {
    where?: unidadesmedidaWhereInput
    data: XOR<unidadesmedidaUpdateWithoutRecetasInput, unidadesmedidaUncheckedUpdateWithoutRecetasInput>
  }

  export type unidadesmedidaUpdateWithoutRecetasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUpdateManyWithoutUnidadesmedidaNestedInput
    materia_prima?: materia_primaUpdateManyWithoutUnidad_medidaNestedInput
    productos_especiales?: productos_especialesUpdateManyWithoutUnidadNestedInput
  }

  export type unidadesmedidaUncheckedUpdateWithoutRecetasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    factor_conversion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutUnidadesmedidaNestedInput
    materia_prima?: materia_primaUncheckedUpdateManyWithoutUnidad_medidaNestedInput
    productos_especiales?: productos_especialesUncheckedUpdateManyWithoutUnidadNestedInput
  }

  export type materia_primaUpsertWithoutRecetasInput = {
    update: XOR<materia_primaUpdateWithoutRecetasInput, materia_primaUncheckedUpdateWithoutRecetasInput>
    create: XOR<materia_primaCreateWithoutRecetasInput, materia_primaUncheckedCreateWithoutRecetasInput>
    where?: materia_primaWhereInput
  }

  export type materia_primaUpdateToOneWithWhereWithoutRecetasInput = {
    where?: materia_primaWhereInput
    data: XOR<materia_primaUpdateWithoutRecetasInput, materia_primaUncheckedUpdateWithoutRecetasInput>
  }

  export type materia_primaUpdateWithoutRecetasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    detalle_factura?: detalle_facturaUpdateManyWithoutMateria_primaNestedInput
    kardex_materia_prima?: kardex_materia_primaUpdateManyWithoutMateria_primaNestedInput
    unidad_medida?: unidadesmedidaUpdateOneRequiredWithoutMateria_primaNestedInput
  }

  export type materia_primaUncheckedUpdateWithoutRecetasInput = {
    id_materia_prima?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad_medida_id?: IntFieldUpdateOperationsInput | number
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutMateria_primaNestedInput
    kardex_materia_prima?: kardex_materia_primaUncheckedUpdateManyWithoutMateria_primaNestedInput
  }

  export type productos_terminadosUpsertWithoutRecetasInput = {
    update: XOR<productos_terminadosUpdateWithoutRecetasInput, productos_terminadosUncheckedUpdateWithoutRecetasInput>
    create: XOR<productos_terminadosCreateWithoutRecetasInput, productos_terminadosUncheckedCreateWithoutRecetasInput>
    where?: productos_terminadosWhereInput
  }

  export type productos_terminadosUpdateToOneWithWhereWithoutRecetasInput = {
    where?: productos_terminadosWhereInput
    data: XOR<productos_terminadosUpdateWithoutRecetasInput, productos_terminadosUncheckedUpdateWithoutRecetasInput>
  }

  export type productos_terminadosUpdateWithoutRecetasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kardex_productos?: kardex_productosUpdateManyWithoutProductos_terminadosNestedInput
    monedas?: monedasUpdateOneRequiredWithoutProductos_terminadosNestedInput
    producto_especial?: productos_especialesUpdateOneWithoutProducto_terminadoNestedInput
  }

  export type productos_terminadosUncheckedUpdateWithoutRecetasInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_moneda?: IntFieldUpdateOperationsInput | number
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    kardex_productos?: kardex_productosUncheckedUpdateManyWithoutProductos_terminadosNestedInput
  }

  export type productos_especialesUpsertWithoutRecetasInput = {
    update: XOR<productos_especialesUpdateWithoutRecetasInput, productos_especialesUncheckedUpdateWithoutRecetasInput>
    create: XOR<productos_especialesCreateWithoutRecetasInput, productos_especialesUncheckedCreateWithoutRecetasInput>
    where?: productos_especialesWhereInput
  }

  export type productos_especialesUpdateToOneWithWhereWithoutRecetasInput = {
    where?: productos_especialesWhereInput
    data: XOR<productos_especialesUpdateWithoutRecetasInput, productos_especialesUncheckedUpdateWithoutRecetasInput>
  }

  export type productos_especialesUpdateWithoutRecetasInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    producto_terminado?: productos_terminadosUpdateOneWithoutProducto_especialNestedInput
    unidad?: unidadesmedidaUpdateOneWithoutProductos_especialesNestedInput
  }

  export type productos_especialesUncheckedUpdateWithoutRecetasInput = {
    id_producto_especial?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: NullableIntFieldUpdateOperationsInput | number | null
    producto_terminado?: productos_terminadosUncheckedUpdateOneWithoutProducto_especialNestedInput
  }

  export type detalle_facturaCreateWithoutUnidadesmedidaInput = {
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    facturas?: facturasCreateNestedOneWithoutDetalle_facturaInput
    materia_prima?: materia_primaCreateNestedOneWithoutDetalle_facturaInput
  }

  export type detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput = {
    id_detalle?: number
    id_factura?: number | null
    id_materia_prima?: number | null
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_facturaCreateOrConnectWithoutUnidadesmedidaInput = {
    where: detalle_facturaWhereUniqueInput
    create: XOR<detalle_facturaCreateWithoutUnidadesmedidaInput, detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput>
  }

  export type detalle_facturaCreateManyUnidadesmedidaInputEnvelope = {
    data: detalle_facturaCreateManyUnidadesmedidaInput | detalle_facturaCreateManyUnidadesmedidaInput[]
    skipDuplicates?: boolean
  }

  export type recetasCreateWithoutUnidadesmedidaInput = {
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    disponible?: boolean
    materia_prima?: materia_primaCreateNestedOneWithoutRecetasInput
    productos_terminados?: productos_terminadosCreateNestedOneWithoutRecetasInput
    productos_especiales?: productos_especialesCreateNestedOneWithoutRecetasInput
  }

  export type recetasUncheckedCreateWithoutUnidadesmedidaInput = {
    id_receta?: number
    id_producto?: number | null
    id_materia_prima?: number | null
    id_producto_especial?: number | null
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    disponible?: boolean
  }

  export type recetasCreateOrConnectWithoutUnidadesmedidaInput = {
    where: recetasWhereUniqueInput
    create: XOR<recetasCreateWithoutUnidadesmedidaInput, recetasUncheckedCreateWithoutUnidadesmedidaInput>
  }

  export type recetasCreateManyUnidadesmedidaInputEnvelope = {
    data: recetasCreateManyUnidadesmedidaInput | recetasCreateManyUnidadesmedidaInput[]
    skipDuplicates?: boolean
  }

  export type materia_primaCreateWithoutUnidad_medidaInput = {
    nombre: string
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
    detalle_factura?: detalle_facturaCreateNestedManyWithoutMateria_primaInput
    kardex_materia_prima?: kardex_materia_primaCreateNestedManyWithoutMateria_primaInput
    recetas?: recetasCreateNestedManyWithoutMateria_primaInput
  }

  export type materia_primaUncheckedCreateWithoutUnidad_medidaInput = {
    id_materia_prima?: number
    nombre: string
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
    detalle_factura?: detalle_facturaUncheckedCreateNestedManyWithoutMateria_primaInput
    kardex_materia_prima?: kardex_materia_primaUncheckedCreateNestedManyWithoutMateria_primaInput
    recetas?: recetasUncheckedCreateNestedManyWithoutMateria_primaInput
  }

  export type materia_primaCreateOrConnectWithoutUnidad_medidaInput = {
    where: materia_primaWhereUniqueInput
    create: XOR<materia_primaCreateWithoutUnidad_medidaInput, materia_primaUncheckedCreateWithoutUnidad_medidaInput>
  }

  export type materia_primaCreateManyUnidad_medidaInputEnvelope = {
    data: materia_primaCreateManyUnidad_medidaInput | materia_primaCreateManyUnidad_medidaInput[]
    skipDuplicates?: boolean
  }

  export type productos_especialesCreateWithoutUnidadInput = {
    id_producto: number
    rendimiento?: Decimal | DecimalJsLike | number | string
    producto_terminado?: productos_terminadosCreateNestedOneWithoutProducto_especialInput
    recetas?: recetasCreateNestedManyWithoutProductos_especialesInput
  }

  export type productos_especialesUncheckedCreateWithoutUnidadInput = {
    id_producto_especial?: number
    id_producto: number
    rendimiento?: Decimal | DecimalJsLike | number | string
    producto_terminado?: productos_terminadosUncheckedCreateNestedOneWithoutProducto_especialInput
    recetas?: recetasUncheckedCreateNestedManyWithoutProductos_especialesInput
  }

  export type productos_especialesCreateOrConnectWithoutUnidadInput = {
    where: productos_especialesWhereUniqueInput
    create: XOR<productos_especialesCreateWithoutUnidadInput, productos_especialesUncheckedCreateWithoutUnidadInput>
  }

  export type productos_especialesCreateManyUnidadInputEnvelope = {
    data: productos_especialesCreateManyUnidadInput | productos_especialesCreateManyUnidadInput[]
    skipDuplicates?: boolean
  }

  export type detalle_facturaUpsertWithWhereUniqueWithoutUnidadesmedidaInput = {
    where: detalle_facturaWhereUniqueInput
    update: XOR<detalle_facturaUpdateWithoutUnidadesmedidaInput, detalle_facturaUncheckedUpdateWithoutUnidadesmedidaInput>
    create: XOR<detalle_facturaCreateWithoutUnidadesmedidaInput, detalle_facturaUncheckedCreateWithoutUnidadesmedidaInput>
  }

  export type detalle_facturaUpdateWithWhereUniqueWithoutUnidadesmedidaInput = {
    where: detalle_facturaWhereUniqueInput
    data: XOR<detalle_facturaUpdateWithoutUnidadesmedidaInput, detalle_facturaUncheckedUpdateWithoutUnidadesmedidaInput>
  }

  export type detalle_facturaUpdateManyWithWhereWithoutUnidadesmedidaInput = {
    where: detalle_facturaScalarWhereInput
    data: XOR<detalle_facturaUpdateManyMutationInput, detalle_facturaUncheckedUpdateManyWithoutUnidadesmedidaInput>
  }

  export type recetasUpsertWithWhereUniqueWithoutUnidadesmedidaInput = {
    where: recetasWhereUniqueInput
    update: XOR<recetasUpdateWithoutUnidadesmedidaInput, recetasUncheckedUpdateWithoutUnidadesmedidaInput>
    create: XOR<recetasCreateWithoutUnidadesmedidaInput, recetasUncheckedCreateWithoutUnidadesmedidaInput>
  }

  export type recetasUpdateWithWhereUniqueWithoutUnidadesmedidaInput = {
    where: recetasWhereUniqueInput
    data: XOR<recetasUpdateWithoutUnidadesmedidaInput, recetasUncheckedUpdateWithoutUnidadesmedidaInput>
  }

  export type recetasUpdateManyWithWhereWithoutUnidadesmedidaInput = {
    where: recetasScalarWhereInput
    data: XOR<recetasUpdateManyMutationInput, recetasUncheckedUpdateManyWithoutUnidadesmedidaInput>
  }

  export type materia_primaUpsertWithWhereUniqueWithoutUnidad_medidaInput = {
    where: materia_primaWhereUniqueInput
    update: XOR<materia_primaUpdateWithoutUnidad_medidaInput, materia_primaUncheckedUpdateWithoutUnidad_medidaInput>
    create: XOR<materia_primaCreateWithoutUnidad_medidaInput, materia_primaUncheckedCreateWithoutUnidad_medidaInput>
  }

  export type materia_primaUpdateWithWhereUniqueWithoutUnidad_medidaInput = {
    where: materia_primaWhereUniqueInput
    data: XOR<materia_primaUpdateWithoutUnidad_medidaInput, materia_primaUncheckedUpdateWithoutUnidad_medidaInput>
  }

  export type materia_primaUpdateManyWithWhereWithoutUnidad_medidaInput = {
    where: materia_primaScalarWhereInput
    data: XOR<materia_primaUpdateManyMutationInput, materia_primaUncheckedUpdateManyWithoutUnidad_medidaInput>
  }

  export type materia_primaScalarWhereInput = {
    AND?: materia_primaScalarWhereInput | materia_primaScalarWhereInput[]
    OR?: materia_primaScalarWhereInput[]
    NOT?: materia_primaScalarWhereInput | materia_primaScalarWhereInput[]
    id_materia_prima?: IntFilter<"materia_prima"> | number
    nombre?: StringFilter<"materia_prima"> | string
    unidad_medida_id?: IntFilter<"materia_prima"> | number
    costo_unitario?: DecimalFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string
    stock_actual?: DecimalNullableFilter<"materia_prima"> | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFilter<"materia_prima"> | string
    fecha_registro?: DateTimeNullableFilter<"materia_prima"> | Date | string | null
    disponible?: BoolFilter<"materia_prima"> | boolean
  }

  export type productos_especialesUpsertWithWhereUniqueWithoutUnidadInput = {
    where: productos_especialesWhereUniqueInput
    update: XOR<productos_especialesUpdateWithoutUnidadInput, productos_especialesUncheckedUpdateWithoutUnidadInput>
    create: XOR<productos_especialesCreateWithoutUnidadInput, productos_especialesUncheckedCreateWithoutUnidadInput>
  }

  export type productos_especialesUpdateWithWhereUniqueWithoutUnidadInput = {
    where: productos_especialesWhereUniqueInput
    data: XOR<productos_especialesUpdateWithoutUnidadInput, productos_especialesUncheckedUpdateWithoutUnidadInput>
  }

  export type productos_especialesUpdateManyWithWhereWithoutUnidadInput = {
    where: productos_especialesScalarWhereInput
    data: XOR<productos_especialesUpdateManyMutationInput, productos_especialesUncheckedUpdateManyWithoutUnidadInput>
  }

  export type productos_especialesScalarWhereInput = {
    AND?: productos_especialesScalarWhereInput | productos_especialesScalarWhereInput[]
    OR?: productos_especialesScalarWhereInput[]
    NOT?: productos_especialesScalarWhereInput | productos_especialesScalarWhereInput[]
    id_producto_especial?: IntFilter<"productos_especiales"> | number
    id_producto?: IntFilter<"productos_especiales"> | number
    rendimiento?: DecimalFilter<"productos_especiales"> | Decimal | DecimalJsLike | number | string
    unidad_rendimiento?: IntNullableFilter<"productos_especiales"> | number | null
  }

  export type detalle_facturaCreateManyFacturasInput = {
    id_detalle?: number
    id_materia_prima?: number | null
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    unidad_medida?: number | null
  }

  export type detalle_facturaUpdateWithoutFacturasInput = {
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    materia_prima?: materia_primaUpdateOneWithoutDetalle_facturaNestedInput
    unidadesmedida?: unidadesmedidaUpdateOneWithoutDetalle_facturaNestedInput
  }

  export type detalle_facturaUncheckedUpdateWithoutFacturasInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type detalle_facturaUncheckedUpdateManyWithoutFacturasInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type detalle_facturaCreateManyMateria_primaInput = {
    id_detalle?: number
    id_factura?: number | null
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    unidad_medida?: number | null
  }

  export type kardex_materia_primaCreateManyMateria_primaInput = {
    id_kardex?: number
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_unitario: Decimal | DecimalJsLike | number | string
    costo_total: Decimal | DecimalJsLike | number | string
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    observaciones?: string | null
  }

  export type recetasCreateManyMateria_primaInput = {
    id_receta?: number
    id_producto?: number | null
    id_producto_especial?: number | null
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    unidad_medida?: number | null
    disponible?: boolean
  }

  export type detalle_facturaUpdateWithoutMateria_primaInput = {
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    facturas?: facturasUpdateOneWithoutDetalle_facturaNestedInput
    unidadesmedida?: unidadesmedidaUpdateOneWithoutDetalle_facturaNestedInput
  }

  export type detalle_facturaUncheckedUpdateWithoutMateria_primaInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_factura?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type detalle_facturaUncheckedUpdateManyWithoutMateria_primaInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_factura?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type kardex_materia_primaUpdateWithoutMateria_primaInput = {
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kardex_materia_primaUncheckedUpdateWithoutMateria_primaInput = {
    id_kardex?: IntFieldUpdateOperationsInput | number
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kardex_materia_primaUncheckedUpdateManyWithoutMateria_primaInput = {
    id_kardex?: IntFieldUpdateOperationsInput | number
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recetasUpdateWithoutMateria_primaInput = {
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    unidadesmedida?: unidadesmedidaUpdateOneWithoutRecetasNestedInput
    productos_terminados?: productos_terminadosUpdateOneWithoutRecetasNestedInput
    productos_especiales?: productos_especialesUpdateOneWithoutRecetasNestedInput
  }

  export type recetasUncheckedUpdateWithoutMateria_primaInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recetasUncheckedUpdateManyWithoutMateria_primaInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type facturasCreateManyMonedasInput = {
    id_factura?: number
    id_proveedor?: number | null
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
  }

  export type productos_terminadosCreateManyMonedasInput = {
    id_producto?: number
    nombre: string
    precio_venta: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    precio_produccion: Decimal | DecimalJsLike | number | string
    id_producto_especial?: number | null
  }

  export type facturasUpdateWithoutMonedasInput = {
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    detalle_factura?: detalle_facturaUpdateManyWithoutFacturasNestedInput
    proveedores?: proveedoresUpdateOneWithoutFacturasNestedInput
  }

  export type facturasUncheckedUpdateWithoutMonedasInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    id_proveedor?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutFacturasNestedInput
  }

  export type facturasUncheckedUpdateManyWithoutMonedasInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    id_proveedor?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productos_terminadosUpdateWithoutMonedasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kardex_productos?: kardex_productosUpdateManyWithoutProductos_terminadosNestedInput
    recetas?: recetasUpdateManyWithoutProductos_terminadosNestedInput
    producto_especial?: productos_especialesUpdateOneWithoutProducto_terminadoNestedInput
  }

  export type productos_terminadosUncheckedUpdateWithoutMonedasInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    kardex_productos?: kardex_productosUncheckedUpdateManyWithoutProductos_terminadosNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutProductos_terminadosNestedInput
  }

  export type productos_terminadosUncheckedUpdateManyWithoutMonedasInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio_venta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    precio_produccion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type kardex_productosCreateManyProductos_terminadosInput = {
    id_kardex?: number
    tipo_movimiento: string
    cantidad: Decimal | DecimalJsLike | number | string
    saldo: Decimal | DecimalJsLike | number | string
    costo_produccion?: Decimal | DecimalJsLike | number | string | null
    precio_venta?: Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: Date | string | null
    referencia?: string | null
    referencias_archivos?: kardex_productosCreatereferencias_archivosInput | string[]
    observaciones?: string | null
  }

  export type recetasCreateManyProductos_terminadosInput = {
    id_receta?: number
    id_materia_prima?: number | null
    id_producto_especial?: number | null
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    unidad_medida?: number | null
    disponible?: boolean
  }

  export type kardex_productosUpdateWithoutProductos_terminadosInput = {
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_produccion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    precio_venta?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    referencias_archivos?: kardex_productosUpdatereferencias_archivosInput | string[]
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kardex_productosUncheckedUpdateWithoutProductos_terminadosInput = {
    id_kardex?: IntFieldUpdateOperationsInput | number
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_produccion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    precio_venta?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    referencias_archivos?: kardex_productosUpdatereferencias_archivosInput | string[]
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kardex_productosUncheckedUpdateManyWithoutProductos_terminadosInput = {
    id_kardex?: IntFieldUpdateOperationsInput | number
    tipo_movimiento?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costo_produccion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    precio_venta?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    referencias_archivos?: kardex_productosUpdatereferencias_archivosInput | string[]
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recetasUpdateWithoutProductos_terminadosInput = {
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    unidadesmedida?: unidadesmedidaUpdateOneWithoutRecetasNestedInput
    materia_prima?: materia_primaUpdateOneWithoutRecetasNestedInput
    productos_especiales?: productos_especialesUpdateOneWithoutRecetasNestedInput
  }

  export type recetasUncheckedUpdateWithoutProductos_terminadosInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recetasUncheckedUpdateManyWithoutProductos_terminadosInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recetasCreateManyProductos_especialesInput = {
    id_receta?: number
    id_producto?: number | null
    id_materia_prima?: number | null
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    unidad_medida?: number | null
    disponible?: boolean
  }

  export type recetasUpdateWithoutProductos_especialesInput = {
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    unidadesmedida?: unidadesmedidaUpdateOneWithoutRecetasNestedInput
    materia_prima?: materia_primaUpdateOneWithoutRecetasNestedInput
    productos_terminados?: productos_terminadosUpdateOneWithoutRecetasNestedInput
  }

  export type recetasUncheckedUpdateWithoutProductos_especialesInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recetasUncheckedUpdateManyWithoutProductos_especialesInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidad_medida?: NullableIntFieldUpdateOperationsInput | number | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type facturasCreateManyProveedoresInput = {
    id_factura?: number
    id_moneda: number
    fecha_factura?: Date | string | null
    total: Decimal | DecimalJsLike | number | string
    estado?: boolean | null
    observaciones?: string | null
  }

  export type facturasUpdateWithoutProveedoresInput = {
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    detalle_factura?: detalle_facturaUpdateManyWithoutFacturasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutFacturasNestedInput
  }

  export type facturasUncheckedUpdateWithoutProveedoresInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    id_moneda?: IntFieldUpdateOperationsInput | number
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutFacturasNestedInput
  }

  export type facturasUncheckedUpdateManyWithoutProveedoresInput = {
    id_factura?: IntFieldUpdateOperationsInput | number
    id_moneda?: IntFieldUpdateOperationsInput | number
    fecha_factura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type detalle_facturaCreateManyUnidadesmedidaInput = {
    id_detalle?: number
    id_factura?: number | null
    id_materia_prima?: number | null
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unitario: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
  }

  export type recetasCreateManyUnidadesmedidaInput = {
    id_receta?: number
    id_producto?: number | null
    id_materia_prima?: number | null
    id_producto_especial?: number | null
    cantidad_requerida: Decimal | DecimalJsLike | number | string
    disponible?: boolean
  }

  export type materia_primaCreateManyUnidad_medidaInput = {
    id_materia_prima?: number
    nombre: string
    costo_unitario: Decimal | DecimalJsLike | number | string
    presentacion?: Decimal | DecimalJsLike | number | string
    stock_actual?: Decimal | DecimalJsLike | number | string | null
    codigo_barras: string
    fecha_registro?: Date | string | null
    disponible?: boolean
  }

  export type productos_especialesCreateManyUnidadInput = {
    id_producto_especial?: number
    id_producto: number
    rendimiento?: Decimal | DecimalJsLike | number | string
  }

  export type detalle_facturaUpdateWithoutUnidadesmedidaInput = {
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    facturas?: facturasUpdateOneWithoutDetalle_facturaNestedInput
    materia_prima?: materia_primaUpdateOneWithoutDetalle_facturaNestedInput
  }

  export type detalle_facturaUncheckedUpdateWithoutUnidadesmedidaInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_factura?: NullableIntFieldUpdateOperationsInput | number | null
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_facturaUncheckedUpdateManyWithoutUnidadesmedidaInput = {
    id_detalle?: IntFieldUpdateOperationsInput | number
    id_factura?: NullableIntFieldUpdateOperationsInput | number | null
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type recetasUpdateWithoutUnidadesmedidaInput = {
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    materia_prima?: materia_primaUpdateOneWithoutRecetasNestedInput
    productos_terminados?: productos_terminadosUpdateOneWithoutRecetasNestedInput
    productos_especiales?: productos_especialesUpdateOneWithoutRecetasNestedInput
  }

  export type recetasUncheckedUpdateWithoutUnidadesmedidaInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recetasUncheckedUpdateManyWithoutUnidadesmedidaInput = {
    id_receta?: IntFieldUpdateOperationsInput | number
    id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    id_materia_prima?: NullableIntFieldUpdateOperationsInput | number | null
    id_producto_especial?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad_requerida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type materia_primaUpdateWithoutUnidad_medidaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    detalle_factura?: detalle_facturaUpdateManyWithoutMateria_primaNestedInput
    kardex_materia_prima?: kardex_materia_primaUpdateManyWithoutMateria_primaNestedInput
    recetas?: recetasUpdateManyWithoutMateria_primaNestedInput
  }

  export type materia_primaUncheckedUpdateWithoutUnidad_medidaInput = {
    id_materia_prima?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    detalle_factura?: detalle_facturaUncheckedUpdateManyWithoutMateria_primaNestedInput
    kardex_materia_prima?: kardex_materia_primaUncheckedUpdateManyWithoutMateria_primaNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutMateria_primaNestedInput
  }

  export type materia_primaUncheckedUpdateManyWithoutUnidad_medidaInput = {
    id_materia_prima?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    costo_unitario?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presentacion?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock_actual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    codigo_barras?: StringFieldUpdateOperationsInput | string
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type productos_especialesUpdateWithoutUnidadInput = {
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    producto_terminado?: productos_terminadosUpdateOneWithoutProducto_especialNestedInput
    recetas?: recetasUpdateManyWithoutProductos_especialesNestedInput
  }

  export type productos_especialesUncheckedUpdateWithoutUnidadInput = {
    id_producto_especial?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    producto_terminado?: productos_terminadosUncheckedUpdateOneWithoutProducto_especialNestedInput
    recetas?: recetasUncheckedUpdateManyWithoutProductos_especialesNestedInput
  }

  export type productos_especialesUncheckedUpdateManyWithoutUnidadInput = {
    id_producto_especial?: IntFieldUpdateOperationsInput | number
    id_producto?: IntFieldUpdateOperationsInput | number
    rendimiento?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use FacturasCountOutputTypeDefaultArgs instead
     */
    export type FacturasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacturasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Materia_primaCountOutputTypeDefaultArgs instead
     */
    export type Materia_primaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Materia_primaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonedasCountOutputTypeDefaultArgs instead
     */
    export type MonedasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonedasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Productos_terminadosCountOutputTypeDefaultArgs instead
     */
    export type Productos_terminadosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Productos_terminadosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Productos_especialesCountOutputTypeDefaultArgs instead
     */
    export type Productos_especialesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Productos_especialesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProveedoresCountOutputTypeDefaultArgs instead
     */
    export type ProveedoresCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProveedoresCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnidadesmedidaCountOutputTypeDefaultArgs instead
     */
    export type UnidadesmedidaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnidadesmedidaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detalle_facturaDefaultArgs instead
     */
    export type detalle_facturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = detalle_facturaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use facturasDefaultArgs instead
     */
    export type facturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = facturasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversionFactorDefaultArgs instead
     */
    export type ConversionFactorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversionFactorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kardex_materia_primaDefaultArgs instead
     */
    export type kardex_materia_primaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kardex_materia_primaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kardex_productosDefaultArgs instead
     */
    export type kardex_productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kardex_productosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use materia_primaDefaultArgs instead
     */
    export type materia_primaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = materia_primaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monedasDefaultArgs instead
     */
    export type monedasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monedasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productos_terminadosDefaultArgs instead
     */
    export type productos_terminadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productos_terminadosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productos_especialesDefaultArgs instead
     */
    export type productos_especialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productos_especialesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use proveedoresDefaultArgs instead
     */
    export type proveedoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = proveedoresDefaultArgs<ExtArgs>
    /**
     * @deprecated Use recetasDefaultArgs instead
     */
    export type recetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = recetasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use unidadesmedidaDefaultArgs instead
     */
    export type unidadesmedidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = unidadesmedidaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}